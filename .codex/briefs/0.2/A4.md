# A4 Alignment Brief

## Intent
- Run shared conformance vectors in the TS kernel to validate L0 semantics.
- Ensure canonicalization and delta/effect rules are enforced consistently with Rust.

## Derived Constraints (binding)
- Script `packages/tf-lang-l0-ts/scripts/run-vectors.ts` reads JSON from `tests/vectors/`.
- Vector schema: `bytecode.version` = "L0", `bytecode.regs`, and `bytecode.instrs: {op,...}[]`.
- Exit code 0 only if all vectors match expected `{delta,effect}`; non-zero otherwise.
- Runner normalizes delta and effect before compare (effect arrays sorted unique).
- Runner must use canonical bytes and BLAKE3 for any hash comparisons.
- Final state for each vector is taken from register 0; pointers must be RFC6901.
- On mismatch, print canonical JSON hex for expected vs actual using `canonicalJsonBytes`.

## Invariants & Oracles
- `pnpm -C packages/tf-lang-l0-ts vectors` prints ✓ for every vector.
- Mismatch in delta or effect causes canonical diff output and non-zero exit.
- Works without network access; vectors load from repo only.

## Checklist for Coder
- [ ] Mirrors TS and Rust behavior
- [ ] Uses canonical bytes (no JSON.stringify)
- [ ] Final state ends in r0
- [ ] JSON Pointers start with "/"
- [ ] Effects NF sorted unique
- [ ] Diff output uses canonicalJsonBytes → hex
- [ ] Proof tags emitted when DEV_PROOFS=1 (if relevant)

## Lessons referenced
- A1: canonical JSON + BLAKE3, float rejection
- A2: snapshot hashing parity across runtimes
- A3: vector structure, delta/effect expectations
