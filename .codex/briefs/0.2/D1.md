# D1 Alignment Brief

## Intent
- Extend claims API to serve counts and clauses from SQLite datasets with canonical hashes.
- Expose deterministic query responses enabling demo evidence sampling.

## Derived Constraints (binding)
- `services/claims-api-ts` reads from `acts.sqlite` and `clauses.sqlite`.
- Endpoints:
  - `/facts/count` → `{ dataset_version, query_hash, count }`
  - `/clauses` → `{ dataset_version, query_hash, clauses[] }`
- `query_hash` = BLAKE3(canonicalJsonBytes({endpoint, params})).
- `dataset_version` is deterministic (content hash of SQLite schema + row hashes), never wall-clock time.
- Must return at least 10 evidence samples for demo subset.
- Responses are canonical JSON; floats in queries or data reject with E_L0_FLOAT.

## Invariants & Oracles
- Curl requests return consistent counts/clauses across runs.
- Querying same parameters yields identical `query_hash` and results.

## Checklist for Coder
- [ ] Mirrors TS and Rust
- [ ] Uses canonical bytes (no JSON.stringify)
- [ ] Final state ends in r0
- [ ] JSON Pointers start with "/"
- [ ] Effects NF sorted unique
- [ ] Proof tags emitted when DEV_PROOFS=1 (if relevant)

## Lessons referenced
- A1: canonical bytes and float rejection
- A2: hash equality expectations
- C1: host round-trip patterns
