# A7 Alignment Brief

## Intent

* Add five minimal, deterministic guardrails to L0 with TS/Rust parity:

  1. `assert/dimension_eq@0.1`
  2. `lens/mod@0.1`
  3. `assert/bounds@0.1`
  4. `probe/delta_bounded@0.1`
  5. `correct/saturate@0.1` (explicit, auditable correction)
* Ship conformance vectors and run them via existing TS/Rust runners and CI from A4–A6.

## Derived Constraints (binding)

* **Determinism:** integer-only L0; reject non-integer numbers (A1/A2). No floats introduced by these ops.
* **Op surface:** expose as CALL-style transforms with `tf://…@0.1` ids (gated by `sig_hash`).
* **JSON Pointers:** RFC6901; invalid traversal → `null` (per A4/A5); indices validated; arrays padded with objects where required.
* **Effects:** normalized form (sorted, unique) for read/write effects.
* **Proof tags:** when `DEV_PROOFS=1`, emit appropriate proof tags (witness/normalization/refutation) for assertions and probes.
* **Saturate journaling:** `correct/saturate` must append `{field, before, after, reason}` to the journal.
* **CI integration:** no new workflow; A6 conformance job must exercise and pass TS+RS runners on the new vectors.

## Invariants & Oracles

* Existing A1–A6 vectors remain green; A7 adds coverage only.
* **Per-op expectations:**

  * `dimension_eq`: mismatch ⇒ hard fail with clear path; match ⇒ no state change beyond reads.
  * `lens/mod`: `(x mod M)` canonicalized into `[0, M)`; reject `M ≤ 0`.
  * `bounds`: integers must satisfy `{min?, max?, inclusive?}`; out-of-range ⇒ fail with offender value.
  * `delta_bounded`: for a sequence at pointer, assert `|x_t − x_{t−1}| ≤ B`; on fail, evidence includes first failing index and delta.
  * `saturate`: clamp integer to `[min,max]` only when out of range; emit journal note; otherwise no-op.

## Checklist for Coder

* [ ] TS & Rust implementations mirror signatures and edge cases.
* [ ] Reject floats/non-integers; validate `M > 0` for `lens/mod`.
* [ ] RFC6901 pointer handling; invalid traversal returns `null`; index validation + padding upheld.
* [ ] Effects in NF (sorted, unique) with correct read/write coverage.
* [ ] Proof tags under `DEV_PROOFS=1` (assert/probe ops).
* [ ] `correct/saturate` writes a journal entry `{field, before, after, reason}`.
* [ ] Add vectors for each op; keep patches minimal and test-backed.

## Lessons referenced

* A1–A2: canonicalization & integer-only; cross-runtime hashing
* A3: vector composition & structure
* A4–A5: runner semantics (pointers null-on-invalid, lens dst-only) and parity
* A6: CI conformance job (both runners green; artifacts on fail)
