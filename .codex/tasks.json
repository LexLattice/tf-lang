{
  "T1_1": {
    "ACCEPTANCE": "# Acceptance — T1_1\n\n## Evidence\n- `schema/tf-spec.schema.json` (JSON Schema)\n- `docs/specs/tf-spec.md` (schema overview; field table)\n- `examples/specs/` (≥3 JSON examples; each explains intent)\n- TS/Rust adapters:\n  - TS: `packages/tf-lang-l0-ts/src/spec/adapter.ts`\n  - Rust: `packages/tf-lang-l0-rs/src/spec/adapter.rs`\n- Validation proof:\n  - CI job output that each example validates against the schema\n  - Round-trip tests passing in both runtimes (parse→canon→serialize)\n\n## CI\n- Job **`tf-spec`**:\n  - Validate `examples/specs/*.json` against `schema/tf-spec.schema.json` (AJV or similar as a **dev** dep).\n  - Run TS/Rust adapter round-trip tests.\n  - Upload an artifact `tf-spec/validation.txt` listing each example and “OK”.\n- (Optional, nice): add a pre-commit hook that runs schema lint; do not gate merges on local hooks.\n\n## Determinism\n- Given the same example input, the adapter round-trip must produce **byte-identical canonical JSON** (use canonical JSON encoder in both runtimes).\n- CI re-runs determinism tests twice to assert equality (no time/env dependencies).\n\n## Parity\n- TS and Rust adapters produce structurally equivalent representations for the same example inputs (exact field names and value shapes).\n\n## Docs\n- `docs/specs/tf-spec.md` added/updated with:\n  - What the schema covers (scope)\n  - Examples section referencing `examples/specs/`\n  - Versioning note for future extensions\n",
    "BLOCKERS": "schema_changes_allowed: true  # this card defines the initial schema\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - tracing overhead when DEV_PROOFS=0\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_1 — Intent Schema (tf-spec)\n\n1) Provide a JSON Schema at `schema/tf-spec.schema.json` that defines the core intent format.\n   - *Why:* Everything (plan/check/trace) builds on a stable, validated schema.\n\n2) Author documentation explaining the schema and its fields, with at least three minimal, real examples.\n   - *Why:* Makes the format legible and reviewable; anchors future extensions.\n\n3) Include three example specs under `examples/specs/` that validate against the schema.\n   - *Why:* Executable samples serve as oracles and onboarding material.\n\n4) Implement **round-trip adapters** (parse → canonical → serialize) in **TypeScript** and **Rust** for the subset covered by the examples.\n   - *Why:* Proves cross-runtime parity and prevents “schema drift” between implementations.\n"
  },
  "T1_2": {
    "ACCEPTANCE": "# Acceptance — T1_2\n\n## Evidence\n- `oracles/core/` package directory.\n- Oracle interfaces and result type definitions.\n- Oracle stubs with unit tests.\n- JSON and Markdown output for explainable failures.\n\n## CI\n- Job **`oracle-core`**:\n  - Builds the `oracles/core` package.\n  - Runs unit tests for the oracle stubs.\n  - Verifies that oracles are pure, deterministic, and side-effect free.\n\n## Determinism\n- Oracles must be deterministic, always producing the same result for the same input.\n\n## Docs\n- README file in `oracles/core/` explaining the purpose and usage of the oracle library.\n",
    "BLOCKERS": "schema_changes_allowed: false # This card builds on the T1.1 schema\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_2 — Oracle Standard Library\n\n1)  Create an `oracles/core` package to house the standard library of oracles.\n    - *Why*: A centralized package provides a clear entry point for using and extending the oracle library.\n\n2)  Define the core oracle interfaces and a common result type with explainable failures.\n    - *Why*: A shared interface and result type ensure a consistent and predictable experience for developers.\n\n3)  Implement stubs for the core oracles with unit tests.\n    - *Why*: Stubs provide a starting point for implementation and allow for early integration and testing.\n"
  },
  "T1_3": {
    "ACCEPTANCE": "# Acceptance — T1_3\n\n## Evidence\n- Implementation of the determinism oracle.\n- Property tests for the oracle.\n- Mutation tests that demonstrate the oracle's detection capabilities.\n- A report showing that the oracle fails on any nondeterministic float, time, or I/O usage.\n\n## CI\n- Job **`determinism-oracle`**:\n  - Runs property tests for the oracle.\n  - Runs mutation tests to ensure the oracle's effectiveness.\n\n## Determinism\n- The oracle itself must be deterministic.\n- The oracle must enforce determinism in the system under test.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_3 — Determinism Oracle\n\n1)  Implement the determinism oracle, which ensures that the same inputs and seed produce an identical final state and key checkpoints.\n    - *Why*: This is fundamental for enabling replay, parity testing between TS and Rust, and ensuring auditability.\n\n2)  Develop property tests to validate the oracle's functionality.\n    - *Why*: Property tests are essential for ensuring the oracle is robust and can handle a wide range of inputs.\n\n3)  Create mutation tests to demonstrate that the oracle can detect nondeterministic behavior.\n    - *Why*: Mutation tests provide confidence that the oracle is effective at its job.\n"
  },
  "T1_4": {
    "ACCEPTANCE": "# Acceptance — T1_4\n\n## Evidence\n- Implementation of the conservation oracle.\n- Test fixtures for the oracle.\n- A report showing clear diff output when the oracle detects leakage or orphan deltas.\n\n## CI\n- Job **`conservation-oracle`**:\n  - Runs the conservation oracle with the test fixtures.\n\n## Determinism\n- The oracle must be deterministic.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_4 — Conservation Oracle\n\n1)  Implement the conservation oracle, which ensures that assets and balances are conserved, accounting for declared effects like fees and fills.\n    - *Why*: This is a core safety feature for the crypto-bot ledger.\n\n2)  Create test fixtures to validate the oracle's functionality.\n    - *Why*: Fixtures provide a reliable way to test the oracle against known scenarios.\n"
  },
  "T1_5": {
    "ACCEPTANCE": "# Acceptance — T1_5\n\n## Evidence\n- Implementation of the idempotence oracle.\n- Randomized property tests for the oracle.\n- A report showing that the oracle fails when side effects are double-applied.\n\n## CI\n- Job **`idempotence-oracle`**:\n  - Runs the randomized property tests for the oracle.\n\n## Determinism\n- The oracle must be deterministic.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_5 — Idempotence Oracle\n\n1)  Implement the idempotence oracle, which ensures that reapplying effects does not change the state after the first application.\n    - *Why*: This is crucial for enabling reliable retries and exactly-once semantics.\n\n2)  Develop randomized property tests to validate the oracle's functionality.\n    - *Why*: Randomized property tests are essential for ensuring the oracle is robust and can handle a wide range of scenarios.\n"
  },
  "T1_6": {
    "ACCEPTANCE": "# Acceptance — T1_6\n\n## Evidence\n- Implementation of the transport/region oracle.\n- The region visualizer tool.\n- A report showing the exact path and offending operation for a violation.\n\n## CI\n- Job **`transport-region-oracle`**:\n  - Runs tests for the transport/region oracle.\n\n## Determinism\n- The oracle must be deterministic.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_6 — Transport/Region Oracle\n\n1)  Implement the transport/region oracle, which ensures that lenses read and write within their declared regions and that merges respect these boundaries.\n    - *Why*: This is essential for preventing accidental cross-region data corruption.\n\n2)  Create a region visualizer to help developers understand the regions and their boundaries.\n    - *Why*: A visualizer makes it easier to reason about and debug region-related issues.\n"
  },
  "T1_7": {
    "ACCEPTANCE": "# Acceptance — T1_7\n\n## Evidence\n- Implementation of the conservativity oracle.\n- The call-graph inspection tool.\n- A report showing that the oracle flags any extra or undeclared effects.\n\n## CI\n- Job **`conservativity-oracle`**:\n  - Runs tests for the conservativity oracle.\n\n## Determinism\n- The oracle must be deterministic.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_7 — Conservativity Oracle (CALL Gate)\n\n1)  Implement the conservativity oracle, which ensures that external calls through a CALL gate only emit allowed effects and schemas.\n    - *Why*: This is crucial for enforcing boundaries with untrusted adapters.\n\n2)  Create a call-graph inspection tool to help visualize the call graph and identify potential issues.\n    - *Why*: A visual tool makes it easier to understand the flow of control and data.\n"
  },
  "T1_8": {
    "ACCEPTANCE": "# Acceptance — T1_8\n\n## Evidence\n- The property-based testing harnesses for TS and Rust.\n- The implementation of reproducible seeds and shrinkers.\n- A report showing the seed corpus emitted on a failure.\n\n## CI\n- Job **`oracle-harness`**:\n  - Runs the oracle harnesses in both TS and Rust.\n  - The job should have a time budget of less than 5 minutes.\n\n## Determinism\n- The test harnesses must be deterministic, with reproducible seeds leading to the same test cases.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_8 — Oracle Harness (Property-Based Testing)\n\n1)  Build property-based testing harnesses in both TS and Rust to stress the oracles with randomized, seeded inputs.\n    - *Why*: This provides confidence in the oracles and helps prevent regressions.\n\n2)  Implement support for reproducible seeds and shrinkers in the harnesses.\n    - *Why*: Reproducible seeds are essential for debugging failures, and shrinkers help to find the minimal failing case.\n"
  },
  "T1_9": {
    "ACCEPTANCE": "# Acceptance — T1_9\n\n## Evidence\n- The mutation scripts.\n- The generated coverage matrix.\n- A report showing a kill-rate of at least 80% for targeted mutants.\n\n## CI\n- Job **`oracle-strength`**:\n  - Runs the mutation tests and generates the coverage matrix.\n  - The job should fail if the kill-rate is less than 80%.\n\n## Determinism\n- The mutation testing process must be deterministic.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T1_9 — Oracle Strength (Mutation Testing)\n\n1)  Develop mutation scripts that inject controlled, realistic faults into the minimal crypto-bot models from T5.\n    - *Why*: This is essential for proving that the oracles are effective at catching faults and avoiding a false sense of security.\n\n2)  Generate a coverage matrix that shows which oracles caught which mutants.\n    - *Why*: The coverage matrix provides a clear and concise way to visualize the strength of the oracle suite.\n"
  },
  "T2_1": {
    "ACCEPTANCE": "# Acceptance — T2_1\n\n## Evidence\n- The `tf-check` CLI executable.\n- The implementation of the `run`, `report`, and `ci` subcommands.\n- Example of the machine-readable JSON output.\n- Example of the human-readable summary output.\n\n## CI\n- Job **`tf-check-cli`**:\n  - Builds the `tf-check` CLI.\n  - Runs the CLI and verifies that the exit codes correctly map to pass/fail scenarios.\n\n## Docs\n- A README file for the `tf-check` CLI, explaining its usage and subcommands.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T2_1 — `tf-check` CLI Skeleton\n\n1)  Scaffold a `tf-check` CLI tool with subcommands `run`, `report`, and `ci`.\n    - *Why*: This provides a single, unified command for running oracles, which makes the alignment process frictionless for developers.\n\n2)  The CLI should produce both machine-readable JSON and a human-readable summary as output.\n    - *Why*: Machine-readable output is essential for CI integration, while a human-readable summary is important for developer experience.\n\n3)  Ensure that the CLI's exit codes correctly map to pass/fail scenarios.\n    - *Why*: This is crucial for reliable CI integration.\n"
  },
  "T2_2": {
    "ACCEPTANCE": "# Acceptance — T2_2\n\n## Evidence\n- The `adapters/ts` and `adapters/rust` packages.\n- Example usage for both adapters.\n- A report showing that the same spec and oracles can be run on both runtimes from the `tf-check` CLI.\n\n## CI\n- Job **`language-adapters`**:\n  - Runs the same spec and oracles on both the TS and Rust runtimes using the `tf-check` CLI.\n\n## Parity\n- The primary goal of this task is to enable parity testing. The adapters must be able to run the same tests and produce comparable results.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T2_2 — Language Adapters (TS & Rust)\n\n1)  Implement language adapters for both TypeScript and Rust that provide a uniform API for running systems under test and collecting traces.\n    - *Why*: This is crucial for achieving parity across different runtimes.\n\n2)  Provide example usage for both adapters.\n    - *Why*: Examples are essential for onboarding and demonstrating correct usage.\n"
  },
  "T2_3": {
    "ACCEPTANCE": "# Acceptance — T2_3\n\n## Evidence\n- The implementation of the `@tf` decorator in TS and the `#[tf]` macro in Rust.\n- The implementation of the mapper.\n- An example of the generated coverage matrix, showing the mapping between intents and code paths, and the percentage of covered intents.\n\n## CI\n- Job **`concept-code-mapper`**:\n  - Runs the mapper and generates the coverage matrix.\n\n## Docs\n- Documentation for the annotations and the mapper.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T2_3 — Concept↔Code Annotations & Mapper\n\n1)  Implement annotations for both TypeScript (`@tf(\"...\")`) and Rust (`#[tf(id=\"...\")]`) that bind code units to `tf-spec` intents.\n    - *Why*: This creates a direct link between the high-level intent and the low-level implementation.\n\n2)  Create a mapper that uses these annotations to generate a coverage matrix and provide context for reviewers.\n    - *Why*: The coverage matrix makes it easy to see which intents are covered by the implementation, and the reviewer context helps to understand the purpose of the code.\n"
  },
  "T2_4": {
    "ACCEPTANCE": "# Acceptance — T2_4\n\n## Evidence\n- The static HTML generator.\n- An example of the generated HTML report, including drill-down pages.\n- The report saved as a CI artifact.\n\n## CI\n- Job **`coverage-report`**:\n  - Runs the static HTML generator and saves the report as a CI artifact.\n\n## Docs\n- Documentation for the coverage report generator.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T2_4 — Coverage Report (JSON→HTML)\n\n1)  Create a static HTML generator that produces a human-readable alignment report from the T2.3 matrix and oracle results.\n    - *Why*: This provides clarity for PR reviews.\n\n2)  The report should include drill-down pages for each intent and oracle, with links to traces.\n    - *Why*: Drill-down pages make it easy to investigate specific issues.\n"
  },
  "T2_5": {
    "ACCEPTANCE": "# Acceptance — T2_5\n\n## Evidence\n- The `.github/workflows/tf-check.yml` file.\n- A PR showing the status check from the workflow.\n- A PR showing the uploaded HTML artifacts.\n\n## CI\n- The workflow itself is the CI implementation. It must run on PRs and demonstrate the required behavior.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T2_5 — GitHub Action Integration\n\n1)  Create a GitHub Actions workflow at `.github/workflows/tf-check.yml` that blocks merges on misalignment and attaches artifacts.\n    - *Why*: This enforces the alignment standard by integrating it directly into the development workflow.\n\n2)  The workflow should include caching to improve performance.\n    - *Why*: Caching reduces the time it takes to run the workflow, which improves developer productivity.\n"
  },
  "T3_1": {
    "ACCEPTANCE": "# Acceptance — T3_1\n\n## Evidence\n- Tag definitions (structs/enums) in the codebase.\n- Code for the emitters at key operations.\n- Golden-file tests that verify the output of the emitters.\n- A stable tag schema document.\n\n## CI\n- Job **`proof-tags`**:\n  - Runs golden-file tests to ensure the stability of the tag schema and emitter output.\n  - Verifies that tags only appear when explicitly enabled.\n\n## Performance\n- The implementation must be designed to have zero overhead when proofs are disabled (verified in T3.2).\n",
    "BLOCKERS": "schema_changes_allowed: true # This card defines a new tag schema\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - tracing overhead when DEV_PROOFS=0\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n  tracing_overhead:\n    allowed: false\n",
    "END_GOAL": "# T3_1 — Proof Tags: Types & Emission Points\n\n1)  Define and implement structured trace events (tags) for: Witness, Normalization, Transport, Refutation, and Conservativity.\n    - *Why*: This allows a reviewer to *follow the proof* of alignment in the system's execution trace.\n\n2)  Instrument key operations in the codebase to emit these tags.\n    - *Why*: Placing emitters at critical points ensures that the trace contains all the necessary information for verification.\n\n3)  Ensure the tag schema is stable and that tags only appear when a `DEV_PROOFS` flag is enabled.\n    - *Why*: A stable schema is crucial for tooling, and conditional emission is key for performance.\n"
  },
  "T3_2": {
    "ACCEPTANCE": "# Acceptance — T3_2\n\n## Evidence\n- The implementation of the `DEV_PROOFS` toggle and associated guards.\n- A performance report showing that the overhead is less than or equal to 1% when tracing is disabled.\n\n## CI\n- Job **`zero-overhead-tracing`**:\n  - Runs benchmarks to measure the performance overhead of the tracing mechanism when it is disabled.\n\n## Performance\n- The key acceptance criterion is that the overhead of the tracing mechanism is less than or equal to 1% when it is disabled.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - tracing overhead when DEV_PROOFS=0\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n  tracing_overhead:\n    allowed: false\n",
    "END_GOAL": "# T3_2 — DEV_PROOFS Toggle & Zero-Overhead Off-Path\n\n1)  Implement a `DEV_PROOFS` toggle that makes tracing fully optional.\n    - *Why*: This ensures that there is no performance regression in production.\n\n2)  Use compile-time and/or runtime guards to ensure that the tracing code is completely removed when the toggle is off.\n    - *Why*: This is the mechanism for achieving zero overhead.\n"
  },
  "T3_3": {
    "ACCEPTANCE": "# Acceptance — T3_3\n\n## Evidence\n- The library for lens merge rules and region filters.\n- Tests and diagrams that document the behavior of the library.\n- A report showing that the TS and Rust implementations have the same behavior on golden test cases.\n\n## CI\n- Job **`lens-merge-rules`**:\n  - Runs tests for the library in both TS and Rust.\n\n## Parity\n- The TS and Rust implementations must have the same behavior on a set of golden test cases.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T3_3 — Lens Merge Rules & Region Filters\n\n1)  Implement a library that defines canonical merge semantics and region scoping for lenses.\n    - *Why*: This ensures consistent state evolution and provides a solid foundation for oracle checks.\n\n2)  Create tests and diagrams to document the behavior of the library.\n    - *Why*: Clear documentation is essential for understanding and using the library correctly.\n"
  },
  "T3_4": {
    "ACCEPTANCE": "# Acceptance — T3_4\n\n## Evidence\n- The unified trace sink implementation.\n- The `tf-check trace` subcommand implementation.\n- Example of the JSONL output from the trace sink.\n- Sample sessions demonstrating the filtering capabilities of the `trace` subcommand.\n\n## CI\n- Job **`trace-sink`**:\n  - Runs tests for the trace sink and the `trace` subcommand, including tests for the filtering functionality.\n  - Tests the streaming capabilities of the sink with a large trace log.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T3_4 — Unified Trace Sink + Filters\n\n1)  Implement a unified trace sink that outputs in JSONL format.\n    - *Why*: A unified sink simplifies the process of collecting and analyzing trace data.\n\n2)  Add a `trace` subcommand to the `tf-check` CLI with filters for region, gate, oracle, and tag.\n    - *Why*: This provides a powerful tool for developers to inspect and debug trace data, which improves reviewer ergonomics.\n"
  },
  "T3_5": {
    "ACCEPTANCE": "# Acceptance — T3_5\n\n## Evidence\n- The parity test suite.\n- The test fixtures used by the parity suite.\n- A report showing that all checkpoints are equal, or a clear explanation of any diffs.\n\n## CI\n- Job **`cross-runtime-parity`**:\n  - Runs the parity test suite across both TS and Rust runtimes.\n\n## Parity\n- The core of this task is to verify parity. The test suite must ensure that all checkpoints are byte-identical, or that any differences are explained.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T3_5 — Cross-Runtime Parity Suite\n\n1)  Implement a parity test suite that ensures that the same seeds produce byte-identical checkpoints across both TypeScript and Rust.\n    - *Why*: This provides confidence in the dual-stack implementation.\n\n2)  Create test fixtures to be used by the parity suite.\n    - *Why*: Fixtures provide a reliable way to test against known scenarios.\n"
  },
  "T4_1": {
    "ACCEPTANCE": "# Acceptance — T4_1\n\n## Evidence\n- The implementation of the planner.\n- An example of the branch graph output.\n- An example of the output showing at least 3 viable plans with scores and rationale.\n\n## CI\n- Job **`tf-plan`**:\n  - Runs the planner with an example `tf-spec` and verifies the output format.\n\n## Docs\n- Documentation for the planner, explaining its usage and output format.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T4_1 — `tf-plan` Branch Space Enumeration\n\n1)  Implement a planner that turns a `tf-spec` into a set of design branches, representing options for each component.\n    - *Why*: This allows for exploring the design space before committing to a single implementation.\n\n2)  The planner should emit a branch graph and scores for at least 3 viable plans, including the rationale for each.\n    - *Why*: This provides a clear and concise way to compare different design options.\n"
  },
  "T4_2": {
    "ACCEPTANCE": "# Acceptance — T4_2\n\n## Evidence\n- The script or CLI tool for creating PR skeletons.\n- Links to the PRs generated by the tool.\n\n## CI\n- Job **`pr-scaffolder`**:\n  - Runs the PR scaffolder tool.\n- The CI jobs in the generated PRs must build, run `tf-check`, and attach reports.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T4_2 — PR Scaffolder (N Branches)\n\n1)  Implement a script or CLI tool that spins up parallel branches, one for each plan in the T4.1 plan graph.\n    - *Why*: This allows for empirical, apples-to-apples comparison of different design choices.\n\n2)  Each branch should be wired to the same oracles and CI.\n    - *Why*: This ensures that all designs are tested under the same conditions.\n"
  },
  "T4_3": {
    "ACCEPTANCE": "# Acceptance — T4_3\n\n## Evidence\n- The merge guidance tool.\n- An example of the aggregated comparison report.\n- An example of a recommendation with a clear rationale and links to artifacts.\n\n## CI\n- Job **`merge-guidance`**:\n  - Runs the merge guidance tool and generates the comparison report.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T4_3 — Merge Guidance Report\n\n1)  Implement a tool that summarizes oracle outcomes and trade-offs to help pick a winning design.\n    - *Why*: This allows for decisions to be based on proofs, not vibes.\n\n2)  The tool should produce an aggregated comparison report with a recommendation, a clear rationale, and links to artifacts.\n    - *Why*: This provides a clear and concise summary of the results of the design exploration.\n"
  },
  "T5_1": {
    "ACCEPTANCE": "# Acceptance — T5_1\n\n## Evidence\n- The pilot repository with the specified module boundaries.\n- \"Hello-world\" examples within each module.\n- Build scripts for both TS and Rust.\n\n## CI\n- Job **`pilot-scaffold`**:\n  - Builds the pilot repository in both TS and Rust.\n  - Runs linting and basic tests on the skeleton.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_1 — Repo Scaffold & Module Boundaries\n\n1)  Scaffold a minimal, clean pilot repository to host the crypto-bot demo.\n    - *Why*: This provides a concrete proving ground for the 0.3 release.\n\n2)  The repo should have the following module boundaries: `/marketdata`, `/strategy`, `/risk`, `/execution`, and `/accounting`.\n    - *Why*: Clear module boundaries are essential for a clean and maintainable architecture.\n\n3)  The repo should include \"hello-world\" examples and be wired to the language adapters.\n    - *Why*: This provides a starting point for development and demonstrates how the different parts of the system fit together.\n"
  },
  "T5_2": {
    "ACCEPTANCE": "# Acceptance — T5_2\n\n## Evidence\n- The replay engine.\n- The canonicalization rules.\n- Documentation for float handling.\n- Test results showing that the same seed produces identical frames.\n\n## CI\n- Job **`marketdata-replay`**:\n  - Runs tests on the replay engine to verify its determinism.\n\n## Determinism\n- The replay engine must be fully deterministic.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_2 — MarketData Replay (Canonicalization)\n\n1)  Build a replay engine that provides a deterministic input stream with seeded slicing.\n    - *Why*: This is essential for conducting repeatable experiments.\n\n2)  The engine should include canonicalization rules and documented float handling.\n    - *Why*: This ensures that the input data is consistent and predictable.\n"
  },
  "T5_3": {
    "ACCEPTANCE": "# Acceptance — T5_3\n\n## Evidence\n- The two pluggable trading strategies.\n- The shared effect schema.\n- The intent ID annotations in the strategy code.\n\n## CI\n- Job **`strategy-variants`**:\n  - Runs both strategies under `tf-check`.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_3 — Strategy Variants (2 Minimal)\n\n1)  Implement two minimal, pluggable trading strategies: one based on momentum and one on mean-reversion.\n    - *Why*: This provides realistic diversity for the T4 planner.\n\n2)  Both strategies should use the same effect schema and be annotated with intent IDs.\n    - *Why*: This ensures that the strategies can be compared on an apples-to-apples basis and that they are correctly linked to the high-level intents.\n"
  },
  "T5_4": {
    "ACCEPTANCE": "# Acceptance — T5_4\n\n## Evidence\n- The risk evaluator.\n- The `reject` and `trim` order effects.\n- Test results showing that the oracles reliably detect any breaches of the risk invariants.\n\n## CI\n- Job **`risk-module`**:\n  - Runs tests on the risk evaluator to ensure it correctly enforces the specified caps and thresholds.\n  - Runs the conservation and idempotence oracles to verify that they detect breaches.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_4 — Risk Module (Position & Drawdown Caps)\n\n1)  Implement a risk evaluator that enforces risk invariants expressed in `tf-spec`, such as position and drawdown caps.\n    - *Why*: This is central to the conservation and idempotence checks.\n\n2)  The evaluator should be able to produce effects, such as rejecting or trimming orders.\n    - *Why*: This allows the system to react to risk violations in a controlled way.\n"
  },
  "T5_5": {
    "ACCEPTANCE": "# Acceptance — T5_5\n\n## Evidence\n- The paper-trading adapter.\n- The latency model.\n- The gate check hooks.\n- A report showing that any undeclared effect is blocked and reported.\n\n## CI\n- Job **`execution-adapter`**:\n  - Runs tests on the execution adapter to verify its functionality, including the gate checks.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_5 — Execution Adapter with CALL Gate\n\n1)  Build a simulated paper-trading execution adapter that is constrained by the Conservativity oracle.\n    - *Why*: This tests the gate/oracle path end-to-end.\n\n2)  The adapter should include a latency model and gate check hooks.\n    - *Why*: A latency model makes the simulation more realistic, and gate check hooks are essential for enforcing the conservativity constraint.\n"
  },
  "T5_6": {
    "ACCEPTANCE": "# Acceptance — T5_6\n\n## Evidence\n- The ledger store.\n- The lens operations.\n- Tests for the ledger and lens operations.\n- A report showing parity between the TS and Rust implementations on golden merge cases.\n\n## CI\n- Job **`accounting-ledger`**:\n  - Runs tests for the ledger and lens operations in both TS and Rust.\n\n## Parity\n- The TS and Rust implementations must have parity on a set of golden merge cases.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_6 — Accounting / Ledger Lens\n\n1)  Implement a ledger store that acts as the source of truth for balances and P&L.\n    - *Why*: This is a critical component that is relied upon by the conservation and transport checks.\n\n2)  Implement lens operations for merging data into the ledger.\n    - *Why*: Lenses provide a structured and reliable way to update the ledger.\n"
  },
  "T5_7": {
    "ACCEPTANCE": "# Acceptance — T5_7\n\n## Evidence\n- The script or Make target for running the end-to-end replay scenario.\n- The generated HTML report and traces.\n- A report showing that `tf-check` passes.\n\n## CI\n- Job **`e2e-replay`**:\n  - Runs the end-to-end replay scenario.\n  - Verifies that `tf-check` passes and that the HTML report and traces are generated.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_7 — End-to-End Deterministic Replay Scenario\n\n1)  Create a script or Make target that runs a deterministic replay scenario from end to end.\n    - *Why*: This serves as a public demo artifact that showcases the full loop of the system.\n\n2)  The script should run `tf-check` and generate the HTML report and traces.\n    - *Why*: This demonstrates the full verification and reporting capabilities of the system.\n"
  },
  "T5_8": {
    "ACCEPTANCE": "# Acceptance — T5_8\n\n## Evidence\n- The CI workflow file for the pilot repo.\n- A PR showing the status check from the workflow.\n- A PR showing the uploaded HTML artifacts.\n\n## CI\n- The workflow itself is the CI implementation. It must run on PRs and demonstrate the required behavior.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T5_8 — CI Wiring for Pilot\n\n1)  Add a CI job to the pilot repo that runs `tf-check` on both the TS and Rust pilots.\n    - *Why*: This demonstrates the standard and enforces alignment in the pilot repo.\n\n2)  The CI job should block PRs on failures and upload the HTML report as an artifact.\n    - *Why*: This ensures that all code merged into the pilot repo meets the alignment standard.\n"
  },
  "T5_9": {
    "ACCEPTANCE": "# Acceptance — T5_9\n\n## Evidence\n- The README file for the pilot repo.\n- The gifs or CLI transcript embedded in the README.\n\n## Docs\n- The primary deliverable is documentation. The README should be clear, concise, and easy to follow, allowing a new developer to reproduce the demo in less than 10 minutes.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - change APIs or file formats beyond what this card specifies\n",
    "END_GOAL": "# T5_9 — Demo README + Short Video/Script\n\n1)  Create a crisp README for the pilot repo that explains how the full loop works, step-by-step.\n    - *Why*: This is essential for onboarding new developers and for evangelism.\n\n2)  The README should include gifs or a CLI transcript to make it easy to follow.\n    - *Why*: Visual aids make the documentation more engaging and easier to understand.\n"
  },
  "T6_1": {
    "ACCEPTANCE": "# Acceptance — T6_1\n\n## Evidence\n- The `.pre-commit-config.yaml` file.\n- The scripts for the pre-commit hooks.\n- A report showing that the hooks run successfully both locally and in CI.\n\n## CI\n- Job **`pre-commit-hooks`**:\n  - Runs the pre-commit hooks.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - change APIs or file formats beyond what this card specifies\n",
    "END_GOAL": "# T6_1 — Pre-commit Hooks\n\n1)  Create a `.pre-commit-config.yaml` file with hooks for schema linting, code formatting, and license headers.\n    - *Why*: This helps to keep the repositories clean and consistent, which lowers the friction for agents.\n\n2)  Ensure that the hooks run both locally and in CI.\n    - *Why*: Running the hooks in both environments ensures that all code is checked, regardless of the developer's local setup.\n"
  },
  "T6_2": {
    "ACCEPTANCE": "# Acceptance — T6_2\n\n## Evidence\n- The specification document for the seed and float rules.\n- The helper libraries in TS and Rust.\n- Test results showing identical outputs across runtimes on tricky cases.\n\n## CI\n- Job **`seeds-canonicalization`**:\n  - Runs tests on the helper libraries to verify that they produce identical outputs across runtimes.\n\n## Determinism\n- The core of this task is to ensure determinism. The libraries must produce identical outputs on both runtimes.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - TS: deep imports across packages\n  - TS: internal ESM imports without \".js\" suffix\n  - TS: use of `as any`\n  - Rust: use of `static mut`\n  - Rust: panicking unwraps in library code\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  ts:\n    no_deep_imports: true\n    internal_esm_imports_end_with_js: true\n    no_as_any: true\n  rust:\n    no_static_mut: true\n    no_panicking_unwraps_in_libs: true\n    use_atomics_mutexes_appropriately: true\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n",
    "END_GOAL": "# T6_2 — Seeds & Canonicalization Rules\n\n1)  Define precise, language-agnostic rules for seeding and float canonicalization.\n    - *Why*: This is essential for achieving determinism.\n\n2)  Implement helper libraries in both TS and Rust that enforce these rules.\n    - *Why*: Libraries make it easy to apply the rules consistently across the codebase.\n"
  },
  "T6_3": {
    "ACCEPTANCE": "# Acceptance — T6_3\n\n## Evidence\n- The threat model document.\n- The security checklist.\n- The implementation of the automated security checks.\n- A report showing that all gates have been audited.\n\n## CI\n- Job **`security-review`**:\n  - Runs the automated security checks.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - change APIs or file formats beyond what this card specifies\n",
    "END_GOAL": "# T6_3 — Security Review of Gates/Transports\n\n1)  Create a threat model for CALL gates and transports.\n    - *Why*: This helps to identify and mitigate potential security vulnerabilities, such as privilege escalation via effects.\n\n2)  Develop a checklist and automated checks based on the threat model.\n    - *Why*: A checklist ensures that all gates are audited consistently, and automated checks help to prevent regressions.\n"
  },
  "T6_4": {
    "ACCEPTANCE": "# Acceptance — T6_4\n\n## Evidence\n- The benchmark suite.\n- A performance report showing that the overhead is less than or equal to 1% when tracing is disabled.\n\n## CI\n- Job **`performance-baseline`**:\n  - Runs the benchmark suite and generates the performance report.\n\n## Performance\n- The key acceptance criterion is that the overhead of the tracing mechanism is less than or equal to 1% when it is disabled.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - cross-test state or nondeterminism\n  - introduce runtime dependencies (CI-only dev deps allowed)\n  - tracing overhead when DEV_PROOFS=0\n  - change APIs or file formats beyond what this card specifies\n\nmachine_rules:\n  runtime_deps:\n    allowed: false\n    ci_dev_deps_allowed: true\n  tracing_overhead:\n    allowed: false\n",
    "END_GOAL": "# T6_4 — Performance Baseline with Proofs Off\n\n1)  Develop a benchmark suite that proves near-zero overhead when tracing is disabled.\n    - *Why*: This is essential for ensuring the production viability of the system.\n\n2)  The suite should generate a report that documents the overhead.\n    - *Why*: A report provides clear and concise evidence of the performance characteristics of the system.\n"
  },
  "T6_5": {
    "ACCEPTANCE": "# Acceptance — T6_5\n\n## Evidence\n- The `examples/` directory with the cookbook of small, focused scenarios.\n- A report showing that each example runs `tf-check` and passes at least two oracles.\n\n## CI\n- Job **`cookbook-examples`**:\n  - Runs `tf-check` on each example and verifies that at least two oracles pass.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - change APIs or file formats beyond what this card specifies\n",
    "END_GOAL": "# T6_5 — Cookbook & Examples\n\n1)  Create a cookbook of small, focused examples that provide a fast path for users to adopt the TF-Lang workflow.\n    - *Why*: This helps to scale the adoption of TF-Lang beyond the pilot.\n\n2)  Each example should run `tf-check` and pass at least two oracles.\n    - *Why*: This ensures that the examples are working and that they demonstrate the value of the TF-Lang workflow.\n"
  },
  "T6_6": {
    "ACCEPTANCE": "# Acceptance — T6_6\n\n## Evidence\n- The concept-to-code matrix visualizer.\n- The visualizer exported as a CI artifact.\n\n## CI\n- Job **`matrix-visualizer`**:\n  - Generates the matrix visualizer and exports it as a CI artifact.\n",
    "BLOCKERS": "schema_changes_allowed: false\n\nmust_not:\n  - change APIs or file formats beyond what this card specifies\n",
    "END_GOAL": "# T6_6 — Concept↔Code Matrix Visualizer\n\n1)  Create a visual map from intents to code and oracle coverage.\n    - *Why*: This improves reviewer ergonomics and provides a feedback loop for planning.\n\n2)  The visualizer should be a static HTML/SVG (or d3) view that is fed by the JSON from T2.3.\n    - *Why*: A static view is easy to host and share.\n\n3)  The visualizer should support filtering by intent, oracle, and runtime, and it should be exported as a CI artifact.\n    - *Why*: Filtering makes it easy to focus on specific areas of interest, and exporting the visualizer as a CI artifact makes it readily accessible.\n"
  }
}
