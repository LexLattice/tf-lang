# PR Bundle for LexLattice/tf-lang
- Generated: 2025-09-12 06:10:02 UTC
- PRs: 23 24 25 26

## Summary

- **#23** — feat: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/23)) — by @andreidita22 — checks: none
n/a
- **#24** — B2: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/24)) — by @andreidita22 — checks: none
- **#25** — feat: emit dev proof tags ([link](https://github.com/LexLattice/tf-lang/pull/25)) — by @andreidita22 — checks: none
n/a
- **#26** — B2: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/26)) — by @andreidita22 — checks: none
n/a


---

# PR #23 — feat: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/23
- Author: @andreidita22
- Created: 2025-09-12T03:03:04Z
- Updated: 2025-09-12T03:04:52Z

## Checks
```
conformance	fail	20s	https://github.com/LexLattice/tf-lang/actions/runs/17663250486/job/50200314199	
rust	pass	40s	https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200329595	
ts	pass	24s	https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200329609	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200329770	
Rust build & test	pass	37s	https://github.com/LexLattice/tf-lang/actions/runs/17663250472/job/50200314175	
TypeScript build & test	pass	13s	https://github.com/LexLattice/tf-lang/actions/runs/17663250472/job/50200314193	
changed	pass	6s	https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200314490	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request introduces a new mechanism for emitting detailed proof tags from the virtual machine interpreters in both TypeScript and Rust. The primary purpose is to provide enhanced debugging and analysis capabilities during development by making internal VM state changes and logical outcomes observable through these tags, without impacting production performance.

### Highlights

* **Proof Tag Emission Control**: Proof tag collection is now gated behind a DEV_PROOFS environment variable, ensuring tags are only emitted in development mode. This applies to both TypeScript and Rust runtimes.
* **Expanded VM Tag Emissions**: The VM interpreters in both TypeScript and Rust have been updated to emit various proof tags, including transport (for LENS_PROJ/LENS_MERGE operations), witness (for final state/effect), refutation (on ASSERT failures), and conservativity (on CALL boundary errors).
* **Comprehensive Testing**: New tests have been added for both TypeScript and Rust runtimes to verify the correct emission and absence of these proof tags based on the DEV_PROOFS flag, covering all new tag types.
* **Proof Sink Utilities Re-export**: Sink utilities for proof tag collection have been re-exported to allow downstream code to easily access emit and take functionalities.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces proof tag emissions in development mode, controlled by the `DEV_PROOFS` environment variable. The changes are consistently applied across both the Rust and TypeScript VM implementations, including new logic for emitting transport, witness, refutation, and conservativity tags. The addition of a global sink for collecting these tags and corresponding tests is well-executed.

My review focuses on improving the robustness of the tests, which currently manipulate environment variables in a way that could lead to flakiness, and a small refactoring opportunity in the TypeScript VM to reduce code duplication. Overall, this is a solid contribution that adds valuable debugging capabilities.
--
```

## Files Changed (JSON)
```json
[{"sha":"b3531d30c410fc9a12b782563d13ed5bc590dda4","filename":".codex/JOURNAL.md","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -500,3 +500,17 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+## [B2] Minimal proof tag emissions\n+- Start: 2025-09-11 23:05 UTC\n+- End:   2025-09-11 23:25 UTC\n+- Changes:\n+  - added DEV_PROOFS-gated tag sink and VM emissions in TS and Rust\n+  - covered transport, witness, refutation, and conservativity tags with tests\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - pnpm -C packages/tf-lang-l0-ts vectors\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests and vectors passed\n+- Next suggested step:\n+  - none"},{"sha":"3d07df95bb53ddad8b33337d2574fa1ad7f71597","filename":".codex/LESSONS.md","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -18,3 +18,4 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-11] Rule: \"Proof tags emit only when DEV_PROOFS=1.\" Guardrail: proof:dev_flag"},{"sha":"f7c7e70af29ba52c2cea56cf9c412d102716c236","filename":".codex/polish/B2.md","status":"added","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -0,0 +1,3 @@\n+# Polish for B2\n+- Re-export proof sink helpers from `packages/tf-lang-l0-ts/src/proof/tags.ts` or `index.ts` so downstream code can access emit/take via the package root.\n+- In Rust VM conservativity tag, use `e.to_string()` instead of `format!(\"{e}\")` for simplicity."},{"sha":"e11addf361c32a80ec80bdb574322963f36cde44","filename":".codex/self-plans/B2.md","status":"added","additions":29,"deletions":0,"changes":29,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -0,0 +1,29 @@\n+# Plan for B2\n+\n+## Steps\n+1. Add proof tag sink to TS and Rust runtime modules that collects tags only when `DEV_PROOFS=1`.\n+2. Emit proof tags from VM interpreters:\n+   - Witness + Normalization at run end using final delta/effect.\n+   - Transport on `LENS_PROJ`/`LENS_MERGE`.\n+   - Refutation before `ASSERT` failure.\n+   - Conservativity when `CALL` boundary errors.\n+3. Expose helper to retrieve and clear collected tags for tests.\n+4. Write unit tests in TS and Rust verifying:\n+   - Tags appear with `DEV_PROOFS=1` and include witness, transport, refutation, and conservativity cases.\n+   - No tags emitted when flag unset.\n+5. Update LESSONS and append to JOURNAL.\n+\n+## Tests\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `pnpm -C packages/tf-lang-l0-ts vectors`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks\n+- Global sinks causing cross-test contamination if not cleared.\n+- Environment gating logic may differ across runtimes.\n+- Error shapes for conservativity may be oversimplified.\n+\n+## Definition of Done\n+- VM emits specified proof tags only when `DEV_PROOFS=1`.\n+- Unit tests cover presence/absence and error cases for TS and Rust.\n+- LESSONS and JOURNAL updated, working tree clean."},{"sha":"307911ddff06feca12c7c48e4d09cc0328542053","filename":"packages/tf-lang-l0-rs/Cargo.lock","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2FCargo.lock","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2FCargo.lock","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.lock?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -79,6 +79,12 @@ version = \"2.7.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0\"\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.21.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n+\n [[package]]\n name = \"pretty_assertions\"\n version = \"1.4.1\"\n@@ -168,6 +174,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"blake3\",\n+ \"once_cell\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\","},{"sha":"b007053d53a73ac579af68fc9155f1a7f3582a7f","filename":"packages/tf-lang-l0-rs/Cargo.toml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2FCargo.toml","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2FCargo.toml","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.toml?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -17,6 +17,7 @@ thiserror = \"1\"\n serde = { version = \"1\", features = [\"derive\"] }\n serde_json = \"1\"\n blake3 = \"1.5\"\n+once_cell = \"1\"\n \n [dev-dependencies]\n pretty_assertions = \"1\""},{"sha":"ed14c332ddb9bc6712a5374d5b40c131858b367a","filename":"packages/tf-lang-l0-rs/src/proof.rs","status":"modified","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -1,5 +1,7 @@\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n+use once_cell::sync::Lazy;\n+use std::sync::Mutex;\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct Replace {\n@@ -42,3 +44,15 @@ pub enum ProofTag {\n     Refutation { code: String, msg: Option<String> },\n     Conservativity { callee: String, expected: String, found: String },\n }\n+\n+static TAGS: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));\n+\n+pub fn emit(tag: ProofTag) {\n+    if std::env::var(\"DEV_PROOFS\").ok().as_deref() == Some(\"1\") {\n+        TAGS.lock().unwrap().push(tag);\n+    }\n+}\n+\n+pub fn take() -> Vec<ProofTag> {\n+    TAGS.lock().unwrap().drain(..).collect()\n+}"},{"sha":"6141658981eeb2c7dc1fe4741d2d79fa6fd6cef2","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":20,"deletions":5,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n use crate::vm::opcode::Host;\n+use crate::proof::{emit, ProofTag, Effect, NormalizationTarget};\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n@@ -37,6 +38,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        emit(ProofTag::Refutation { code: \"ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -98,6 +100,7 @@ impl<'h> VM<'h> {\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n                     regs[*dst as usize] = sub;\n+                    emit(ProofTag::Transport { op: crate::proof::TransportOp::LensProj, region: region.to_string() });\n                 }\n                 Instr::LensMerge {\n                     dst,\n@@ -109,6 +112,7 @@ impl<'h> VM<'h> {\n                         self.host\n                             .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n                     regs[*dst as usize] = merged;\n+                    emit(ProofTag::Transport { op: crate::proof::TransportOp::LensMerge, region: region.to_string() });\n                 }\n                 Instr::PlanSim {\n                     dst_delta,\n@@ -173,8 +177,13 @@ impl<'h> VM<'h> {\n                     for r in args {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n-                    let out = self.host.call_tf(tf_id, &a)?;\n-                    regs[*dst as usize] = out;\n+                    match self.host.call_tf(tf_id, &a) {\n+                        Ok(out) => regs[*dst as usize] = out,\n+                        Err(e) => {\n+                            emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: String::new(), found: e.to_string() });\n+                            return Err(e);\n+                        }\n+                    }\n                 }\n             }\n             if !init_captured && regs[0] != serde_json::Value::Null {\n@@ -184,11 +193,17 @@ impl<'h> VM<'h> {\n         }\n \n         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);\n-        let out = if final_state == initial_state {\n-            serde_json::Value::Null\n+        let (out, delta_tag) = if final_state == initial_state {\n+            (serde_json::Value::Null, None)\n         } else {\n-            serde_json::json!({ \"replace\": final_state })\n+            (\n+                serde_json::json!({ \"replace\": final_state.clone() }),\n+                Some(crate::proof::Replace { replace: final_state }),\n+            )\n         };\n+        emit(ProofTag::Witness { delta: delta_tag, effect: Effect::default() });\n+        emit(ProofTag::Normalization { target: NormalizationTarget::Delta });\n+        emit(ProofTag::Normalization { target: NormalizationTarget::Effect });\n \n         Ok(out)\n     }"},{"sha":"8cbea400c0c0fb1af03d14d533ad0def76d47b2e","filename":"packages/tf-lang-l0-rs/tests/proof.rs","status":"modified","additions":92,"deletions":1,"changes":93,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof.rs?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -1,5 +1,11 @@\n use serde_json::{json, Value};\n-use tflang_l0::proof::{Delta, Effect, NormalizationTarget, Replace, ProofTag, TransportOp};\n+use tflang_l0::proof::{self, Delta, Effect, NormalizationTarget, Replace, ProofTag, TransportOp};\n+use tflang_l0::vm::interpreter::VM;\n+use tflang_l0::vm::opcode::Host;\n+use tflang_l0::model::bytecode::{Program, Instr};\n+use tflang_l0::model::{World, JournalEntry};\n+use once_cell::sync::Lazy;\n+use std::sync::Mutex;\n \n #[test]\n fn proof_tag_shapes() {\n@@ -26,3 +32,88 @@ fn serde_roundtrip_normalization() {\n     let v = serde_json::to_value(&n).unwrap();\n     assert_eq!(v, json!({\"kind\":\"Normalization\",\"target\":\"delta\"}));\n }\n+\n+struct StubHost;\n+\n+impl Host for StubHost {\n+    fn lens_project(&self, state: &Value, _region: &str) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn lens_merge(&self, state: &Value, _region: &str, _sub: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &Value) -> anyhow::Result<String> { Ok(String::new()) }\n+    fn diff_apply(&self, state: &Value, _delta: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> { Ok(delta.clone()) }\n+    fn journal_record(&self, _plan: &Value, _delta: &Value, _s0: &str, _s1: &str, _meta: &Value) -> anyhow::Result<JournalEntry> { Ok(JournalEntry(Value::Null)) }\n+    fn journal_rewind(&self, _world: &World, _entry: &JournalEntry) -> anyhow::Result<World> { Ok(World(Value::Null)) }\n+    fn call_tf(&self, _tf_id: &str, _args: &[Value]) -> anyhow::Result<Value> { Ok(Value::Null) }\n+}\n+\n+struct FailHost;\n+\n+impl Host for FailHost {\n+    fn lens_project(&self, state: &Value, _region: &str) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn lens_merge(&self, state: &Value, _region: &str, _sub: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &Value) -> anyhow::Result<String> { Ok(String::new()) }\n+    fn diff_apply(&self, state: &Value, _delta: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> { Ok(delta.clone()) }\n+    fn journal_record(&self, _plan: &Value, _delta: &Value, _s0: &str, _s1: &str, _meta: &Value) -> anyhow::Result<JournalEntry> { Ok(JournalEntry(Value::Null)) }\n+    fn journal_rewind(&self, _world: &World, _entry: &JournalEntry) -> anyhow::Result<World> { Ok(World(Value::Null)) }\n+    fn call_tf(&self, tf_id: &str, _args: &[Value]) -> anyhow::Result<Value> { anyhow::bail!(\"fail {tf_id}\") }\n+}\n+\n+static TEST_MUTEX: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));\n+\n+#[test]\n+fn emits_tags_with_flag() {\n+    let _g = TEST_MUTEX.lock().unwrap();\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let host = StubHost;\n+    let vm = VM { host: &host };\n+    let prog = Program { version: \"0.1\".into(), regs: 2, instrs: vec![\n+        Instr::Const { dst: 0, value: json!({}) },\n+        Instr::LensProj { dst: 1, state: 0, region: \"/r\".into() },\n+    ]};\n+    vm.run(&prog).unwrap();\n+    let tags = proof::take();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { .. })));\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+    std::env::remove_var(\"DEV_PROOFS\");\n+}\n+\n+#[test]\n+fn no_tags_without_flag() {\n+    let _g = TEST_MUTEX.lock().unwrap();\n+    std::env::remove_var(\"DEV_PROOFS\");\n+    let host = StubHost;\n+    let vm = VM { host: &host };\n+    let prog = Program { version: \"0.1\".into(), regs: 1, instrs: vec![\n+        Instr::Const { dst: 0, value: Value::Null },\n+    ]};\n+    vm.run(&prog).unwrap();\n+    assert!(proof::take().is_empty());\n+}\n+\n+#[test]\n+fn refutation_and_conservativity() {\n+    let _g = TEST_MUTEX.lock().unwrap();\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let host = StubHost;\n+    let vm = VM { host: &host };\n+    let prog = Program { version: \"0.1\".into(), regs: 1, instrs: vec![\n+        Instr::Const { dst: 0, value: json!(false) },\n+        Instr::Assert { pred: 0, msg: \"oops\".into() },\n+    ]};\n+    assert!(vm.run(&prog).is_err());\n+    let tags = proof::take();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Refutation { code, .. } if code == \"ASSERT\")));\n+\n+    let fail = FailHost;\n+    let vm2 = VM { host: &fail };\n+    let prog2 = Program { version: \"0.1\".into(), regs: 1, instrs: vec![\n+        Instr::Call { dst: 0, tf_id: \"x\".into(), args: vec![] },\n+    ]};\n+    assert!(vm2.run(&prog2).is_err());\n+    let tags2 = proof::take();\n+    assert!(tags2.iter().any(|t| matches!(t, ProofTag::Conservativity { callee, .. } if callee == \"x\")));\n+    std::env::remove_var(\"DEV_PROOFS\");\n+}"},{"sha":"3588d098e018b666f5b502857717d14bbccb5a2b","filename":"packages/tf-lang-l0-ts/src/index.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -5,4 +5,4 @@ export * as check from './check/index.js';\n export { canonicalJsonBytes } from './canon/json.js';\n export { blake3hex } from './canon/hash.js';\n export * as ops from './ops/index.js';\n-export * as proof from './proof/tags.js';\n+export * as proof from './proof/index.js';"},{"sha":"81ff3207fba15d7b4158ad294f9242f4e8ab1f04","filename":"packages/tf-lang-l0-ts/src/proof/index.ts","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -0,0 +1,2 @@\n+export * from './tags.js';\n+export * from './sink.js';"},{"sha":"67bba293f6580db4a7ad3958b18da08f755b7dad","filename":"packages/tf-lang-l0-ts/src/proof/sink.ts","status":"added","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Fsink.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Fsink.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Fsink.ts?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -0,0 +1,13 @@\n+import type { ProofTag } from './tags.js';\n+\n+const tags: ProofTag[] = [];\n+\n+export function emit(tag: ProofTag): void {\n+  if (process.env.DEV_PROOFS === '1') tags.push(tag);\n+}\n+\n+export function take(): ProofTag[] {\n+  const out = tags.slice();\n+  tags.length = 0;\n+  return out;\n+}"},{"sha":"1643a8d65e97427784ee855f11dfd66a82a9cb89","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":32,"deletions":6,"changes":38,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n+import { emit } from '../proof/sink.js';\n \n export class VM {\n   constructor(public host: Host) {}\n@@ -41,8 +42,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +76,21 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          try {\n+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          } catch (e: any) {\n+            const msg = e && typeof e === 'object' && 'message' in e ? String((e as any).message) : String(e);\n+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: '', found: msg });\n+            throw e;\n+          }\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -92,9 +110,17 @@ export class VM {\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n     if (Buffer.from(a).equals(Buffer.from(b))) {\n-      return null;\n+      const delta = null;\n+      emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+      emit({ kind: 'Normalization', target: 'delta' });\n+      emit({ kind: 'Normalization', target: 'effect' });\n+      return delta;\n     }\n-    return { replace: finalState };\n+    const delta = { replace: finalState };\n+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+    emit({ kind: 'Normalization', target: 'delta' });\n+    emit({ kind: 'Normalization', target: 'effect' });\n+    return delta;\n   }\n }\n "},{"sha":"b8eddfdc6f533888a009f035fb645f13d4b33708","filename":"packages/tf-lang-l0-ts/tests/dev-proofs.test.ts","status":"added","additions":71,"deletions":0,"changes":71,"blob_url":"https://github.com/LexLattice/tf-lang/blob/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Ftests%2Fdev-proofs.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/bc60af5e32d25d39e04b35f071bdfd72145caf84/packages%2Ftf-lang-l0-ts%2Ftests%2Fdev-proofs.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fdev-proofs.test.ts?ref=bc60af5e32d25d39e04b35f071bdfd72145caf84","patch":"@@ -0,0 +1,71 @@\n+import { describe, it, expect } from 'vitest';\n+import { VM } from '../src/vm/interpreter.js';\n+import type { Program } from '../src/model/bytecode.js';\n+import type { Host } from '../src/vm/opcode.js';\n+import { take } from '../src/proof/sink.js';\n+\n+function stubHost(overrides: Partial<Host> = {}): Host {\n+  return {\n+    lens_project: (s) => s,\n+    lens_merge: (s) => s,\n+    snapshot_make: (s) => s,\n+    snapshot_id: () => '',\n+    diff_apply: (s) => s,\n+    diff_invert: (d) => d,\n+    journal_record: () => ({ value: null }),\n+    journal_rewind: () => ({ value: null }),\n+    call_tf: () => null,\n+    ...overrides,\n+  } as Host;\n+}\n+\n+describe('dev proofs', () => {\n+  it('emits tags when DEV_PROOFS=1', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const host = stubHost();\n+    const vm = new VM(host);\n+    const prog: Program = { regs: 2, instrs: [\n+      { op: 'CONST', dst: 0, value: {} },\n+      { op: 'LENS_PROJ', dst: 1, state: 0, region: '/r' },\n+    ]};\n+    await vm.run(prog);\n+    const tags = take();\n+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);\n+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);\n+    delete process.env.DEV_PROOFS;\n+  });\n+\n+  it('no tags when DEV_PROOFS unset', async () => {\n+    delete process.env.DEV_PROOFS;\n+    const host = stubHost();\n+    const vm = new VM(host);\n+    const prog: Program = { regs: 1, instrs: [{ op: 'CONST', dst: 0, value: null }] };\n+    await vm.run(prog);\n+    expect(take()).toEqual([]);\n+  });\n+\n+  it('refutation tag on ASSERT failure', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const host = stubHost();\n+    const vm = new VM(host);\n+    const prog: Program = { regs: 1, instrs: [\n+      { op: 'CONST', dst: 0, value: false },\n+      { op: 'ASSERT', pred: 0, msg: 'oops' },\n+    ]};\n+    await expect(vm.run(prog)).rejects.toThrow('ASSERT failed');\n+    const tags = take();\n+    expect(tags.some(t => t.kind === 'Refutation' && t.code === 'ASSERT')).toBe(true);\n+    delete process.env.DEV_PROOFS;\n+  });\n+\n+  it('conservativity tag on CALL failure', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const host = stubHost({ call_tf: () => { throw new Error('bad'); } });\n+    const vm = new VM(host);\n+    const prog: Program = { regs: 1, instrs: [ { op: 'CALL', dst: 0, tf_id: 'x', args: [] } ] };\n+    await expect(vm.run(prog)).rejects.toThrow('bad');\n+    const tags = take();\n+    expect(tags.some(t => t.kind === 'Conservativity' && t.callee === 'x')).toBe(true);\n+    delete process.env.DEV_PROOFS;\n+  });\n+});"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..b3531d3 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,17 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+## [B2] Minimal proof tag emissions
+- Start: 2025-09-11 23:05 UTC
+- End:   2025-09-11 23:25 UTC
+- Changes:
+  - added DEV_PROOFS-gated tag sink and VM emissions in TS and Rust
+  - covered transport, witness, refutation, and conservativity tags with tests
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - pnpm -C packages/tf-lang-l0-ts vectors
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests and vectors passed
+- Next suggested step:
+  - none
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..3d07df9 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,4 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-11] Rule: "Proof tags emit only when DEV_PROOFS=1." Guardrail: proof:dev_flag
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..f7c7e70
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1,3 @@
+# Polish for B2
+- Re-export proof sink helpers from `packages/tf-lang-l0-ts/src/proof/tags.ts` or `index.ts` so downstream code can access emit/take via the package root.
+- In Rust VM conservativity tag, use `e.to_string()` instead of `format!("{e}")` for simplicity.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..e11addf
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,29 @@
+# Plan for B2
+
+## Steps
+1. Add proof tag sink to TS and Rust runtime modules that collects tags only when `DEV_PROOFS=1`.
+2. Emit proof tags from VM interpreters:
+   - Witness + Normalization at run end using final delta/effect.
+   - Transport on `LENS_PROJ`/`LENS_MERGE`.
+   - Refutation before `ASSERT` failure.
+   - Conservativity when `CALL` boundary errors.
+3. Expose helper to retrieve and clear collected tags for tests.
+4. Write unit tests in TS and Rust verifying:
+   - Tags appear with `DEV_PROOFS=1` and include witness, transport, refutation, and conservativity cases.
+   - No tags emitted when flag unset.
+5. Update LESSONS and append to JOURNAL.
+
+## Tests
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `pnpm -C packages/tf-lang-l0-ts vectors`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks
+- Global sinks causing cross-test contamination if not cleared.
+- Environment gating logic may differ across runtimes.
+- Error shapes for conservativity may be oversimplified.
+
+## Definition of Done
+- VM emits specified proof tags only when `DEV_PROOFS=1`.
+- Unit tests cover presence/absence and error cases for TS and Rust.
+- LESSONS and JOURNAL updated, working tree clean.
diff --git a/packages/tf-lang-l0-rs/Cargo.lock b/packages/tf-lang-l0-rs/Cargo.lock
index 485414a..307911d 100644
--- a/packages/tf-lang-l0-rs/Cargo.lock
+++ b/packages/tf-lang-l0-rs/Cargo.lock
@@ -79,6 +79,12 @@ version = "2.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
 
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
 [[package]]
 name = "pretty_assertions"
 version = "1.4.1"
@@ -168,6 +174,7 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "blake3",
+ "once_cell",
  "pretty_assertions",
  "serde",
  "serde_json",
diff --git a/packages/tf-lang-l0-rs/Cargo.toml b/packages/tf-lang-l0-rs/Cargo.toml
index 253a2b2..b007053 100644
--- a/packages/tf-lang-l0-rs/Cargo.toml
+++ b/packages/tf-lang-l0-rs/Cargo.toml
@@ -17,6 +17,7 @@ thiserror = "1"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 blake3 = "1.5"
+once_cell = "1"
 
 [dev-dependencies]
 pretty_assertions = "1"
diff --git a/packages/tf-lang-l0-rs/src/proof.rs b/packages/tf-lang-l0-rs/src/proof.rs
index 4a4ea5e..ed14c33 100644
--- a/packages/tf-lang-l0-rs/src/proof.rs
+++ b/packages/tf-lang-l0-rs/src/proof.rs
@@ -1,5 +1,7 @@
 use serde::{Deserialize, Serialize};
 use serde_json::Value;
+use once_cell::sync::Lazy;
+use std::sync::Mutex;
 
 #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
 pub struct Replace {
@@ -42,3 +44,15 @@ pub enum ProofTag {
     Refutation { code: String, msg: Option<String> },
     Conservativity { callee: String, expected: String, found: String },
 }
+
+static TAGS: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));
+
+pub fn emit(tag: ProofTag) {
+    if std::env::var("DEV_PROOFS").ok().as_deref() == Some("1") {
+        TAGS.lock().unwrap().push(tag);
+    }
+}
+
+pub fn take() -> Vec<ProofTag> {
+    TAGS.lock().unwrap().drain(..).collect()
+}
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..6141658 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
 use crate::vm::opcode::Host;
+use crate::proof::{emit, ProofTag, Effect, NormalizationTarget};
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
@@ -37,6 +38,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        emit(ProofTag::Refutation { code: "ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -98,6 +100,7 @@ impl<'h> VM<'h> {
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
                     regs[*dst as usize] = sub;
+                    emit(ProofTag::Transport { op: crate::proof::TransportOp::LensProj, region: region.to_string() });
                 }
                 Instr::LensMerge {
                     dst,
@@ -109,6 +112,7 @@ impl<'h> VM<'h> {
                         self.host
                             .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
                     regs[*dst as usize] = merged;
+                    emit(ProofTag::Transport { op: crate::proof::TransportOp::LensMerge, region: region.to_string() });
                 }
                 Instr::PlanSim {
                     dst_delta,
@@ -173,8 +177,13 @@ impl<'h> VM<'h> {
                     for r in args {
                         a.push(get(*r, &regs)?.clone());
                     }
-                    let out = self.host.call_tf(tf_id, &a)?;
-                    regs[*dst as usize] = out;
+                    match self.host.call_tf(tf_id, &a) {
+                        Ok(out) => regs[*dst as usize] = out,
+                        Err(e) => {
+                            emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: String::new(), found: e.to_string() });
+                            return Err(e);
+                        }
+                    }
                 }
             }
             if !init_captured && regs[0] != serde_json::Value::Null {
@@ -184,11 +193,17 @@ impl<'h> VM<'h> {
         }
 
         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);
-        let out = if final_state == initial_state {
-            serde_json::Value::Null
+        let (out, delta_tag) = if final_state == initial_state {
+            (serde_json::Value::Null, None)
         } else {
-            serde_json::json!({ "replace": final_state })
+            (
+                serde_json::json!({ "replace": final_state.clone() }),
+                Some(crate::proof::Replace { replace: final_state }),
+            )
         };
+        emit(ProofTag::Witness { delta: delta_tag, effect: Effect::default() });
+        emit(ProofTag::Normalization { target: NormalizationTarget::Delta });
+        emit(ProofTag::Normalization { target: NormalizationTarget::Effect });
 
         Ok(out)
     }
diff --git a/packages/tf-lang-l0-rs/tests/proof.rs b/packages/tf-lang-l0-rs/tests/proof.rs
index 96788dc..8cbea40 100644
--- a/packages/tf-lang-l0-rs/tests/proof.rs
+++ b/packages/tf-lang-l0-rs/tests/proof.rs
@@ -1,5 +1,11 @@
 use serde_json::{json, Value};
-use tflang_l0::proof::{Delta, Effect, NormalizationTarget, Replace, ProofTag, TransportOp};
+use tflang_l0::proof::{self, Delta, Effect, NormalizationTarget, Replace, ProofTag, TransportOp};
+use tflang_l0::vm::interpreter::VM;
+use tflang_l0::vm::opcode::Host;
+use tflang_l0::model::bytecode::{Program, Instr};
+use tflang_l0::model::{World, JournalEntry};
+use once_cell::sync::Lazy;
+use std::sync::Mutex;
 
 #[test]
 fn proof_tag_shapes() {
@@ -26,3 +32,88 @@ fn serde_roundtrip_normalization() {
     let v = serde_json::to_value(&n).unwrap();
     assert_eq!(v, json!({"kind":"Normalization","target":"delta"}));
 }
+
+struct StubHost;
+
+impl Host for StubHost {
+    fn lens_project(&self, state: &Value, _region: &str) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn lens_merge(&self, state: &Value, _region: &str, _sub: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &Value) -> anyhow::Result<String> { Ok(String::new()) }
+    fn diff_apply(&self, state: &Value, _delta: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> { Ok(delta.clone()) }
+    fn journal_record(&self, _plan: &Value, _delta: &Value, _s0: &str, _s1: &str, _meta: &Value) -> anyhow::Result<JournalEntry> { Ok(JournalEntry(Value::Null)) }
+    fn journal_rewind(&self, _world: &World, _entry: &JournalEntry) -> anyhow::Result<World> { Ok(World(Value::Null)) }
+    fn call_tf(&self, _tf_id: &str, _args: &[Value]) -> anyhow::Result<Value> { Ok(Value::Null) }
+}
+
+struct FailHost;
+
+impl Host for FailHost {
+    fn lens_project(&self, state: &Value, _region: &str) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn lens_merge(&self, state: &Value, _region: &str, _sub: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &Value) -> anyhow::Result<String> { Ok(String::new()) }
+    fn diff_apply(&self, state: &Value, _delta: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> { Ok(delta.clone()) }
+    fn journal_record(&self, _plan: &Value, _delta: &Value, _s0: &str, _s1: &str, _meta: &Value) -> anyhow::Result<JournalEntry> { Ok(JournalEntry(Value::Null)) }
+    fn journal_rewind(&self, _world: &World, _entry: &JournalEntry) -> anyhow::Result<World> { Ok(World(Value::Null)) }
+    fn call_tf(&self, tf_id: &str, _args: &[Value]) -> anyhow::Result<Value> { anyhow::bail!("fail {tf_id}") }
+}
+
+static TEST_MUTEX: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));
+
+#[test]
+fn emits_tags_with_flag() {
+    let _g = TEST_MUTEX.lock().unwrap();
+    std::env::set_var("DEV_PROOFS", "1");
+    let host = StubHost;
+    let vm = VM { host: &host };
+    let prog = Program { version: "0.1".into(), regs: 2, instrs: vec![
+        Instr::Const { dst: 0, value: json!({}) },
+        Instr::LensProj { dst: 1, state: 0, region: "/r".into() },
+    ]};
+    vm.run(&prog).unwrap();
+    let tags = proof::take();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { .. })));
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+    std::env::remove_var("DEV_PROOFS");
+}
+
+#[test]
+fn no_tags_without_flag() {
+    let _g = TEST_MUTEX.lock().unwrap();
+    std::env::remove_var("DEV_PROOFS");
+    let host = StubHost;
+    let vm = VM { host: &host };
+    let prog = Program { version: "0.1".into(), regs: 1, instrs: vec![
+        Instr::Const { dst: 0, value: Value::Null },
+    ]};
+    vm.run(&prog).unwrap();
+    assert!(proof::take().is_empty());
+}
+
+#[test]
+fn refutation_and_conservativity() {
+    let _g = TEST_MUTEX.lock().unwrap();
+    std::env::set_var("DEV_PROOFS", "1");
+    let host = StubHost;
+    let vm = VM { host: &host };
+    let prog = Program { version: "0.1".into(), regs: 1, instrs: vec![
+        Instr::Const { dst: 0, value: json!(false) },
+        Instr::Assert { pred: 0, msg: "oops".into() },
+    ]};
+    assert!(vm.run(&prog).is_err());
+    let tags = proof::take();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Refutation { code, .. } if code == "ASSERT")));
+
+    let fail = FailHost;
+    let vm2 = VM { host: &fail };
+    let prog2 = Program { version: "0.1".into(), regs: 1, instrs: vec![
+        Instr::Call { dst: 0, tf_id: "x".into(), args: vec![] },
+    ]};
+    assert!(vm2.run(&prog2).is_err());
+    let tags2 = proof::take();
+    assert!(tags2.iter().any(|t| matches!(t, ProofTag::Conservativity { callee, .. } if callee == "x")));
+    std::env::remove_var("DEV_PROOFS");
+}
diff --git a/packages/tf-lang-l0-ts/src/index.ts b/packages/tf-lang-l0-ts/src/index.ts
index 14746e5..3588d09 100644
--- a/packages/tf-lang-l0-ts/src/index.ts
+++ b/packages/tf-lang-l0-ts/src/index.ts
@@ -5,4 +5,4 @@ export * as check from './check/index.js';
 export { canonicalJsonBytes } from './canon/json.js';
 export { blake3hex } from './canon/hash.js';
 export * as ops from './ops/index.js';
-export * as proof from './proof/tags.js';
+export * as proof from './proof/index.js';
diff --git a/packages/tf-lang-l0-ts/src/proof/index.ts b/packages/tf-lang-l0-ts/src/proof/index.ts
new file mode 100644
index 0000000..81ff320
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/index.ts
@@ -0,0 +1,2 @@
+export * from './tags.js';
+export * from './sink.js';
diff --git a/packages/tf-lang-l0-ts/src/proof/sink.ts b/packages/tf-lang-l0-ts/src/proof/sink.ts
new file mode 100644
index 0000000..67bba29
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/sink.ts
@@ -0,0 +1,13 @@
+import type { ProofTag } from './tags.js';
+
+const tags: ProofTag[] = [];
+
+export function emit(tag: ProofTag): void {
+  if (process.env.DEV_PROOFS === '1') tags.push(tag);
+}
+
+export function take(): ProofTag[] {
+  const out = tags.slice();
+  tags.length = 0;
+  return out;
+}
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..1643a8d 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
+import { emit } from '../proof/sink.js';
 
 export class VM {
   constructor(public host: Host) {}
@@ -41,8 +42,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +76,21 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          try {
+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          } catch (e: any) {
+            const msg = e && typeof e === 'object' && 'message' in e ? String((e as any).message) : String(e);
+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: '', found: msg });
+            throw e;
+          }
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -92,9 +110,17 @@ export class VM {
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
     if (Buffer.from(a).equals(Buffer.from(b))) {
-      return null;
+      const delta = null;
+      emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+      emit({ kind: 'Normalization', target: 'delta' });
+      emit({ kind: 'Normalization', target: 'effect' });
+      return delta;
     }
-    return { replace: finalState };
+    const delta = { replace: finalState };
+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+    emit({ kind: 'Normalization', target: 'delta' });
+    emit({ kind: 'Normalization', target: 'effect' });
+    return delta;
   }
 }
 
diff --git a/packages/tf-lang-l0-ts/tests/dev-proofs.test.ts b/packages/tf-lang-l0-ts/tests/dev-proofs.test.ts
new file mode 100644
index 0000000..b8eddfd
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/dev-proofs.test.ts
@@ -0,0 +1,71 @@
+import { describe, it, expect } from 'vitest';
+import { VM } from '../src/vm/interpreter.js';
+import type { Program } from '../src/model/bytecode.js';
+import type { Host } from '../src/vm/opcode.js';
+import { take } from '../src/proof/sink.js';
+
+function stubHost(overrides: Partial<Host> = {}): Host {
+  return {
+    lens_project: (s) => s,
+    lens_merge: (s) => s,
+    snapshot_make: (s) => s,
+    snapshot_id: () => '',
+    diff_apply: (s) => s,
+    diff_invert: (d) => d,
+    journal_record: () => ({ value: null }),
+    journal_rewind: () => ({ value: null }),
+    call_tf: () => null,
+    ...overrides,
+  } as Host;
+}
+
+describe('dev proofs', () => {
+  it('emits tags when DEV_PROOFS=1', async () => {
+    process.env.DEV_PROOFS = '1';
+    const host = stubHost();
+    const vm = new VM(host);
+    const prog: Program = { regs: 2, instrs: [
+      { op: 'CONST', dst: 0, value: {} },
+      { op: 'LENS_PROJ', dst: 1, state: 0, region: '/r' },
+    ]};
+    await vm.run(prog);
+    const tags = take();
+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);
+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);
+    delete process.env.DEV_PROOFS;
+  });
+
+  it('no tags when DEV_PROOFS unset', async () => {
+    delete process.env.DEV_PROOFS;
+    const host = stubHost();
+    const vm = new VM(host);
+    const prog: Program = { regs: 1, instrs: [{ op: 'CONST', dst: 0, value: null }] };
+    await vm.run(prog);
+    expect(take()).toEqual([]);
+  });
+
+  it('refutation tag on ASSERT failure', async () => {
+    process.env.DEV_PROOFS = '1';
+    const host = stubHost();
+    const vm = new VM(host);
+    const prog: Program = { regs: 1, instrs: [
+      { op: 'CONST', dst: 0, value: false },
+      { op: 'ASSERT', pred: 0, msg: 'oops' },
+    ]};
+    await expect(vm.run(prog)).rejects.toThrow('ASSERT failed');
+    const tags = take();
+    expect(tags.some(t => t.kind === 'Refutation' && t.code === 'ASSERT')).toBe(true);
+    delete process.env.DEV_PROOFS;
+  });
+
+  it('conservativity tag on CALL failure', async () => {
+    process.env.DEV_PROOFS = '1';
+    const host = stubHost({ call_tf: () => { throw new Error('bad'); } });
+    const vm = new VM(host);
+    const prog: Program = { regs: 1, instrs: [ { op: 'CALL', dst: 0, tf_id: 'x', args: [] } ] };
+    await expect(vm.run(prog)).rejects.toThrow('bad');
+    const tags = take();
+    expect(tags.some(t => t.kind === 'Conservativity' && t.callee === 'x')).toBe(true);
+    delete process.env.DEV_PROOFS;
+  });
+});
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T03:03:04Z","isDraft":false,"mergeStateStatus":"UNSTABLE","number":23,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_mEnZ","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request introduces a new mechanism for emitting detailed proof tags from the virtual machine interpreters in both TypeScript and Rust. The primary purpose is to provide enhanced debugging and analysis capabilities during development by making internal VM state changes and logical outcomes observable through these tags, without impacting production performance.\n\n### Highlights\n\n* **Proof Tag Emission Control**: Proof tag collection is now gated behind a DEV_PROOFS environment variable, ensuring tags are only emitted in development mode. This applies to both TypeScript and Rust runtimes.\n* **Expanded VM Tag Emissions**: The VM interpreters in both TypeScript and Rust have been updated to emit various proof tags, including transport (for LENS_PROJ/LENS_MERGE operations), witness (for final state/effect), refutation (on ASSERT failures), and conservativity (on CALL boundary errors).\n* **Comprehensive Testing**: New tests have been added for both TypeScript and Rust runtimes to verify the correct emission and absence of these proof tags based on the DEV_PROOFS flag, covering all new tag types.\n* **Proof Sink Utilities Re-export**: Sink utilities for proof tag collection have been re-exported to allow downstream code to easily access emit and take functionalities.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T03:03:24Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"bc60af5e32d25d39e04b35f071bdfd72145caf84"}},{"id":"PRR_kwDOPs5-l86_mFAK","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces proof tag emissions in development mode, controlled by the `DEV_PROOFS` environment variable. The changes are consistently applied across both the Rust and TypeScript VM implementations, including new logic for emitting transport, witness, refutation, and conservativity tags. The addition of a global sink for collecting these tags and corresponding tests is well-executed.\n\nMy review focuses on improving the robustness of the tests, which currently manipulate environment variables in a way that could lead to flakiness, and a small refactoring opportunity in the TypeScript VM to reduce code duplication. Overall, this is a solid contribution that adds valuable debugging capabilities.","submittedAt":"2025-09-12T03:04:52Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"bc60af5e32d25d39e04b35f071bdfd72145caf84"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:30Z","conclusion":"FAILURE","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663250486/job/50200314199","name":"conformance","startedAt":"2025-09-12T03:03:10Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:23Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663250472/job/50200314193","name":"TypeScript build & test","startedAt":"2025-09-12T03:03:10Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:16Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200314490","name":"changed","startedAt":"2025-09-12T03:03:10Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:47Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663250472/job/50200314175","name":"Rust build & test","startedAt":"2025-09-12T03:03:10Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:43Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200329609","name":"ts","startedAt":"2025-09-12T03:03:19Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:58Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200329595","name":"rust","startedAt":"2025-09-12T03:03:18Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:16Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663250487/job/50200329770","name":"golden","startedAt":"2025-09-12T03:03:16Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"feat: emit proof tags in dev mode","updatedAt":"2025-09-12T03:04:52Z","url":"https://github.com/LexLattice/tf-lang/pull/23"}
```


---

# PR #24 — B2: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/24
- Author: @andreidita22
- Created: 2025-09-12T03:03:27Z
- Updated: 2025-09-12T03:05:28Z

## Checks
```
rust	pass	39s	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369976	
ts	pass	8s	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369983	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200370216	
Rust build & test	pass	38s	https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351309	
TypeScript build & test	pass	20s	https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351311	
changed	pass	8s	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200351319	
conformance	pass	25s	https://github.com/LexLattice/tf-lang/actions/runs/17663257057/job/50200351254	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request enhances the development experience by enabling detailed proof tag emission within the TypeScript and Rust virtual machines. The primary goal is to provide richer debugging and analysis capabilities for understanding VM execution flows, without impacting production performance or log verbosity, by making this feature strictly opt-in via an environment variable.

### Highlights

* **Conditional Proof Tag Emission**: Introduced a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust VMs, strictly gated by the `DEV_PROOFS=1` environment variable. This ensures that detailed proof logs are only generated in development environments.
* **VM Interpreter Integration**: Modified the core VM interpreters in both TypeScript and Rust to integrate the new proof tag emission. Tags are now emitted at key operational points, such as assertion failures, lens operations, function calls, and at the completion of execution to capture witness and normalization data.
* **New Proof Logging Modules**: Created dedicated proof logging modules in both Rust (`src/proof.rs`) and TypeScript (`src/proof/index.ts`) to manage the collection and flushing of proof tags. These modules provide `emit` and `flush` functions, centralizing the proof logging logic.
* **Testing and Documentation**: Added new test files (`proof_dev.rs` and `proof-dev.test.ts`) to explicitly verify that proof tags are emitted only when `DEV_PROOFS` is set, and are absent otherwise. Internal documentation (`.codex/JOURNAL.md`, `.codex/LESSONS.md`, `.codex/polish/B2.md`, `.codex/self-plans/B2.md`) has been updated to reflect these changes and the associated development plan.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces a valuable debugging feature by emitting proof tags in development mode for both the Rust and TypeScript VMs. The implementation is gated by a `DEV_PROOFS` environment variable, and new tests are added to verify this behavior. The changes are logical and well-structured. My review includes suggestions to improve the robustness of the tests against parallelism issues and to enhance type safety in the TypeScript implementation.
--
```

## Files Changed (JSON)
```json
[{"sha":"eb92ae62b7f86743522c27004c50e6d55b41fdbc","filename":".codex/JOURNAL.md","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -500,3 +500,15 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+## [B2] Proof tag emission\n+- Start: 2025-09-11 23:00 UTC\n+- End:   2025-09-11 23:30 UTC\n+- Changes:\n+  - added DEV_PROOFS-gated proof log in TS and Rust\n+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags\n+  - tests cover tag emission toggled by DEV_PROOFS\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests passed"},{"sha":"8f931145539f999c99b85f87c1f358500da6eb91","filename":".codex/LESSONS.md","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -18,3 +18,4 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-11] Rule: \"Proof tags emitted only when DEV_PROOFS=1.\" Guardrail: proof:dev_flag"},{"sha":"d15db569325eef38e564861509f191dee9687288","filename":".codex/polish/B2.md","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,2 @@\n+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.\n+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'."},{"sha":"c434bdd3898e1ed0286eada6f934fb1588576103","filename":".codex/self-plans/B2.md","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,25 @@\n+# Plan for B2\n+\n+## Steps\n+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.\n+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.\n+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.\n+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.\n+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.\n+6. Add Rust tests ensuring tags are emitted only in dev mode.\n+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.\n+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.\n+\n+## Tests\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks\n+- Environment variable may leak between tests; ensure logs are flushed and variables reset.\n+- Synchronizing tag structures across runtimes might be inconsistent.\n+- Adding dependency `once_cell` for Rust logging could impact build.\n+\n+## Definition of Done\n+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.\n+- Tests cover presence and absence of tags.\n+- Journal updated and repository tests pass."},{"sha":"307911ddff06feca12c7c48e4d09cc0328542053","filename":"packages/tf-lang-l0-rs/Cargo.lock","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.lock","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.lock","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.lock?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -79,6 +79,12 @@ version = \"2.7.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0\"\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.21.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n+\n [[package]]\n name = \"pretty_assertions\"\n version = \"1.4.1\"\n@@ -168,6 +174,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"blake3\",\n+ \"once_cell\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\","},{"sha":"b007053d53a73ac579af68fc9155f1a7f3582a7f","filename":"packages/tf-lang-l0-rs/Cargo.toml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.toml","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.toml","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.toml?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -17,6 +17,7 @@ thiserror = \"1\"\n serde = { version = \"1\", features = [\"derive\"] }\n serde_json = \"1\"\n blake3 = \"1.5\"\n+once_cell = \"1\"\n \n [dev-dependencies]\n pretty_assertions = \"1\""},{"sha":"f045263d515daabd2de3a95cbf854985a7df9f26","filename":"packages/tf-lang-l0-rs/src/proof.rs","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -42,3 +42,18 @@ pub enum ProofTag {\n     Refutation { code: String, msg: Option<String> },\n     Conservativity { callee: String, expected: String, found: String },\n }\n+\n+use once_cell::sync::Lazy;\n+use std::sync::Mutex;\n+\n+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));\n+\n+pub fn emit(tag: ProofTag) {\n+    if std::env::var(\"DEV_PROOFS\").unwrap_or_default() == \"1\" {\n+        PROOF_LOG.lock().unwrap().push(tag);\n+    }\n+}\n+\n+pub fn flush() -> Vec<ProofTag> {\n+    PROOF_LOG.lock().unwrap().drain(..).collect()\n+}"},{"sha":"383cd8315c311ce7237e43987f2b54a194b3618b","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":22,"deletions":7,"changes":29,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n use crate::vm::opcode::Host;\n+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n@@ -37,6 +38,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        emit(ProofTag::Refutation { code: \"ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -97,6 +99,7 @@ impl<'h> VM<'h> {\n                 }\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });\n                     regs[*dst as usize] = sub;\n                 }\n                 Instr::LensMerge {\n@@ -105,9 +108,10 @@ impl<'h> VM<'h> {\n                     region,\n                     sub,\n                 } => {\n-                    let merged =\n-                        self.host\n-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    let merged = self\n+                        .host\n+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });\n                     regs[*dst as usize] = merged;\n                 }\n                 Instr::PlanSim {\n@@ -173,7 +177,10 @@ impl<'h> VM<'h> {\n                     for r in args {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n-                    let out = self.host.call_tf(tf_id, &a)?;\n+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {\n+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: \"ok\".into(), found: format!(\"{}\", e) });\n+                        e\n+                    })?;\n                     regs[*dst as usize] = out;\n                 }\n             }\n@@ -184,10 +191,18 @@ impl<'h> VM<'h> {\n         }\n \n         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);\n-        let out = if final_state == initial_state {\n-            serde_json::Value::Null\n+        let delta = if final_state == initial_state {\n+            None\n         } else {\n-            serde_json::json!({ \"replace\": final_state })\n+            Some(Replace { replace: final_state.clone() })\n+        };\n+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });\n+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {\n+            emit(ProofTag::Normalization { target });\n+        }\n+        let out = match delta {\n+            None => serde_json::Value::Null,\n+            Some(d) => serde_json::json!({ \"replace\": d.replace }),\n         };\n \n         Ok(out)"},{"sha":"5301c8487c8e4dfc7b1f8715bcf8682113ce936e","filename":"packages/tf-lang-l0-rs/tests/proof_dev.rs","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,55 @@\n+use serde_json::json;\n+use tflang_l0::model::{Instr, Program};\n+use tflang_l0::vm::interpreter::VM;\n+use tflang_l0::vm::opcode::Host;\n+use tflang_l0::proof::{flush, ProofTag, TransportOp};\n+\n+struct DummyHost;\n+\n+impl Host for DummyHost {\n+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"region\": region, \"state\": state}))\n+    }\n+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"orig\": state, \"sub\": substate}))\n+    }\n+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok(\"id\".into()) }\n+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }\n+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {\n+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))\n+    }\n+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {\n+        Ok(tflang_l0::model::World(world.0.clone()))\n+    }\n+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }\n+}\n+\n+fn sample_prog() -> Program {\n+    Program {\n+        version: \"0.1\".into(),\n+        regs: 2,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!({}) },\n+            Instr::LensProj { dst: 1, state: 0, region: \"r\".into() },\n+            Instr::Const { dst: 0, value: json!({\"x\":1}) },\n+            Instr::Halt,\n+        ],\n+    }\n+}\n+\n+#[test]\n+fn dev_proofs_toggles_tags() {\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let vm = VM { host: &DummyHost };\n+    let _ = vm.run(&sample_prog()).unwrap();\n+    let tags = flush();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+\n+    std::env::remove_var(\"DEV_PROOFS\");\n+    let _ = vm.run(&sample_prog()).unwrap();\n+    let tags = flush();\n+    assert!(tags.is_empty());\n+}"},{"sha":"3588d098e018b666f5b502857717d14bbccb5a2b","filename":"packages/tf-lang-l0-ts/src/index.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -5,4 +5,4 @@ export * as check from './check/index.js';\n export { canonicalJsonBytes } from './canon/json.js';\n export { blake3hex } from './canon/hash.js';\n export * as ops from './ops/index.js';\n-export * as proof from './proof/tags.js';\n+export * as proof from './proof/index.js';"},{"sha":"991c932188806f388d3d6fae650a7d2e417609ea","filename":"packages/tf-lang-l0-ts/src/proof/index.ts","status":"added","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,16 @@\n+export * from './tags.js';\n+import type { ProofTag } from './tags.js';\n+\n+const log: ProofTag[] = [];\n+\n+export function emit(tag: ProofTag): void {\n+  if (process.env.DEV_PROOFS === '1') {\n+    log.push(tag);\n+  }\n+}\n+\n+export function flush(): ProofTag[] {\n+  const out = log.slice();\n+  log.length = 0;\n+  return out;\n+}"},{"sha":"c4b5fbe67565531cf1db48186290f87fc5a36451","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n+import { emit } from '../proof/index.js';\n \n export class VM {\n   constructor(public host: Host) {}\n@@ -41,8 +42,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +76,20 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          try {\n+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          } catch (e: any) {\n+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });\n+            throw e;\n+          }\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -91,10 +108,10 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    if (Buffer.from(a).equals(Buffer.from(b))) {\n-      return null;\n-    }\n-    return { replace: finalState };\n+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };\n+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));\n+    return delta;\n   }\n }\n "},{"sha":"691e4679f85237b347d8692bb2b4c81e7a982170","filename":"packages/tf-lang-l0-ts/tests/proof-dev.test.ts","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,35 @@\n+import { describe, it, expect } from 'vitest';\n+import { VM } from '../src/vm/index.js';\n+import type { Program } from '../src/model/bytecode.js';\n+import { DummyHost } from '../src/host/memory.js';\n+import { flush } from '../src/proof/index.js';\n+\n+describe('proof dev mode', () => {\n+  const prog: Program = {\n+    version: '0.1',\n+    regs: 2,\n+    instrs: [\n+      { op: 'CONST', dst: 0, value: {} },\n+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },\n+      { op: 'CONST', dst: 0, value: { x: 1 } },\n+      { op: 'HALT' },\n+    ],\n+  };\n+\n+  it('emits tags when DEV_PROOFS=1', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const vm = new VM(DummyHost);\n+    await vm.run(prog);\n+    const tags = flush();\n+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);\n+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);\n+    delete process.env.DEV_PROOFS;\n+  });\n+\n+  it('no tags when DEV_PROOFS is unset', async () => {\n+    const vm = new VM(DummyHost);\n+    await vm.run(prog);\n+    const tags = flush();\n+    expect(tags.length).toBe(0);\n+  });\n+});"},{"sha":"84020f7a6fb48f42653c12ed963f928fe34b852f","filename":"packages/tf-lang-l0-ts/tests/proof-tags.test.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -1,5 +1,5 @@\n import { describe, it, expect } from 'vitest';\n-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';\n+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';\n \n describe('proof tags', () => {\n   it('compile tag shapes', () => {"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..eb92ae6 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,15 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+## [B2] Proof tag emission
+- Start: 2025-09-11 23:00 UTC
+- End:   2025-09-11 23:30 UTC
+- Changes:
+  - added DEV_PROOFS-gated proof log in TS and Rust
+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags
+  - tests cover tag emission toggled by DEV_PROOFS
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests passed
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..8f93114 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,4 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-11] Rule: "Proof tags emitted only when DEV_PROOFS=1." Guardrail: proof:dev_flag
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..d15db56
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1,2 @@
+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.
+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..c434bdd
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,25 @@
+# Plan for B2
+
+## Steps
+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.
+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.
+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.
+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.
+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.
+6. Add Rust tests ensuring tags are emitted only in dev mode.
+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.
+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.
+
+## Tests
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks
+- Environment variable may leak between tests; ensure logs are flushed and variables reset.
+- Synchronizing tag structures across runtimes might be inconsistent.
+- Adding dependency `once_cell` for Rust logging could impact build.
+
+## Definition of Done
+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.
+- Tests cover presence and absence of tags.
+- Journal updated and repository tests pass.
diff --git a/packages/tf-lang-l0-rs/Cargo.lock b/packages/tf-lang-l0-rs/Cargo.lock
index 485414a..307911d 100644
--- a/packages/tf-lang-l0-rs/Cargo.lock
+++ b/packages/tf-lang-l0-rs/Cargo.lock
@@ -79,6 +79,12 @@ version = "2.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
 
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
 [[package]]
 name = "pretty_assertions"
 version = "1.4.1"
@@ -168,6 +174,7 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "blake3",
+ "once_cell",
  "pretty_assertions",
  "serde",
  "serde_json",
diff --git a/packages/tf-lang-l0-rs/Cargo.toml b/packages/tf-lang-l0-rs/Cargo.toml
index 253a2b2..b007053 100644
--- a/packages/tf-lang-l0-rs/Cargo.toml
+++ b/packages/tf-lang-l0-rs/Cargo.toml
@@ -17,6 +17,7 @@ thiserror = "1"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 blake3 = "1.5"
+once_cell = "1"
 
 [dev-dependencies]
 pretty_assertions = "1"
diff --git a/packages/tf-lang-l0-rs/src/proof.rs b/packages/tf-lang-l0-rs/src/proof.rs
index 4a4ea5e..f045263 100644
--- a/packages/tf-lang-l0-rs/src/proof.rs
+++ b/packages/tf-lang-l0-rs/src/proof.rs
@@ -42,3 +42,18 @@ pub enum ProofTag {
     Refutation { code: String, msg: Option<String> },
     Conservativity { callee: String, expected: String, found: String },
 }
+
+use once_cell::sync::Lazy;
+use std::sync::Mutex;
+
+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));
+
+pub fn emit(tag: ProofTag) {
+    if std::env::var("DEV_PROOFS").unwrap_or_default() == "1" {
+        PROOF_LOG.lock().unwrap().push(tag);
+    }
+}
+
+pub fn flush() -> Vec<ProofTag> {
+    PROOF_LOG.lock().unwrap().drain(..).collect()
+}
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..383cd83 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
 use crate::vm::opcode::Host;
+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
@@ -37,6 +38,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        emit(ProofTag::Refutation { code: "ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -97,6 +99,7 @@ impl<'h> VM<'h> {
                 }
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });
                     regs[*dst as usize] = sub;
                 }
                 Instr::LensMerge {
@@ -105,9 +108,10 @@ impl<'h> VM<'h> {
                     region,
                     sub,
                 } => {
-                    let merged =
-                        self.host
-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    let merged = self
+                        .host
+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });
                     regs[*dst as usize] = merged;
                 }
                 Instr::PlanSim {
@@ -173,7 +177,10 @@ impl<'h> VM<'h> {
                     for r in args {
                         a.push(get(*r, &regs)?.clone());
                     }
-                    let out = self.host.call_tf(tf_id, &a)?;
+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {
+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: "ok".into(), found: format!("{}", e) });
+                        e
+                    })?;
                     regs[*dst as usize] = out;
                 }
             }
@@ -184,10 +191,18 @@ impl<'h> VM<'h> {
         }
 
         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);
-        let out = if final_state == initial_state {
-            serde_json::Value::Null
+        let delta = if final_state == initial_state {
+            None
         } else {
-            serde_json::json!({ "replace": final_state })
+            Some(Replace { replace: final_state.clone() })
+        };
+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });
+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {
+            emit(ProofTag::Normalization { target });
+        }
+        let out = match delta {
+            None => serde_json::Value::Null,
+            Some(d) => serde_json::json!({ "replace": d.replace }),
         };
 
         Ok(out)
diff --git a/packages/tf-lang-l0-rs/tests/proof_dev.rs b/packages/tf-lang-l0-rs/tests/proof_dev.rs
new file mode 100644
index 0000000..5301c84
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/proof_dev.rs
@@ -0,0 +1,55 @@
+use serde_json::json;
+use tflang_l0::model::{Instr, Program};
+use tflang_l0::vm::interpreter::VM;
+use tflang_l0::vm::opcode::Host;
+use tflang_l0::proof::{flush, ProofTag, TransportOp};
+
+struct DummyHost;
+
+impl Host for DummyHost {
+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"region": region, "state": state}))
+    }
+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"orig": state, "sub": substate}))
+    }
+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok("id".into()) }
+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }
+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {
+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))
+    }
+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {
+        Ok(tflang_l0::model::World(world.0.clone()))
+    }
+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }
+}
+
+fn sample_prog() -> Program {
+    Program {
+        version: "0.1".into(),
+        regs: 2,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!({}) },
+            Instr::LensProj { dst: 1, state: 0, region: "r".into() },
+            Instr::Const { dst: 0, value: json!({"x":1}) },
+            Instr::Halt,
+        ],
+    }
+}
+
+#[test]
+fn dev_proofs_toggles_tags() {
+    std::env::set_var("DEV_PROOFS", "1");
+    let vm = VM { host: &DummyHost };
+    let _ = vm.run(&sample_prog()).unwrap();
+    let tags = flush();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+
+    std::env::remove_var("DEV_PROOFS");
+    let _ = vm.run(&sample_prog()).unwrap();
+    let tags = flush();
+    assert!(tags.is_empty());
+}
diff --git a/packages/tf-lang-l0-ts/src/index.ts b/packages/tf-lang-l0-ts/src/index.ts
index 14746e5..3588d09 100644
--- a/packages/tf-lang-l0-ts/src/index.ts
+++ b/packages/tf-lang-l0-ts/src/index.ts
@@ -5,4 +5,4 @@ export * as check from './check/index.js';
 export { canonicalJsonBytes } from './canon/json.js';
 export { blake3hex } from './canon/hash.js';
 export * as ops from './ops/index.js';
-export * as proof from './proof/tags.js';
+export * as proof from './proof/index.js';
diff --git a/packages/tf-lang-l0-ts/src/proof/index.ts b/packages/tf-lang-l0-ts/src/proof/index.ts
new file mode 100644
index 0000000..991c932
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/index.ts
@@ -0,0 +1,16 @@
+export * from './tags.js';
+import type { ProofTag } from './tags.js';
+
+const log: ProofTag[] = [];
+
+export function emit(tag: ProofTag): void {
+  if (process.env.DEV_PROOFS === '1') {
+    log.push(tag);
+  }
+}
+
+export function flush(): ProofTag[] {
+  const out = log.slice();
+  log.length = 0;
+  return out;
+}
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..c4b5fbe 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
+import { emit } from '../proof/index.js';
 
 export class VM {
   constructor(public host: Host) {}
@@ -41,8 +42,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +76,20 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          try {
+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          } catch (e: any) {
+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });
+            throw e;
+          }
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -91,10 +108,10 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    if (Buffer.from(a).equals(Buffer.from(b))) {
-      return null;
-    }
-    return { replace: finalState };
+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };
+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));
+    return delta;
   }
 }
 
diff --git a/packages/tf-lang-l0-ts/tests/proof-dev.test.ts b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
new file mode 100644
index 0000000..691e467
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
@@ -0,0 +1,35 @@
+import { describe, it, expect } from 'vitest';
+import { VM } from '../src/vm/index.js';
+import type { Program } from '../src/model/bytecode.js';
+import { DummyHost } from '../src/host/memory.js';
+import { flush } from '../src/proof/index.js';
+
+describe('proof dev mode', () => {
+  const prog: Program = {
+    version: '0.1',
+    regs: 2,
+    instrs: [
+      { op: 'CONST', dst: 0, value: {} },
+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },
+      { op: 'CONST', dst: 0, value: { x: 1 } },
+      { op: 'HALT' },
+    ],
+  };
+
+  it('emits tags when DEV_PROOFS=1', async () => {
+    process.env.DEV_PROOFS = '1';
+    const vm = new VM(DummyHost);
+    await vm.run(prog);
+    const tags = flush();
+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);
+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);
+    delete process.env.DEV_PROOFS;
+  });
+
+  it('no tags when DEV_PROOFS is unset', async () => {
+    const vm = new VM(DummyHost);
+    await vm.run(prog);
+    const tags = flush();
+    expect(tags.length).toBe(0);
+  });
+});
diff --git a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
index 73f4ae2..84020f7 100644
--- a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
+++ b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
@@ -1,5 +1,5 @@
 import { describe, it, expect } from 'vitest';
-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';
+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';
 
 describe('proof tags', () => {
   it('compile tag shapes', () => {
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T03:03:27Z","isDraft":false,"mergeStateStatus":"CLEAN","number":24,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_mEuL","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request enhances the development experience by enabling detailed proof tag emission within the TypeScript and Rust virtual machines. The primary goal is to provide richer debugging and analysis capabilities for understanding VM execution flows, without impacting production performance or log verbosity, by making this feature strictly opt-in via an environment variable.\n\n### Highlights\n\n* **Conditional Proof Tag Emission**: Introduced a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust VMs, strictly gated by the `DEV_PROOFS=1` environment variable. This ensures that detailed proof logs are only generated in development environments.\n* **VM Interpreter Integration**: Modified the core VM interpreters in both TypeScript and Rust to integrate the new proof tag emission. Tags are now emitted at key operational points, such as assertion failures, lens operations, function calls, and at the completion of execution to capture witness and normalization data.\n* **New Proof Logging Modules**: Created dedicated proof logging modules in both Rust (`src/proof.rs`) and TypeScript (`src/proof/index.ts`) to manage the collection and flushing of proof tags. These modules provide `emit` and `flush` functions, centralizing the proof logging logic.\n* **Testing and Documentation**: Added new test files (`proof_dev.rs` and `proof-dev.test.ts`) to explicitly verify that proof tags are emitted only when `DEV_PROOFS` is set, and are absent otherwise. Internal documentation (`.codex/JOURNAL.md`, `.codex/LESSONS.md`, `.codex/polish/B2.md`, `.codex/self-plans/B2.md`) has been updated to reflect these changes and the associated development plan.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T03:03:45Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"f8920220396bfa1869abd6d2a52d469efb2cd4c0"}},{"id":"PRR_kwDOPs5-l86_mFJ5","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces a valuable debugging feature by emitting proof tags in development mode for both the Rust and TypeScript VMs. The implementation is gated by a `DEV_PROOFS` environment variable, and new tests are added to verify this behavior. The changes are logical and well-structured. My review includes suggestions to improve the robustness of the tests against parallelism issues and to enhance type safety in the TypeScript implementation.","submittedAt":"2025-09-12T03:05:28Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"f8920220396bfa1869abd6d2a52d469efb2cd4c0"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:58Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257057/job/50200351254","name":"conformance","startedAt":"2025-09-12T03:03:33Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:52Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351311","name":"TypeScript build & test","startedAt":"2025-09-12T03:03:32Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:40Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200351319","name":"changed","startedAt":"2025-09-12T03:03:32Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:04:11Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351309","name":"Rust build & test","startedAt":"2025-09-12T03:03:33Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:50Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369983","name":"ts","startedAt":"2025-09-12T03:03:42Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:04:21Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369976","name":"rust","startedAt":"2025-09-12T03:03:42Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:40Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200370216","name":"golden","startedAt":"2025-09-12T03:03:40Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"B2: emit proof tags in dev mode","updatedAt":"2025-09-12T03:05:28Z","url":"https://github.com/LexLattice/tf-lang/pull/24"}
```


---

# PR #25 — feat: emit dev proof tags
- URL: https://github.com/LexLattice/tf-lang/pull/25
- Author: @andreidita22
- Created: 2025-09-12T03:04:36Z
- Updated: 2025-09-12T03:07:03Z

## Checks
```
conformance	fail	31s	https://github.com/LexLattice/tf-lang/actions/runs/17663277021/job/50200482405	
rust	fail	35s	https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200493863	
ts	pass	13s	https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200493855	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200493999	
Rust build & test	pass	32s	https://github.com/LexLattice/tf-lang/actions/runs/17663277032/job/50200482429	
TypeScript build & test	pass	14s	https://github.com/LexLattice/tf-lang/actions/runs/17663277032/job/50200482447	
changed	pass	7s	https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200482441	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request introduces a new feature that allows for the conditional emission of detailed proof tags within the TypeScript and Rust Virtual Machines. This capability is specifically designed for development and debugging purposes, enabling deeper insight into VM execution and state transformations when the DEV_PROOFS environment variable is enabled. The changes ensure that this diagnostic information is only generated when explicitly requested, preventing any performance impact or data leakage in production environments.

### Highlights

* **Conditional Proof Tag Emission**: Implemented a mechanism to emit various proof tags (witness, normalization, transport, refutation, conservativity) in both TypeScript and Rust Virtual Machines, gated by the DEV_PROOFS environment variable.
* **Comprehensive Test Coverage**: Added new unit tests in both runtimes to verify the correct emission and absence of proof tags based on the DEV_PROOFS flag.
* **Documentation Updates**: Documented the new DEV_PROOFS rule in the project's lessons and journal entries, ensuring clarity on its intended use.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request effectively introduces the emission of development-time proof tags in both the Rust and TypeScript VMs, gated by the `DEV_PROOFS` environment variable. The changes are well-implemented across both languages, and the inclusion of new unit tests to cover both the presence and absence of these tags is excellent. The documentation updates are also clear and helpful.

My review focuses on improving the robustness and clarity of the new Rust tests. Specifically, I've suggested using a safer pattern for managing environment variables to prevent test flakiness, splitting a test case for better atomicity, and making a test mock more specific to avoid potential future issues. Overall, this is a solid contribution.
--
author:	chatgpt-codex-connector
association:	none
edited:	false
status:	commented
--
Codex Review: Here are some suggestions.

Reply with `@codex fix comments` to fix any unresolved comments.

<details> <summary>About Codex in GitHub</summary>

[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment "@codex review". If Codex has suggestions, it will comment; otherwise it will react with 👍.

Codex can also answer questions or update the PR. Try commenting "@codex fix this CI failure" or "@codex address that feedback".
</details>
--
```

## Files Changed (JSON)
```json
[{"sha":"835485ffc281b45aa2bf9f159ee464f77650301a","filename":".codex/JOURNAL.md","status":"modified","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -500,3 +500,20 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+\n+## [B2] DEV proof tags\n+- Start: 2025-09-12 02:50 UTC\n+- End:   2025-09-12 03:00 UTC\n+- Lessons consulted:\n+  - A1–B1\n+- Changes:\n+  - gated proof-tag sink in TS and Rust VMs emitting witness, normalization, transport, refutation, and conservativity tags\n+  - added tests for tag presence/absence in both runtimes\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - pnpm -C packages/tf-lang-l0-ts vectors\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests and vectors passed\n+- Next suggested step:\n+  - C1"},{"sha":"28a25cd9d7f37073a5817815da24e4847f71bf6e","filename":".codex/LESSONS.md","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -18,3 +18,4 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-12] Rule: \"Emit proof tags only when DEV_PROOFS=1.\" Guardrail: proof:dev_flag"},{"sha":"d31a26b5fe12c7d6b83f4773d6cedb5b97eafe8f","filename":".codex/polish/B2.md","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -0,0 +1,2 @@\n+# Polish for Task B2\n+- Clear `DEV_PROOFS` after Rust tests to avoid environment bleed."},{"sha":"f4d43c9072b036804961c94a9dbb4f006f836589","filename":".codex/self-plans/B2.md","status":"added","additions":27,"deletions":0,"changes":27,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -0,0 +1,27 @@\n+# Plan for Task B2\n+\n+## Steps\n+1. Add proof-tag emission to TS VM (`packages/tf-lang-l0-ts/src/vm/interpreter.ts`).\n+   - Initialize optional `tags` array when `process.env.DEV_PROOFS === '1'`.\n+   - Provide `emit` helper and push Witness/Normalization tags after final delta, Transport tags for lens ops, Refutation on failed ASSERT, and Conservativity when `call_tf` returns `null`.\n+2. Mirror the same logic in Rust VM (`packages/tf-lang-l0-rs/src/vm/interpreter.rs`).\n+   - Use `Option<Vec<ProofTag>>` gated by `std::env::var(\"DEV_PROOFS\") == Ok(\"1\".into())`.\n+3. Add tests verifying tag emission and absence.\n+   - TS: new tests under `packages/tf-lang-l0-ts/tests` covering witness/transport, refutation, conservativity, and off-by-default.\n+   - Rust: analogous tests under `packages/tf-lang-l0-rs/tests`.\n+4. Append B2 entry to `.codex/JOURNAL.md`; add lesson if a general rule emerges.\n+\n+## Test Changes\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `pnpm -C packages/tf-lang-l0-ts vectors`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks & Rollback\n+- Tag emission may alter runtime behavior if not fully gated; ensure tags only stored when flag enabled.\n+- Rust env handling may differ across platforms; tests set variable explicitly.\n+- Rollback by removing tag-related code and tests.\n+\n+## Definition of Done\n+- TS and Rust VMs emit proof tags only when DEV_PROOFS=1.\n+- Tests cover presence/absence and pass alongside existing suite.\n+- Journal updated (and lesson added if applicable)."},{"sha":"104d2ad74787aa596efecb6d1452871350f4514a","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":39,"deletions":2,"changes":41,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -1,12 +1,14 @@\n use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n+use crate::proof::{Effect, NormalizationTarget, ProofTag, Replace, TransportOp};\n use crate::vm::opcode::Host;\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n pub struct VM<'h> {\n     pub host: &'h dyn Host,\n+    pub tags: Option<Vec<ProofTag>>,\n }\n \n #[derive(thiserror::Error, Debug)]\n@@ -18,7 +20,22 @@ pub enum VmError {\n }\n \n impl<'h> VM<'h> {\n-    pub fn run(&self, prog: &Program) -> anyhow::Result<Value> {\n+    pub fn new(host: &'h dyn Host) -> Self {\n+        let tags = if std::env::var(\"DEV_PROOFS\").ok().as_deref() == Some(\"1\") {\n+            Some(Vec::new())\n+        } else {\n+            None\n+        };\n+        VM { host, tags }\n+    }\n+\n+    fn emit(&mut self, tag: ProofTag) {\n+        if let Some(ts) = &mut self.tags {\n+            ts.push(tag);\n+        }\n+    }\n+\n+    pub fn run(&mut self, prog: &Program) -> anyhow::Result<Value> {\n         let mut regs: Vec<Value> = vec![serde_json::Value::Null; prog.regs as usize];\n         let mut initial_state = regs[0].clone();\n         let mut init_captured = false;\n@@ -37,6 +54,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        self.emit(ProofTag::Refutation { code: \"E_ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -98,6 +116,7 @@ impl<'h> VM<'h> {\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n                     regs[*dst as usize] = sub;\n+                    self.emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.to_string() });\n                 }\n                 Instr::LensMerge {\n                     dst,\n@@ -109,6 +128,7 @@ impl<'h> VM<'h> {\n                         self.host\n                             .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n                     regs[*dst as usize] = merged;\n+                    self.emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.to_string() });\n                 }\n                 Instr::PlanSim {\n                     dst_delta,\n@@ -174,6 +194,13 @@ impl<'h> VM<'h> {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n                     let out = self.host.call_tf(tf_id, &a)?;\n+                    if out.is_null() {\n+                        self.emit(ProofTag::Conservativity {\n+                            callee: tf_id.clone(),\n+                            expected: \"non-null\".into(),\n+                            found: \"null\".into(),\n+                        });\n+                    }\n                     regs[*dst as usize] = out;\n                 }\n             }\n@@ -184,7 +211,17 @@ impl<'h> VM<'h> {\n         }\n \n         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);\n-        let out = if final_state == initial_state {\n+        let a = canonical_json_bytes(&initial_state)?;\n+        let b = canonical_json_bytes(&final_state)?;\n+        let same = a == b;\n+        if let Some(ts) = &mut self.tags {\n+            let delta = if same { None } else { Some(Replace { replace: final_state.clone() }) };\n+            let effect = Effect::default();\n+            ts.push(ProofTag::Witness { delta, effect });\n+            ts.push(ProofTag::Normalization { target: NormalizationTarget::Delta });\n+            ts.push(ProofTag::Normalization { target: NormalizationTarget::Effect });\n+        }\n+        let out = if same {\n             serde_json::Value::Null\n         } else {\n             serde_json::json!({ \"replace\": final_state })"},{"sha":"cee076a6462729028ff373423744f09253f10a22","filename":"packages/tf-lang-l0-rs/tests/laws.rs","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Ftests%2Flaws.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Ftests%2Flaws.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Flaws.rs?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -108,7 +108,7 @@ fn vm_runs_halt_program() -> Result<()> {\n         regs: 2,\n         instrs: vec![Instr::Halt],\n     };\n-    let vm = VM { host: &DummyHost };\n+    let mut vm = VM::new(&DummyHost);\n     let out = vm.run(&prog)?;\n     assert_eq!(out, serde_json::Value::Null);\n     Ok(())\n@@ -143,7 +143,7 @@ fn vm_basic_ops() -> Result<()> {\n             Instr::Halt,\n         ],\n     };\n-    let vm = VM { host: &DummyHost };\n+    let mut vm = VM::new(&DummyHost);\n     let out = vm.run(&prog)?;\n     // r0 is returned by our VM.run. It should be untouched Null unless overwritten.\n     assert_eq!(out, serde_json::Value::Null);\n@@ -237,7 +237,7 @@ fn law_rewind_apply_id_pair_ids_equal() -> Result<()> {\n             Instr::Halt,\n         ],\n     };\n-    let vm = VM { host: &DummyHost };\n+    let mut vm = VM::new(&DummyHost);\n     let out = vm.run(&prog)?;\n     let obj = out\n         .get(\"replace\")"},{"sha":"ffb4a78b74343f2f9787c4755135530d2f07117f","filename":"packages/tf-lang-l0-rs/tests/proof.rs","status":"modified","additions":105,"deletions":1,"changes":106,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof.rs?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -1,5 +1,9 @@\n use serde_json::{json, Value};\n-use tflang_l0::proof::{Delta, Effect, NormalizationTarget, Replace, ProofTag, TransportOp};\n+use tflang_l0::proof::{Delta, Effect, NormalizationTarget, ProofTag, Replace, TransportOp};\n+use tflang_l0::vm::interpreter::VM;\n+use tflang_l0::vm::opcode::Host;\n+use tflang_l0::model::{Instr, Program};\n+use anyhow::Result;\n \n #[test]\n fn proof_tag_shapes() {\n@@ -26,3 +30,103 @@ fn serde_roundtrip_normalization() {\n     let v = serde_json::to_value(&n).unwrap();\n     assert_eq!(v, json!({\"kind\":\"Normalization\",\"target\":\"delta\"}));\n }\n+\n+struct MiniHost;\n+\n+impl Host for MiniHost {\n+    fn lens_project(&self, state: &Value, region: &str) -> anyhow::Result<Value> {\n+        Ok(json!({\"region\": region, \"state\": state}))\n+    }\n+    fn lens_merge(&self, state: &Value, _region: &str, substate: &Value) -> anyhow::Result<Value> {\n+        Ok(json!({\"orig\": state, \"sub\": substate}))\n+    }\n+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &Value) -> anyhow::Result<String> { Ok(\"id\".into()) }\n+    fn diff_apply(&self, state: &Value, delta: &Value) -> anyhow::Result<Value> {\n+        if let Some(arr) = state.as_array() {\n+            if let Some(v) = delta.get(\"append\") {\n+                let mut new = arr.clone();\n+                new.push(v.clone());\n+                return Ok(Value::Array(new));\n+            }\n+        }\n+        Ok(state.clone())\n+    }\n+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> { Ok(json!({\"invert\": delta})) }\n+    fn journal_record(&self, _plan: &Value, delta: &Value, s0: &str, s1: &str, _meta: &Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {\n+        Ok(tflang_l0::model::JournalEntry(json!({\"delta\": delta, \"from\": s0, \"to\": s1})))\n+    }\n+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {\n+        Ok(world.clone())\n+    }\n+    fn call_tf(&self, tf_id: &str, _args: &[Value]) -> anyhow::Result<Value> {\n+        if tf_id == \"tf://missing@0.1\" {\n+            Ok(Value::Null)\n+        } else {\n+            Ok(Value::Null)\n+        }\n+    }\n+}\n+\n+#[test]\n+fn emits_tags_when_enabled() -> Result<()> {\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let prog = Program {\n+        version: \"0.1\".into(),\n+        regs: 3,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!([]) },\n+            Instr::Const { dst: 1, value: json!({\"append\": 1}) },\n+            Instr::DiffApply { dst: 0, state: 0, delta: 1 },\n+            Instr::LensProj { dst: 2, state: 0, region: \"r\".into() },\n+            Instr::Halt,\n+        ],\n+    };\n+    let mut vm = VM::new(&MiniHost);\n+    vm.run(&prog)?;\n+    let tags = vm.tags.unwrap();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { .. })));\n+    assert!(tags.iter().filter(|t| matches!(t, ProofTag::Normalization { .. })).count() > 0);\n+    std::env::remove_var(\"DEV_PROOFS\");\n+    Ok(())\n+}\n+\n+#[test]\n+fn refutation_and_conservativity() -> Result<()> {\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let prog = Program {\n+        version: \"0.1\".into(),\n+        regs: 2,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!(0) },\n+            Instr::Assert { pred: 0, msg: \"no\".into() },\n+        ],\n+    };\n+    let mut vm = VM::new(&MiniHost);\n+    assert!(vm.run(&prog).is_err());\n+    let tags = vm.tags.unwrap();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Refutation { .. })));\n+\n+    let prog2 = Program {\n+        version: \"0.1\".into(),\n+        regs: 1,\n+        instrs: vec![Instr::Call { dst: 0, tf_id: \"tf://missing@0.1\".into(), args: vec![] }],\n+    };\n+    let mut vm2 = VM::new(&MiniHost);\n+    vm2.run(&prog2)?;\n+    let tags2 = vm2.tags.unwrap();\n+    assert!(tags2.iter().any(|t| matches!(t, ProofTag::Conservativity { .. })));\n+    std::env::remove_var(\"DEV_PROOFS\");\n+    Ok(())\n+}\n+\n+#[test]\n+fn silent_when_disabled() -> Result<()> {\n+    std::env::remove_var(\"DEV_PROOFS\");\n+    let prog = Program { version: \"0.1\".into(), regs: 1, instrs: vec![Instr::Halt] };\n+    let mut vm = VM::new(&MiniHost);\n+    vm.run(&prog)?;\n+    assert!(vm.tags.is_none());\n+    Ok(())\n+}"},{"sha":"8ad42d582abbba898a367170c220f283e1e825b0","filename":"packages/tf-lang-l0-rs/tests/vectors.rs","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Ftests%2Fvectors.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-rs%2Ftests%2Fvectors.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fvectors.rs?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -423,7 +423,7 @@ fn vectors() -> Result<()> {\n         lint_vector(&vec)?;\n \n         let host = EffectHost::new(DummyHost);\n-        let vm = VM { host: &host };\n+        let mut vm = VM::new(&host);\n         let run_res = vm.run(&vec.bytecode);\n         let (delta, err_msg) = match run_res {\n             Ok(d) => (d, None),"},{"sha":"bfed785132866ee3b2ebfed0a9bc88bb7d6c5c88","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":38,"deletions":6,"changes":44,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -1,10 +1,19 @@\n import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n+import type { ProofTag } from '../proof/tags.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n \n export class VM {\n-  constructor(public host: Host) {}\n+  constructor(public host: Host) {\n+    if (process?.env?.DEV_PROOFS === '1') this.tags = [];\n+  }\n+\n+  tags?: ProofTag[];\n+\n+  private emit(tag: ProofTag) {\n+    this.tags?.push(tag);\n+  }\n \n   private get(regs: Value[], idx: number): Value {\n     if (idx < 0 || idx >= regs.length) throw new Error(`register out of bounds: r${idx}`);\n@@ -41,8 +50,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          this.emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          this.emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +84,19 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          const out = await this.host.call_tf(ins.tf_id, args);\n+          if (out === null) {\n+            this.emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'non-null', found: 'null' });\n+          }\n+          regs[ins.dst] = out;\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            this.emit({ kind: 'Refutation', code: 'E_ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -91,7 +115,15 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    if (Buffer.from(a).equals(Buffer.from(b))) {\n+    const same = Buffer.from(a).equals(Buffer.from(b));\n+    if (this.tags) {\n+      const delta = same ? null : { replace: finalState };\n+      const effect = { read: [], write: [], external: [] };\n+      this.emit({ kind: 'Witness', delta, effect });\n+      this.emit({ kind: 'Normalization', target: 'delta' });\n+      this.emit({ kind: 'Normalization', target: 'effect' });\n+    }\n+    if (same) {\n       return null;\n     }\n     return { replace: finalState };"},{"sha":"d77182bb61289f347e29d4aac87a7a6dcb1105f5","filename":"packages/tf-lang-l0-ts/tests/dev-proofs.test.ts","status":"added","additions":67,"deletions":0,"changes":67,"blob_url":"https://github.com/LexLattice/tf-lang/blob/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-ts%2Ftests%2Fdev-proofs.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/b2322a8cfe46d008f22cbf18b2718415591d71b8/packages%2Ftf-lang-l0-ts%2Ftests%2Fdev-proofs.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fdev-proofs.test.ts?ref=b2322a8cfe46d008f22cbf18b2718415591d71b8","patch":"@@ -0,0 +1,67 @@\n+import { describe, it, expect, afterEach } from 'vitest';\n+import { VM } from '../src/vm/interpreter.js';\n+import { DummyHost } from '../src/host/memory.js';\n+import type { Program } from '../src/model/bytecode.js';\n+\n+afterEach(() => {\n+  delete process.env.DEV_PROOFS;\n+});\n+\n+describe('DEV_PROOFS emission', () => {\n+  it('emits witness and transport tags', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const prog: Program = {\n+      version: '0.1',\n+      regs: 3,\n+      instrs: [\n+        { op: 'CONST', dst: 0, value: [] },\n+        { op: 'CONST', dst: 1, value: { append: 1 } },\n+        { op: 'DIFF_APPLY', dst: 0, state: 0, delta: 1 },\n+        { op: 'LENS_PROJ', dst: 2, state: 0, region: 'r' },\n+        { op: 'HALT' },\n+      ],\n+    };\n+    const vm = new VM(DummyHost);\n+    await vm.run(prog);\n+    expect(vm.tags?.some(t => t.kind === 'Witness')).toBe(true);\n+    expect(vm.tags?.filter(t => t.kind === 'Normalization').length).toBeGreaterThan(0);\n+    expect(vm.tags?.some(t => t.kind === 'Transport' && t.op === 'LENS_PROJ')).toBe(true);\n+  });\n+\n+  it('emits refutation on ASSERT failure', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const prog: Program = {\n+      version: '0.1',\n+      regs: 1,\n+      instrs: [\n+        { op: 'CONST', dst: 0, value: 0 },\n+        { op: 'ASSERT', pred: 0, msg: 'no' },\n+      ],\n+    };\n+    const vm = new VM(DummyHost);\n+    await expect(vm.run(prog)).rejects.toThrow();\n+    expect(vm.tags?.some(t => t.kind === 'Refutation')).toBe(true);\n+  });\n+\n+  it('emits conservativity on missing call', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const prog: Program = {\n+      version: '0.1',\n+      regs: 1,\n+      instrs: [\n+        { op: 'CALL', dst: 0, tf_id: 'tf://missing@0.1', args: [] },\n+        { op: 'HALT' },\n+      ],\n+    };\n+    const vm = new VM(DummyHost);\n+    await vm.run(prog);\n+    expect(vm.tags?.some(t => t.kind === 'Conservativity')).toBe(true);\n+  });\n+\n+  it('is silent when DEV_PROOFS unset', async () => {\n+    const prog: Program = { version: '0.1', regs: 1, instrs: [ { op: 'HALT' } ] };\n+    const vm = new VM(DummyHost);\n+    await vm.run(prog);\n+    expect(vm.tags).toBeUndefined();\n+  });\n+});"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..835485f 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,20 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+
+## [B2] DEV proof tags
+- Start: 2025-09-12 02:50 UTC
+- End:   2025-09-12 03:00 UTC
+- Lessons consulted:
+  - A1–B1
+- Changes:
+  - gated proof-tag sink in TS and Rust VMs emitting witness, normalization, transport, refutation, and conservativity tags
+  - added tests for tag presence/absence in both runtimes
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - pnpm -C packages/tf-lang-l0-ts vectors
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests and vectors passed
+- Next suggested step:
+  - C1
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..28a25cd 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,4 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-12] Rule: "Emit proof tags only when DEV_PROOFS=1." Guardrail: proof:dev_flag
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..d31a26b
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1,2 @@
+# Polish for Task B2
+- Clear `DEV_PROOFS` after Rust tests to avoid environment bleed.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..f4d43c9
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,27 @@
+# Plan for Task B2
+
+## Steps
+1. Add proof-tag emission to TS VM (`packages/tf-lang-l0-ts/src/vm/interpreter.ts`).
+   - Initialize optional `tags` array when `process.env.DEV_PROOFS === '1'`.
+   - Provide `emit` helper and push Witness/Normalization tags after final delta, Transport tags for lens ops, Refutation on failed ASSERT, and Conservativity when `call_tf` returns `null`.
+2. Mirror the same logic in Rust VM (`packages/tf-lang-l0-rs/src/vm/interpreter.rs`).
+   - Use `Option<Vec<ProofTag>>` gated by `std::env::var("DEV_PROOFS") == Ok("1".into())`.
+3. Add tests verifying tag emission and absence.
+   - TS: new tests under `packages/tf-lang-l0-ts/tests` covering witness/transport, refutation, conservativity, and off-by-default.
+   - Rust: analogous tests under `packages/tf-lang-l0-rs/tests`.
+4. Append B2 entry to `.codex/JOURNAL.md`; add lesson if a general rule emerges.
+
+## Test Changes
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `pnpm -C packages/tf-lang-l0-ts vectors`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks & Rollback
+- Tag emission may alter runtime behavior if not fully gated; ensure tags only stored when flag enabled.
+- Rust env handling may differ across platforms; tests set variable explicitly.
+- Rollback by removing tag-related code and tests.
+
+## Definition of Done
+- TS and Rust VMs emit proof tags only when DEV_PROOFS=1.
+- Tests cover presence/absence and pass alongside existing suite.
+- Journal updated (and lesson added if applicable).
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..104d2ad 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -1,12 +1,14 @@
 use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
+use crate::proof::{Effect, NormalizationTarget, ProofTag, Replace, TransportOp};
 use crate::vm::opcode::Host;
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
 pub struct VM<'h> {
     pub host: &'h dyn Host,
+    pub tags: Option<Vec<ProofTag>>,
 }
 
 #[derive(thiserror::Error, Debug)]
@@ -18,7 +20,22 @@ pub enum VmError {
 }
 
 impl<'h> VM<'h> {
-    pub fn run(&self, prog: &Program) -> anyhow::Result<Value> {
+    pub fn new(host: &'h dyn Host) -> Self {
+        let tags = if std::env::var("DEV_PROOFS").ok().as_deref() == Some("1") {
+            Some(Vec::new())
+        } else {
+            None
+        };
+        VM { host, tags }
+    }
+
+    fn emit(&mut self, tag: ProofTag) {
+        if let Some(ts) = &mut self.tags {
+            ts.push(tag);
+        }
+    }
+
+    pub fn run(&mut self, prog: &Program) -> anyhow::Result<Value> {
         let mut regs: Vec<Value> = vec![serde_json::Value::Null; prog.regs as usize];
         let mut initial_state = regs[0].clone();
         let mut init_captured = false;
@@ -37,6 +54,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        self.emit(ProofTag::Refutation { code: "E_ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -98,6 +116,7 @@ impl<'h> VM<'h> {
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
                     regs[*dst as usize] = sub;
+                    self.emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.to_string() });
                 }
                 Instr::LensMerge {
                     dst,
@@ -109,6 +128,7 @@ impl<'h> VM<'h> {
                         self.host
                             .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
                     regs[*dst as usize] = merged;
+                    self.emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.to_string() });
                 }
                 Instr::PlanSim {
                     dst_delta,
@@ -174,6 +194,13 @@ impl<'h> VM<'h> {
                         a.push(get(*r, &regs)?.clone());
                     }
                     let out = self.host.call_tf(tf_id, &a)?;
+                    if out.is_null() {
+                        self.emit(ProofTag::Conservativity {
+                            callee: tf_id.clone(),
+                            expected: "non-null".into(),
+                            found: "null".into(),
+                        });
+                    }
                     regs[*dst as usize] = out;
                 }
             }
@@ -184,7 +211,17 @@ impl<'h> VM<'h> {
         }
 
         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);
-        let out = if final_state == initial_state {
+        let a = canonical_json_bytes(&initial_state)?;
+        let b = canonical_json_bytes(&final_state)?;
+        let same = a == b;
+        if let Some(ts) = &mut self.tags {
+            let delta = if same { None } else { Some(Replace { replace: final_state.clone() }) };
+            let effect = Effect::default();
+            ts.push(ProofTag::Witness { delta, effect });
+            ts.push(ProofTag::Normalization { target: NormalizationTarget::Delta });
+            ts.push(ProofTag::Normalization { target: NormalizationTarget::Effect });
+        }
+        let out = if same {
             serde_json::Value::Null
         } else {
             serde_json::json!({ "replace": final_state })
diff --git a/packages/tf-lang-l0-rs/tests/laws.rs b/packages/tf-lang-l0-rs/tests/laws.rs
index 6d20382..cee076a 100644
--- a/packages/tf-lang-l0-rs/tests/laws.rs
+++ b/packages/tf-lang-l0-rs/tests/laws.rs
@@ -108,7 +108,7 @@ fn vm_runs_halt_program() -> Result<()> {
         regs: 2,
         instrs: vec![Instr::Halt],
     };
-    let vm = VM { host: &DummyHost };
+    let mut vm = VM::new(&DummyHost);
     let out = vm.run(&prog)?;
     assert_eq!(out, serde_json::Value::Null);
     Ok(())
@@ -143,7 +143,7 @@ fn vm_basic_ops() -> Result<()> {
             Instr::Halt,
         ],
     };
-    let vm = VM { host: &DummyHost };
+    let mut vm = VM::new(&DummyHost);
     let out = vm.run(&prog)?;
     // r0 is returned by our VM.run. It should be untouched Null unless overwritten.
     assert_eq!(out, serde_json::Value::Null);
@@ -237,7 +237,7 @@ fn law_rewind_apply_id_pair_ids_equal() -> Result<()> {
             Instr::Halt,
         ],
     };
-    let vm = VM { host: &DummyHost };
+    let mut vm = VM::new(&DummyHost);
     let out = vm.run(&prog)?;
     let obj = out
         .get("replace")
diff --git a/packages/tf-lang-l0-rs/tests/proof.rs b/packages/tf-lang-l0-rs/tests/proof.rs
index 96788dc..ffb4a78 100644
--- a/packages/tf-lang-l0-rs/tests/proof.rs
+++ b/packages/tf-lang-l0-rs/tests/proof.rs
@@ -1,5 +1,9 @@
 use serde_json::{json, Value};
-use tflang_l0::proof::{Delta, Effect, NormalizationTarget, Replace, ProofTag, TransportOp};
+use tflang_l0::proof::{Delta, Effect, NormalizationTarget, ProofTag, Replace, TransportOp};
+use tflang_l0::vm::interpreter::VM;
+use tflang_l0::vm::opcode::Host;
+use tflang_l0::model::{Instr, Program};
+use anyhow::Result;
 
 #[test]
 fn proof_tag_shapes() {
@@ -26,3 +30,103 @@ fn serde_roundtrip_normalization() {
     let v = serde_json::to_value(&n).unwrap();
     assert_eq!(v, json!({"kind":"Normalization","target":"delta"}));
 }
+
+struct MiniHost;
+
+impl Host for MiniHost {
+    fn lens_project(&self, state: &Value, region: &str) -> anyhow::Result<Value> {
+        Ok(json!({"region": region, "state": state}))
+    }
+    fn lens_merge(&self, state: &Value, _region: &str, substate: &Value) -> anyhow::Result<Value> {
+        Ok(json!({"orig": state, "sub": substate}))
+    }
+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &Value) -> anyhow::Result<String> { Ok("id".into()) }
+    fn diff_apply(&self, state: &Value, delta: &Value) -> anyhow::Result<Value> {
+        if let Some(arr) = state.as_array() {
+            if let Some(v) = delta.get("append") {
+                let mut new = arr.clone();
+                new.push(v.clone());
+                return Ok(Value::Array(new));
+            }
+        }
+        Ok(state.clone())
+    }
+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> { Ok(json!({"invert": delta})) }
+    fn journal_record(&self, _plan: &Value, delta: &Value, s0: &str, s1: &str, _meta: &Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {
+        Ok(tflang_l0::model::JournalEntry(json!({"delta": delta, "from": s0, "to": s1})))
+    }
+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {
+        Ok(world.clone())
+    }
+    fn call_tf(&self, tf_id: &str, _args: &[Value]) -> anyhow::Result<Value> {
+        if tf_id == "tf://missing@0.1" {
+            Ok(Value::Null)
+        } else {
+            Ok(Value::Null)
+        }
+    }
+}
+
+#[test]
+fn emits_tags_when_enabled() -> Result<()> {
+    std::env::set_var("DEV_PROOFS", "1");
+    let prog = Program {
+        version: "0.1".into(),
+        regs: 3,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!([]) },
+            Instr::Const { dst: 1, value: json!({"append": 1}) },
+            Instr::DiffApply { dst: 0, state: 0, delta: 1 },
+            Instr::LensProj { dst: 2, state: 0, region: "r".into() },
+            Instr::Halt,
+        ],
+    };
+    let mut vm = VM::new(&MiniHost);
+    vm.run(&prog)?;
+    let tags = vm.tags.unwrap();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { .. })));
+    assert!(tags.iter().filter(|t| matches!(t, ProofTag::Normalization { .. })).count() > 0);
+    std::env::remove_var("DEV_PROOFS");
+    Ok(())
+}
+
+#[test]
+fn refutation_and_conservativity() -> Result<()> {
+    std::env::set_var("DEV_PROOFS", "1");
+    let prog = Program {
+        version: "0.1".into(),
+        regs: 2,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!(0) },
+            Instr::Assert { pred: 0, msg: "no".into() },
+        ],
+    };
+    let mut vm = VM::new(&MiniHost);
+    assert!(vm.run(&prog).is_err());
+    let tags = vm.tags.unwrap();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Refutation { .. })));
+
+    let prog2 = Program {
+        version: "0.1".into(),
+        regs: 1,
+        instrs: vec![Instr::Call { dst: 0, tf_id: "tf://missing@0.1".into(), args: vec![] }],
+    };
+    let mut vm2 = VM::new(&MiniHost);
+    vm2.run(&prog2)?;
+    let tags2 = vm2.tags.unwrap();
+    assert!(tags2.iter().any(|t| matches!(t, ProofTag::Conservativity { .. })));
+    std::env::remove_var("DEV_PROOFS");
+    Ok(())
+}
+
+#[test]
+fn silent_when_disabled() -> Result<()> {
+    std::env::remove_var("DEV_PROOFS");
+    let prog = Program { version: "0.1".into(), regs: 1, instrs: vec![Instr::Halt] };
+    let mut vm = VM::new(&MiniHost);
+    vm.run(&prog)?;
+    assert!(vm.tags.is_none());
+    Ok(())
+}
diff --git a/packages/tf-lang-l0-rs/tests/vectors.rs b/packages/tf-lang-l0-rs/tests/vectors.rs
index 22f634f..8ad42d5 100644
--- a/packages/tf-lang-l0-rs/tests/vectors.rs
+++ b/packages/tf-lang-l0-rs/tests/vectors.rs
@@ -423,7 +423,7 @@ fn vectors() -> Result<()> {
         lint_vector(&vec)?;
 
         let host = EffectHost::new(DummyHost);
-        let vm = VM { host: &host };
+        let mut vm = VM::new(&host);
         let run_res = vm.run(&vec.bytecode);
         let (delta, err_msg) = match run_res {
             Ok(d) => (d, None),
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..bfed785 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -1,10 +1,19 @@
 import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
+import type { ProofTag } from '../proof/tags.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
 
 export class VM {
-  constructor(public host: Host) {}
+  constructor(public host: Host) {
+    if (process?.env?.DEV_PROOFS === '1') this.tags = [];
+  }
+
+  tags?: ProofTag[];
+
+  private emit(tag: ProofTag) {
+    this.tags?.push(tag);
+  }
 
   private get(regs: Value[], idx: number): Value {
     if (idx < 0 || idx >= regs.length) throw new Error(`register out of bounds: r${idx}`);
@@ -41,8 +50,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          this.emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          this.emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +84,19 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          const out = await this.host.call_tf(ins.tf_id, args);
+          if (out === null) {
+            this.emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'non-null', found: 'null' });
+          }
+          regs[ins.dst] = out;
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            this.emit({ kind: 'Refutation', code: 'E_ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -91,7 +115,15 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    if (Buffer.from(a).equals(Buffer.from(b))) {
+    const same = Buffer.from(a).equals(Buffer.from(b));
+    if (this.tags) {
+      const delta = same ? null : { replace: finalState };
+      const effect = { read: [], write: [], external: [] };
+      this.emit({ kind: 'Witness', delta, effect });
+      this.emit({ kind: 'Normalization', target: 'delta' });
+      this.emit({ kind: 'Normalization', target: 'effect' });
+    }
+    if (same) {
       return null;
     }
     return { replace: finalState };
diff --git a/packages/tf-lang-l0-ts/tests/dev-proofs.test.ts b/packages/tf-lang-l0-ts/tests/dev-proofs.test.ts
new file mode 100644
index 0000000..d77182b
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/dev-proofs.test.ts
@@ -0,0 +1,67 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { VM } from '../src/vm/interpreter.js';
+import { DummyHost } from '../src/host/memory.js';
+import type { Program } from '../src/model/bytecode.js';
+
+afterEach(() => {
+  delete process.env.DEV_PROOFS;
+});
+
+describe('DEV_PROOFS emission', () => {
+  it('emits witness and transport tags', async () => {
+    process.env.DEV_PROOFS = '1';
+    const prog: Program = {
+      version: '0.1',
+      regs: 3,
+      instrs: [
+        { op: 'CONST', dst: 0, value: [] },
+        { op: 'CONST', dst: 1, value: { append: 1 } },
+        { op: 'DIFF_APPLY', dst: 0, state: 0, delta: 1 },
+        { op: 'LENS_PROJ', dst: 2, state: 0, region: 'r' },
+        { op: 'HALT' },
+      ],
+    };
+    const vm = new VM(DummyHost);
+    await vm.run(prog);
+    expect(vm.tags?.some(t => t.kind === 'Witness')).toBe(true);
+    expect(vm.tags?.filter(t => t.kind === 'Normalization').length).toBeGreaterThan(0);
+    expect(vm.tags?.some(t => t.kind === 'Transport' && t.op === 'LENS_PROJ')).toBe(true);
+  });
+
+  it('emits refutation on ASSERT failure', async () => {
+    process.env.DEV_PROOFS = '1';
+    const prog: Program = {
+      version: '0.1',
+      regs: 1,
+      instrs: [
+        { op: 'CONST', dst: 0, value: 0 },
+        { op: 'ASSERT', pred: 0, msg: 'no' },
+      ],
+    };
+    const vm = new VM(DummyHost);
+    await expect(vm.run(prog)).rejects.toThrow();
+    expect(vm.tags?.some(t => t.kind === 'Refutation')).toBe(true);
+  });
+
+  it('emits conservativity on missing call', async () => {
+    process.env.DEV_PROOFS = '1';
+    const prog: Program = {
+      version: '0.1',
+      regs: 1,
+      instrs: [
+        { op: 'CALL', dst: 0, tf_id: 'tf://missing@0.1', args: [] },
+        { op: 'HALT' },
+      ],
+    };
+    const vm = new VM(DummyHost);
+    await vm.run(prog);
+    expect(vm.tags?.some(t => t.kind === 'Conservativity')).toBe(true);
+  });
+
+  it('is silent when DEV_PROOFS unset', async () => {
+    const prog: Program = { version: '0.1', regs: 1, instrs: [ { op: 'HALT' } ] };
+    const vm = new VM(DummyHost);
+    await vm.run(prog);
+    expect(vm.tags).toBeUndefined();
+  });
+});
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T03:04:36Z","isDraft":false,"mergeStateStatus":"UNSTABLE","number":25,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_mFBt","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request introduces a new feature that allows for the conditional emission of detailed proof tags within the TypeScript and Rust Virtual Machines. This capability is specifically designed for development and debugging purposes, enabling deeper insight into VM execution and state transformations when the DEV_PROOFS environment variable is enabled. The changes ensure that this diagnostic information is only generated when explicitly requested, preventing any performance impact or data leakage in production environments.\n\n### Highlights\n\n* **Conditional Proof Tag Emission**: Implemented a mechanism to emit various proof tags (witness, normalization, transport, refutation, conservativity) in both TypeScript and Rust Virtual Machines, gated by the DEV_PROOFS environment variable.\n* **Comprehensive Test Coverage**: Added new unit tests in both runtimes to verify the correct emission and absence of proof tags based on the DEV_PROOFS flag.\n* **Documentation Updates**: Documented the new DEV_PROOFS rule in the project's lessons and journal entries, ensuring clarity on its intended use.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T03:04:57Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"b2322a8cfe46d008f22cbf18b2718415591d71b8"}},{"id":"PRR_kwDOPs5-l86_mFZ1","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request effectively introduces the emission of development-time proof tags in both the Rust and TypeScript VMs, gated by the `DEV_PROOFS` environment variable. The changes are well-implemented across both languages, and the inclusion of new unit tests to cover both the presence and absence of these tags is excellent. The documentation updates are also clear and helpful.\n\nMy review focuses on improving the robustness and clarity of the new Rust tests. Specifically, I've suggested using a safer pattern for managing environment variables to prevent test flakiness, splitting a test case for better atomicity, and making a test mock more specific to avoid potential future issues. Overall, this is a solid contribution.","submittedAt":"2025-09-12T03:06:25Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"b2322a8cfe46d008f22cbf18b2718415591d71b8"}},{"id":"PRR_kwDOPs5-l86_mFo_","author":{"login":"chatgpt-codex-connector"},"authorAssociation":"NONE","body":"Codex Review: Here are some suggestions.\n\nReply with `@codex fix comments` to fix any unresolved comments.\n\n<details> <summary>About Codex in GitHub</summary>\n\n[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment \"@codex review\". If Codex has suggestions, it will comment; otherwise it will react with 👍.\n\nCodex can also answer questions or update the PR. Try commenting \"@codex fix this CI failure\" or \"@codex address that feedback\".\n</details>","submittedAt":"2025-09-12T03:07:03Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"b2322a8cfe46d008f22cbf18b2718415591d71b8"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T03:05:15Z","conclusion":"FAILURE","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663277021/job/50200482405","name":"conformance","startedAt":"2025-09-12T03:04:44Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:04:57Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663277032/job/50200482447","name":"TypeScript build & test","startedAt":"2025-09-12T03:04:43Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:04:51Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200482441","name":"changed","startedAt":"2025-09-12T03:04:44Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:05:15Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663277032/job/50200482429","name":"Rust build & test","startedAt":"2025-09-12T03:04:43Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:05:07Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200493855","name":"ts","startedAt":"2025-09-12T03:04:54Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:05:29Z","conclusion":"FAILURE","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200493863","name":"rust","startedAt":"2025-09-12T03:04:54Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:04:51Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663277017/job/50200493999","name":"golden","startedAt":"2025-09-12T03:04:52Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"feat: emit dev proof tags","updatedAt":"2025-09-12T03:07:03Z","url":"https://github.com/LexLattice/tf-lang/pull/25"}
```


---

# PR #26 — B2: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/26
- Author: @andreidita22
- Created: 2025-09-12T03:05:37Z
- Updated: 2025-09-12T03:07:44Z

## Checks
```
conformance	fail	31s	https://github.com/LexLattice/tf-lang/actions/runs/17663292731/job/50200529071	
rust	fail	36s	https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200534861	
ts	pass	10s	https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200534862	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200534909	
Rust build & test	pass	46s	https://github.com/LexLattice/tf-lang/actions/runs/17663292726/job/50200529100	
TypeScript build & test	pass	14s	https://github.com/LexLattice/tf-lang/actions/runs/17663292726/job/50200529097	
changed	pass	4s	https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200529068	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request enhances the debugging capabilities of the system by introducing a mechanism to conditionally emit detailed proof tags within the TypeScript and Rust virtual machines. These tags provide granular insights into the VM's execution flow, state transformations, and assertion outcomes, but are only generated when a specific development environment variable is set, ensuring no performance impact in production.

### Highlights

* **Conditional Proof Tag Emission**: Introduced a mechanism to conditionally emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust Virtual Machines, active only when the `DEV_PROOFS=1` environment variable is set.
* **Dedicated Logging Utilities**: Implemented new `emit` and `take` functions for managing proof tag logs in both Rust (`packages/tf-lang-l0-rs/src/proof.rs`) and TypeScript (`packages/tf-lang-l0-ts/src/proof/dev.ts`), ensuring these logs are only populated in development mode.
* **VM Instrumentation**: Instrumented the core VM interpreters in both Rust and TypeScript to emit specific proof tags during operations such as `ASSERT` failures (Refutation), `LENS_PROJ`/`LENS_MERGE` (Transport), `CALL` results (Conservativity), and at the end of execution (Witness, Normalization).
* **Comprehensive Testing**: Added new unit tests in both Rust (`packages/tf-lang-l0-rs/tests/proof_emit.rs`) and TypeScript (`packages/tf-lang-l0-ts/tests/proof-emit.test.ts`) to verify the correct presence and absence of proof tag emissions based on the `DEV_PROOFS` environment variable, including specific tests for refutation tags.
* **Documentation Updates**: Updated internal documentation files, including `.codex/JOURNAL.md` with a new entry for 'Minimal proof emissions' and `.codex/LESSONS.md` with a new rule stating that 'Proof tags emitted only when DEV_PROOFS=1'.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces proof tag emission in development mode for both Rust and TypeScript VMs, controlled by the `DEV_PROOFS` environment variable. The changes include new logging utilities, instrumentation of the VMs to emit various proof tags, and corresponding tests. My review focuses on improving performance by caching environment variable checks, enhancing code clarity and efficiency in the Rust VM, and addressing potential test flakiness in both test suites due to manipulation of shared environment state. I've also suggested a consistency improvement in the TypeScript code.
--
```

## Files Changed (JSON)
```json
[{"sha":"8fbf2d009e88cb6280690c72cd56cd31d5e0ef43","filename":".codex/JOURNAL.md","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -500,3 +500,18 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+## [B2] Minimal proof emissions\n+- Start: 2025-09-11 23:00 UTC\n+- End:   2025-09-11 23:15 UTC\n+- Changes:\n+  - Added DEV_PROOFS-gated proof logging utilities in TS and Rust\n+  - Instrumented VMs to emit Witness, Normalization, Transport, Refutation, and Conservativity tags\n+  - Added unit tests verifying tags present only in dev mode\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - pnpm -C packages/tf-lang-l0-ts vectors\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests and vectors passed\n+- Next suggested step:\n+  - C1"},{"sha":"ce202a09f9f2aa5148f2d442284b228c2aa2253d","filename":".codex/LESSONS.md","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -18,3 +18,4 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-11] Rule: \"Proof tags emitted only when DEV_PROOFS=1.\" Guardrail: proof:dev_toggle"},{"sha":"8640af82b651079a8c196da55c6e9e92e87f3ddd","filename":".codex/polish/B2.md","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -0,0 +1 @@\n+- [TS] tests/proof-emit.test.ts: drop redundant `process.env.DEV_PROOFS='1'` before second run and clear the log explicitly for readability."},{"sha":"bbddc9f482af241a728849cc4fa19204422c6688","filename":".codex/self-plans/B2.md","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -0,0 +1,26 @@\n+# Plan for Task B2\n+\n+## Steps\n+1. Add proof logging modules in TS and Rust that capture tags only when `DEV_PROOFS=1`.\n+2. Instrument TS VM to emit Transport tags on lens ops, Conservativity on null CALL results, Refutation on failed ASSERT, and Witness/Normalization after run.\n+3. Mirror these emissions in the Rust VM.\n+4. Expose log/take helpers for tests.\n+5. Write unit tests in TS and Rust verifying tags appear when `DEV_PROOFS=1` and remain absent otherwise.\n+6. Run `pnpm -C packages/tf-lang-l0-ts test`, `pnpm -C packages/tf-lang-l0-ts vectors`, and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`.\n+7. Append journal entry and update lessons if a new rule emerges.\n+\n+## Test Changes\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `pnpm -C packages/tf-lang-l0-ts vectors`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks & Rollback\n+- Divergent behavior between TS and Rust emissions.\n+- Forgetting to clear logs may cause flaky tests.\n+- Emissions accidentally affecting normal runtime.\n+- Rollback by removing proof logging modules and reverting VM changes.\n+\n+## Definition of Done\n+- Tags emitted only when `DEV_PROOFS=1` and cover Witness, Normalization, Transport, Refutation, and Conservativity cases.\n+- All tests and vectors pass.\n+- Journal updated; new lesson added if warranted."},{"sha":"aeb7a9c379462d277d528ef740b9b9e42037f0ad","filename":"packages/tf-lang-l0-rs/src/proof.rs","status":"modified","additions":18,"deletions":0,"changes":18,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -1,5 +1,7 @@\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n+use std::sync::{Mutex, OnceLock};\n+use std::env;\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct Replace {\n@@ -42,3 +44,19 @@ pub enum ProofTag {\n     Refutation { code: String, msg: Option<String> },\n     Conservativity { callee: String, expected: String, found: String },\n }\n+\n+static LOG: OnceLock<Mutex<Vec<ProofTag>>> = OnceLock::new();\n+\n+fn log() -> &'static Mutex<Vec<ProofTag>> {\n+    LOG.get_or_init(|| Mutex::new(Vec::new()))\n+}\n+\n+pub fn emit(tag: ProofTag) {\n+    if env::var(\"DEV_PROOFS\").ok().as_deref() == Some(\"1\") {\n+        log().lock().unwrap().push(tag);\n+    }\n+}\n+\n+pub fn take() -> Vec<ProofTag> {\n+    log().lock().unwrap().drain(..).collect()\n+}"},{"sha":"3a6beb9898bcf5cabd7d8f6a4108bc60f9448810","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":25,"deletions":2,"changes":27,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n use crate::vm::opcode::Host;\n+use crate::proof::{emit, ProofTag, TransportOp, NormalizationTarget, Effect, Replace};\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n@@ -37,6 +38,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        emit(ProofTag::Refutation { code: \"E_ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -98,6 +100,7 @@ impl<'h> VM<'h> {\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n                     regs[*dst as usize] = sub;\n+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });\n                 }\n                 Instr::LensMerge {\n                     dst,\n@@ -109,6 +112,7 @@ impl<'h> VM<'h> {\n                         self.host\n                             .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n                     regs[*dst as usize] = merged;\n+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });\n                 }\n                 Instr::PlanSim {\n                     dst_delta,\n@@ -173,7 +177,18 @@ impl<'h> VM<'h> {\n                     for r in args {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n-                    let out = self.host.call_tf(tf_id, &a)?;\n+                    let out = match self.host.call_tf(tf_id, &a) {\n+                        Ok(v) => {\n+                            if v.is_null() {\n+                                emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: \"value\".into(), found: \"null\".into() });\n+                            }\n+                            v\n+                        }\n+                        Err(e) => {\n+                            emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: \"ok\".into(), found: e.to_string() });\n+                            return Err(e);\n+                        }\n+                    };\n                     regs[*dst as usize] = out;\n                 }\n             }\n@@ -187,8 +202,16 @@ impl<'h> VM<'h> {\n         let out = if final_state == initial_state {\n             serde_json::Value::Null\n         } else {\n-            serde_json::json!({ \"replace\": final_state })\n+            serde_json::json!({ \"replace\": final_state.clone() })\n         };\n+        let delta_tag = if out.is_null() {\n+            None\n+        } else {\n+            Some(Replace { replace: final_state.clone() })\n+        };\n+        emit(ProofTag::Witness { delta: delta_tag, effect: Effect::default() });\n+        emit(ProofTag::Normalization { target: NormalizationTarget::Delta });\n+        emit(ProofTag::Normalization { target: NormalizationTarget::Effect });\n \n         Ok(out)\n     }"},{"sha":"93f81bb28b9e18944f41c61576941ef0e2c9db30","filename":"packages/tf-lang-l0-rs/tests/proof_emit.rs","status":"added","additions":98,"deletions":0,"changes":98,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_emit.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_emit.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_emit.rs?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -0,0 +1,98 @@\n+use serde_json::{json, Value};\n+use tflang_l0::model::bytecode::{Instr, Program};\n+use tflang_l0::model::{JournalEntry, World};\n+use tflang_l0::proof::{self, ProofTag};\n+use tflang_l0::vm::{opcode::Host, VM};\n+\n+struct DummyHost;\n+\n+impl Host for DummyHost {\n+    fn lens_project(&self, state: &Value, region: &str) -> anyhow::Result<Value> {\n+        Ok(json!({ \"region\": region, \"state\": state.clone() }))\n+    }\n+    fn lens_merge(&self, state: &Value, _region: &str, sub: &Value) -> anyhow::Result<Value> {\n+        Ok(json!({ \"orig\": state.clone(), \"sub\": sub.clone() }))\n+    }\n+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, snapshot: &Value) -> anyhow::Result<String> {\n+        Ok(format!(\"id:{snapshot}\"))\n+    }\n+    fn diff_apply(&self, state: &Value, _delta: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> {\n+        Ok(json!({\"invert\": delta.clone()}))\n+    }\n+    fn journal_record(\n+        &self,\n+        _plan: &Value,\n+        delta: &Value,\n+        s0: &str,\n+        s1: &str,\n+        _meta: &Value,\n+    ) -> anyhow::Result<JournalEntry> {\n+        Ok(JournalEntry(json!({\"delta\": delta.clone(), \"from\": s0, \"to\": s1})))\n+    }\n+    fn journal_rewind(&self, world: &World, _entry: &JournalEntry) -> anyhow::Result<World> {\n+        Ok(World(world.0.clone()))\n+    }\n+    fn call_tf(&self, _id: &str, _args: &[Value]) -> anyhow::Result<Value> {\n+        Ok(Value::Null)\n+    }\n+}\n+\n+#[test]\n+fn tags_emitted_with_env() {\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let prog = Program {\n+        version: \"0.1\".into(),\n+        regs: 3,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!({\"a\":1}) },\n+            Instr::LensProj { dst: 1, state: 0, region: \"r\".into() },\n+            Instr::Call { dst: 2, tf_id: \"tf://missing@0.1\".into(), args: vec![] },\n+            Instr::Halt,\n+        ],\n+    };\n+    let vm = VM { host: &DummyHost };\n+    vm.run(&prog).unwrap();\n+    let tags = proof::take();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Normalization { .. })));\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { .. })));\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Conservativity { .. })));\n+}\n+\n+#[test]\n+fn no_tags_without_env() {\n+    std::env::remove_var(\"DEV_PROOFS\");\n+    let prog = Program {\n+        version: \"0.1\".into(),\n+        regs: 3,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!({\"a\":1}) },\n+            Instr::LensProj { dst: 1, state: 0, region: \"r\".into() },\n+            Instr::Call { dst: 2, tf_id: \"tf://missing@0.1\".into(), args: vec![] },\n+            Instr::Halt,\n+        ],\n+    };\n+    let vm = VM { host: &DummyHost };\n+    vm.run(&prog).unwrap();\n+    let tags = proof::take();\n+    assert!(tags.is_empty());\n+}\n+\n+#[test]\n+fn refutation_on_assert() {\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let prog = Program {\n+        version: \"0.1\".into(),\n+        regs: 1,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!(false) },\n+            Instr::Assert { pred: 0, msg: \"nope\".into() },\n+        ],\n+    };\n+    let vm = VM { host: &DummyHost };\n+    assert!(vm.run(&prog).is_err());\n+    let tags = proof::take();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Refutation { .. })));\n+}"},{"sha":"61518e4c82e2b37ed7c0316578f159a2d3f76be2","filename":"packages/tf-lang-l0-ts/src/proof/dev.ts","status":"added","additions":13,"deletions":0,"changes":13,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Fdev.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Fdev.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Fdev.ts?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -0,0 +1,13 @@\n+import type { ProofTag } from './tags.js';\n+\n+export const log: ProofTag[] = [];\n+\n+export function emit(tag: ProofTag): void {\n+  if (process?.env?.DEV_PROOFS === '1') {\n+    log.push(JSON.parse(JSON.stringify(tag)));\n+  }\n+}\n+\n+export function take(): ProofTag[] {\n+  return log.splice(0, log.length);\n+}"},{"sha":"40f84d8152e8ae020ab561ba2390778949468dde","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n+import { emit } from '../proof/dev.js';\n \n export class VM {\n   constructor(public host: Host) {}\n@@ -41,8 +42,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +76,19 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          const out = await this.host.call_tf(ins.tf_id, args);\n+          if (out === null) {\n+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'value', found: 'null' });\n+          }\n+          regs[ins.dst] = out;\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            emit({ kind: 'Refutation', code: 'E_ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -91,10 +107,11 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    if (Buffer.from(a).equals(Buffer.from(b))) {\n-      return null;\n-    }\n-    return { replace: finalState };\n+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };\n+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+    emit({ kind: 'Normalization', target: 'delta' });\n+    emit({ kind: 'Normalization', target: 'effect' });\n+    return delta;\n   }\n }\n "},{"sha":"97c3464a4e52802e95fa26ca826e474cb4f74cf3","filename":"packages/tf-lang-l0-ts/tests/proof-emit.test.ts","status":"added","additions":58,"deletions":0,"changes":58,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-emit.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2667ab3209484e8a692a5a657825aec2b38be7e5/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-emit.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-emit.test.ts?ref=2667ab3209484e8a692a5a657825aec2b38be7e5","patch":"@@ -0,0 +1,58 @@\n+import { describe, test, expect, beforeEach } from 'vitest';\n+import { vm } from '../src/index.js';\n+import { DummyHost } from '../src/host/memory.js';\n+import { take } from '../src/proof/dev.js';\n+\n+const { VM } = vm;\n+\n+describe('proof tag emission', () => {\n+  beforeEach(() => { take(); });\n+\n+  test('no tags without DEV_PROOFS', async () => {\n+    delete process.env.DEV_PROOFS;\n+    const v = new VM(DummyHost);\n+    const prog = {\n+      regs: 3,\n+      instrs: [\n+        { op: 'CONST', dst: 0, value: { a: 1 } },\n+        { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },\n+        { op: 'CALL', dst: 2, tf_id: 'tf://missing@0.1', args: [] },\n+        { op: 'HALT' },\n+      ],\n+    } as any;\n+    await v.run(prog);\n+    expect(take()).toHaveLength(0);\n+  });\n+\n+  test('tags emitted when DEV_PROOFS=1', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const v = new VM(DummyHost);\n+    const prog = {\n+      regs: 3,\n+      instrs: [\n+        { op: 'CONST', dst: 0, value: { a: 1 } },\n+        { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },\n+        { op: 'CALL', dst: 2, tf_id: 'tf://missing@0.1', args: [] },\n+        { op: 'HALT' },\n+      ],\n+    } as any;\n+    await v.run(prog);\n+    const tags = take();\n+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);\n+    expect(tags.filter(t => t.kind === 'Normalization').length).toBeGreaterThan(0);\n+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);\n+    expect(tags.some(t => t.kind === 'Conservativity')).toBe(true);\n+\n+    take();\n+    const prog2 = {\n+      regs: 1,\n+      instrs: [\n+        { op: 'CONST', dst: 0, value: false },\n+        { op: 'ASSERT', pred: 0, msg: 'nope' },\n+      ],\n+    } as any;\n+    await expect(v.run(prog2)).rejects.toThrow(/ASSERT failed/);\n+    const tags2 = take();\n+    expect(tags2.some(t => t.kind === 'Refutation')).toBe(true);\n+  });\n+});"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..8fbf2d0 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,18 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+## [B2] Minimal proof emissions
+- Start: 2025-09-11 23:00 UTC
+- End:   2025-09-11 23:15 UTC
+- Changes:
+  - Added DEV_PROOFS-gated proof logging utilities in TS and Rust
+  - Instrumented VMs to emit Witness, Normalization, Transport, Refutation, and Conservativity tags
+  - Added unit tests verifying tags present only in dev mode
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - pnpm -C packages/tf-lang-l0-ts vectors
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests and vectors passed
+- Next suggested step:
+  - C1
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..ce202a0 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,4 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-11] Rule: "Proof tags emitted only when DEV_PROOFS=1." Guardrail: proof:dev_toggle
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..8640af8
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1 @@
+- [TS] tests/proof-emit.test.ts: drop redundant `process.env.DEV_PROOFS='1'` before second run and clear the log explicitly for readability.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..bbddc9f
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,26 @@
+# Plan for Task B2
+
+## Steps
+1. Add proof logging modules in TS and Rust that capture tags only when `DEV_PROOFS=1`.
+2. Instrument TS VM to emit Transport tags on lens ops, Conservativity on null CALL results, Refutation on failed ASSERT, and Witness/Normalization after run.
+3. Mirror these emissions in the Rust VM.
+4. Expose log/take helpers for tests.
+5. Write unit tests in TS and Rust verifying tags appear when `DEV_PROOFS=1` and remain absent otherwise.
+6. Run `pnpm -C packages/tf-lang-l0-ts test`, `pnpm -C packages/tf-lang-l0-ts vectors`, and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`.
+7. Append journal entry and update lessons if a new rule emerges.
+
+## Test Changes
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `pnpm -C packages/tf-lang-l0-ts vectors`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks & Rollback
+- Divergent behavior between TS and Rust emissions.
+- Forgetting to clear logs may cause flaky tests.
+- Emissions accidentally affecting normal runtime.
+- Rollback by removing proof logging modules and reverting VM changes.
+
+## Definition of Done
+- Tags emitted only when `DEV_PROOFS=1` and cover Witness, Normalization, Transport, Refutation, and Conservativity cases.
+- All tests and vectors pass.
+- Journal updated; new lesson added if warranted.
diff --git a/packages/tf-lang-l0-rs/src/proof.rs b/packages/tf-lang-l0-rs/src/proof.rs
index 4a4ea5e..aeb7a9c 100644
--- a/packages/tf-lang-l0-rs/src/proof.rs
+++ b/packages/tf-lang-l0-rs/src/proof.rs
@@ -1,5 +1,7 @@
 use serde::{Deserialize, Serialize};
 use serde_json::Value;
+use std::sync::{Mutex, OnceLock};
+use std::env;
 
 #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
 pub struct Replace {
@@ -42,3 +44,19 @@ pub enum ProofTag {
     Refutation { code: String, msg: Option<String> },
     Conservativity { callee: String, expected: String, found: String },
 }
+
+static LOG: OnceLock<Mutex<Vec<ProofTag>>> = OnceLock::new();
+
+fn log() -> &'static Mutex<Vec<ProofTag>> {
+    LOG.get_or_init(|| Mutex::new(Vec::new()))
+}
+
+pub fn emit(tag: ProofTag) {
+    if env::var("DEV_PROOFS").ok().as_deref() == Some("1") {
+        log().lock().unwrap().push(tag);
+    }
+}
+
+pub fn take() -> Vec<ProofTag> {
+    log().lock().unwrap().drain(..).collect()
+}
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..3a6beb9 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
 use crate::vm::opcode::Host;
+use crate::proof::{emit, ProofTag, TransportOp, NormalizationTarget, Effect, Replace};
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
@@ -37,6 +38,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        emit(ProofTag::Refutation { code: "E_ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -98,6 +100,7 @@ impl<'h> VM<'h> {
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
                     regs[*dst as usize] = sub;
+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });
                 }
                 Instr::LensMerge {
                     dst,
@@ -109,6 +112,7 @@ impl<'h> VM<'h> {
                         self.host
                             .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
                     regs[*dst as usize] = merged;
+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });
                 }
                 Instr::PlanSim {
                     dst_delta,
@@ -173,7 +177,18 @@ impl<'h> VM<'h> {
                     for r in args {
                         a.push(get(*r, &regs)?.clone());
                     }
-                    let out = self.host.call_tf(tf_id, &a)?;
+                    let out = match self.host.call_tf(tf_id, &a) {
+                        Ok(v) => {
+                            if v.is_null() {
+                                emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: "value".into(), found: "null".into() });
+                            }
+                            v
+                        }
+                        Err(e) => {
+                            emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: "ok".into(), found: e.to_string() });
+                            return Err(e);
+                        }
+                    };
                     regs[*dst as usize] = out;
                 }
             }
@@ -187,8 +202,16 @@ impl<'h> VM<'h> {
         let out = if final_state == initial_state {
             serde_json::Value::Null
         } else {
-            serde_json::json!({ "replace": final_state })
+            serde_json::json!({ "replace": final_state.clone() })
         };
+        let delta_tag = if out.is_null() {
+            None
+        } else {
+            Some(Replace { replace: final_state.clone() })
+        };
+        emit(ProofTag::Witness { delta: delta_tag, effect: Effect::default() });
+        emit(ProofTag::Normalization { target: NormalizationTarget::Delta });
+        emit(ProofTag::Normalization { target: NormalizationTarget::Effect });
 
         Ok(out)
     }
diff --git a/packages/tf-lang-l0-rs/tests/proof_emit.rs b/packages/tf-lang-l0-rs/tests/proof_emit.rs
new file mode 100644
index 0000000..93f81bb
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/proof_emit.rs
@@ -0,0 +1,98 @@
+use serde_json::{json, Value};
+use tflang_l0::model::bytecode::{Instr, Program};
+use tflang_l0::model::{JournalEntry, World};
+use tflang_l0::proof::{self, ProofTag};
+use tflang_l0::vm::{opcode::Host, VM};
+
+struct DummyHost;
+
+impl Host for DummyHost {
+    fn lens_project(&self, state: &Value, region: &str) -> anyhow::Result<Value> {
+        Ok(json!({ "region": region, "state": state.clone() }))
+    }
+    fn lens_merge(&self, state: &Value, _region: &str, sub: &Value) -> anyhow::Result<Value> {
+        Ok(json!({ "orig": state.clone(), "sub": sub.clone() }))
+    }
+    fn snapshot_make(&self, state: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, snapshot: &Value) -> anyhow::Result<String> {
+        Ok(format!("id:{snapshot}"))
+    }
+    fn diff_apply(&self, state: &Value, _delta: &Value) -> anyhow::Result<Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &Value) -> anyhow::Result<Value> {
+        Ok(json!({"invert": delta.clone()}))
+    }
+    fn journal_record(
+        &self,
+        _plan: &Value,
+        delta: &Value,
+        s0: &str,
+        s1: &str,
+        _meta: &Value,
+    ) -> anyhow::Result<JournalEntry> {
+        Ok(JournalEntry(json!({"delta": delta.clone(), "from": s0, "to": s1})))
+    }
+    fn journal_rewind(&self, world: &World, _entry: &JournalEntry) -> anyhow::Result<World> {
+        Ok(World(world.0.clone()))
+    }
+    fn call_tf(&self, _id: &str, _args: &[Value]) -> anyhow::Result<Value> {
+        Ok(Value::Null)
+    }
+}
+
+#[test]
+fn tags_emitted_with_env() {
+    std::env::set_var("DEV_PROOFS", "1");
+    let prog = Program {
+        version: "0.1".into(),
+        regs: 3,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!({"a":1}) },
+            Instr::LensProj { dst: 1, state: 0, region: "r".into() },
+            Instr::Call { dst: 2, tf_id: "tf://missing@0.1".into(), args: vec![] },
+            Instr::Halt,
+        ],
+    };
+    let vm = VM { host: &DummyHost };
+    vm.run(&prog).unwrap();
+    let tags = proof::take();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Normalization { .. })));
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { .. })));
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Conservativity { .. })));
+}
+
+#[test]
+fn no_tags_without_env() {
+    std::env::remove_var("DEV_PROOFS");
+    let prog = Program {
+        version: "0.1".into(),
+        regs: 3,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!({"a":1}) },
+            Instr::LensProj { dst: 1, state: 0, region: "r".into() },
+            Instr::Call { dst: 2, tf_id: "tf://missing@0.1".into(), args: vec![] },
+            Instr::Halt,
+        ],
+    };
+    let vm = VM { host: &DummyHost };
+    vm.run(&prog).unwrap();
+    let tags = proof::take();
+    assert!(tags.is_empty());
+}
+
+#[test]
+fn refutation_on_assert() {
+    std::env::set_var("DEV_PROOFS", "1");
+    let prog = Program {
+        version: "0.1".into(),
+        regs: 1,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!(false) },
+            Instr::Assert { pred: 0, msg: "nope".into() },
+        ],
+    };
+    let vm = VM { host: &DummyHost };
+    assert!(vm.run(&prog).is_err());
+    let tags = proof::take();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Refutation { .. })));
+}
diff --git a/packages/tf-lang-l0-ts/src/proof/dev.ts b/packages/tf-lang-l0-ts/src/proof/dev.ts
new file mode 100644
index 0000000..61518e4
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/dev.ts
@@ -0,0 +1,13 @@
+import type { ProofTag } from './tags.js';
+
+export const log: ProofTag[] = [];
+
+export function emit(tag: ProofTag): void {
+  if (process?.env?.DEV_PROOFS === '1') {
+    log.push(JSON.parse(JSON.stringify(tag)));
+  }
+}
+
+export function take(): ProofTag[] {
+  return log.splice(0, log.length);
+}
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..40f84d8 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
+import { emit } from '../proof/dev.js';
 
 export class VM {
   constructor(public host: Host) {}
@@ -41,8 +42,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +76,19 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          const out = await this.host.call_tf(ins.tf_id, args);
+          if (out === null) {
+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'value', found: 'null' });
+          }
+          regs[ins.dst] = out;
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            emit({ kind: 'Refutation', code: 'E_ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -91,10 +107,11 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    if (Buffer.from(a).equals(Buffer.from(b))) {
-      return null;
-    }
-    return { replace: finalState };
+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };
+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+    emit({ kind: 'Normalization', target: 'delta' });
+    emit({ kind: 'Normalization', target: 'effect' });
+    return delta;
   }
 }
 
diff --git a/packages/tf-lang-l0-ts/tests/proof-emit.test.ts b/packages/tf-lang-l0-ts/tests/proof-emit.test.ts
new file mode 100644
index 0000000..97c3464
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proof-emit.test.ts
@@ -0,0 +1,58 @@
+import { describe, test, expect, beforeEach } from 'vitest';
+import { vm } from '../src/index.js';
+import { DummyHost } from '../src/host/memory.js';
+import { take } from '../src/proof/dev.js';
+
+const { VM } = vm;
+
+describe('proof tag emission', () => {
+  beforeEach(() => { take(); });
+
+  test('no tags without DEV_PROOFS', async () => {
+    delete process.env.DEV_PROOFS;
+    const v = new VM(DummyHost);
+    const prog = {
+      regs: 3,
+      instrs: [
+        { op: 'CONST', dst: 0, value: { a: 1 } },
+        { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },
+        { op: 'CALL', dst: 2, tf_id: 'tf://missing@0.1', args: [] },
+        { op: 'HALT' },
+      ],
+    } as any;
+    await v.run(prog);
+    expect(take()).toHaveLength(0);
+  });
+
+  test('tags emitted when DEV_PROOFS=1', async () => {
+    process.env.DEV_PROOFS = '1';
+    const v = new VM(DummyHost);
+    const prog = {
+      regs: 3,
+      instrs: [
+        { op: 'CONST', dst: 0, value: { a: 1 } },
+        { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },
+        { op: 'CALL', dst: 2, tf_id: 'tf://missing@0.1', args: [] },
+        { op: 'HALT' },
+      ],
+    } as any;
+    await v.run(prog);
+    const tags = take();
+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);
+    expect(tags.filter(t => t.kind === 'Normalization').length).toBeGreaterThan(0);
+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);
+    expect(tags.some(t => t.kind === 'Conservativity')).toBe(true);
+
+    take();
+    const prog2 = {
+      regs: 1,
+      instrs: [
+        { op: 'CONST', dst: 0, value: false },
+        { op: 'ASSERT', pred: 0, msg: 'nope' },
+      ],
+    } as any;
+    await expect(v.run(prog2)).rejects.toThrow(/ASSERT failed/);
+    const tags2 = take();
+    expect(tags2.some(t => t.kind === 'Refutation')).toBe(true);
+  });
+});
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T03:05:37Z","isDraft":false,"mergeStateStatus":"UNSTABLE","number":26,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_mFSI","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request enhances the debugging capabilities of the system by introducing a mechanism to conditionally emit detailed proof tags within the TypeScript and Rust virtual machines. These tags provide granular insights into the VM's execution flow, state transformations, and assertion outcomes, but are only generated when a specific development environment variable is set, ensuring no performance impact in production.\n\n### Highlights\n\n* **Conditional Proof Tag Emission**: Introduced a mechanism to conditionally emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust Virtual Machines, active only when the `DEV_PROOFS=1` environment variable is set.\n* **Dedicated Logging Utilities**: Implemented new `emit` and `take` functions for managing proof tag logs in both Rust (`packages/tf-lang-l0-rs/src/proof.rs`) and TypeScript (`packages/tf-lang-l0-ts/src/proof/dev.ts`), ensuring these logs are only populated in development mode.\n* **VM Instrumentation**: Instrumented the core VM interpreters in both Rust and TypeScript to emit specific proof tags during operations such as `ASSERT` failures (Refutation), `LENS_PROJ`/`LENS_MERGE` (Transport), `CALL` results (Conservativity), and at the end of execution (Witness, Normalization).\n* **Comprehensive Testing**: Added new unit tests in both Rust (`packages/tf-lang-l0-rs/tests/proof_emit.rs`) and TypeScript (`packages/tf-lang-l0-ts/tests/proof-emit.test.ts`) to verify the correct presence and absence of proof tag emissions based on the `DEV_PROOFS` environment variable, including specific tests for refutation tags.\n* **Documentation Updates**: Updated internal documentation files, including `.codex/JOURNAL.md` with a new entry for 'Minimal proof emissions' and `.codex/LESSONS.md` with a new rule stating that 'Proof tags emitted only when DEV_PROOFS=1'.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T03:05:57Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2667ab3209484e8a692a5a657825aec2b38be7e5"}},{"id":"PRR_kwDOPs5-l86_mGBO","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces proof tag emission in development mode for both Rust and TypeScript VMs, controlled by the `DEV_PROOFS` environment variable. The changes include new logging utilities, instrumentation of the VMs to emit various proof tags, and corresponding tests. My review focuses on improving performance by caching environment variable checks, enhancing code clarity and efficiency in the Rust VM, and addressing potential test flakiness in both test suites due to manipulation of shared environment state. I've also suggested a consistency improvement in the TypeScript code.","submittedAt":"2025-09-12T03:07:44Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2667ab3209484e8a692a5a657825aec2b38be7e5"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T03:06:15Z","conclusion":"FAILURE","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663292731/job/50200529071","name":"conformance","startedAt":"2025-09-12T03:05:44Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:05:56Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663292726/job/50200529097","name":"TypeScript build & test","startedAt":"2025-09-12T03:05:42Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:05:48Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200529068","name":"changed","startedAt":"2025-09-12T03:05:44Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:06:28Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663292726/job/50200529100","name":"Rust build & test","startedAt":"2025-09-12T03:05:42Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:06:01Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200534862","name":"ts","startedAt":"2025-09-12T03:05:51Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:06:26Z","conclusion":"FAILURE","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200534861","name":"rust","startedAt":"2025-09-12T03:05:50Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:05:48Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663292732/job/50200534909","name":"golden","startedAt":"2025-09-12T03:05:48Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"B2: emit proof tags in dev mode","updatedAt":"2025-09-12T03:07:44Z","url":"https://github.com/LexLattice/tf-lang/pull/26"}
```
