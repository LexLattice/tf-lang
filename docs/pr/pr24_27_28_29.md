# PR Bundle for LexLattice/tf-lang
- Generated: 2025-09-12 12:10:20 UTC
- PRs: 24 27 28 29

## Summary

- **#24** — B2: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/24)) — by @andreidita22 — checks: none
- **#27** — B2: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/27)) — by @andreidita22 — checks: none
- **#28** — B2: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/28)) — by @andreidita22 — checks: none
- **#29** — B2: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/29)) — by @andreidita22 — checks: none


---

# PR #24 — B2: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/24
- Author: @andreidita22
- Created: 2025-09-12T03:03:27Z
- Updated: 2025-09-12T03:05:28Z

## Checks
```
rust	pass	39s	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369976	
ts	pass	8s	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369983	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200370216	
Rust build & test	pass	38s	https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351309	
TypeScript build & test	pass	20s	https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351311	
changed	pass	8s	https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200351319	
conformance	pass	25s	https://github.com/LexLattice/tf-lang/actions/runs/17663257057/job/50200351254	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request enhances the development experience by enabling detailed proof tag emission within the TypeScript and Rust virtual machines. The primary goal is to provide richer debugging and analysis capabilities for understanding VM execution flows, without impacting production performance or log verbosity, by making this feature strictly opt-in via an environment variable.

### Highlights

* **Conditional Proof Tag Emission**: Introduced a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust VMs, strictly gated by the `DEV_PROOFS=1` environment variable. This ensures that detailed proof logs are only generated in development environments.
* **VM Interpreter Integration**: Modified the core VM interpreters in both TypeScript and Rust to integrate the new proof tag emission. Tags are now emitted at key operational points, such as assertion failures, lens operations, function calls, and at the completion of execution to capture witness and normalization data.
* **New Proof Logging Modules**: Created dedicated proof logging modules in both Rust (`src/proof.rs`) and TypeScript (`src/proof/index.ts`) to manage the collection and flushing of proof tags. These modules provide `emit` and `flush` functions, centralizing the proof logging logic.
* **Testing and Documentation**: Added new test files (`proof_dev.rs` and `proof-dev.test.ts`) to explicitly verify that proof tags are emitted only when `DEV_PROOFS` is set, and are absent otherwise. Internal documentation (`.codex/JOURNAL.md`, `.codex/LESSONS.md`, `.codex/polish/B2.md`, `.codex/self-plans/B2.md`) has been updated to reflect these changes and the associated development plan.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces a valuable debugging feature by emitting proof tags in development mode for both the Rust and TypeScript VMs. The implementation is gated by a `DEV_PROOFS` environment variable, and new tests are added to verify this behavior. The changes are logical and well-structured. My review includes suggestions to improve the robustness of the tests against parallelism issues and to enhance type safety in the TypeScript implementation.
--
```

## Files Changed (JSON)
```json
[{"sha":"eb92ae62b7f86743522c27004c50e6d55b41fdbc","filename":".codex/JOURNAL.md","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -500,3 +500,15 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+## [B2] Proof tag emission\n+- Start: 2025-09-11 23:00 UTC\n+- End:   2025-09-11 23:30 UTC\n+- Changes:\n+  - added DEV_PROOFS-gated proof log in TS and Rust\n+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags\n+  - tests cover tag emission toggled by DEV_PROOFS\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests passed"},{"sha":"8f931145539f999c99b85f87c1f358500da6eb91","filename":".codex/LESSONS.md","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -18,3 +18,4 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-11] Rule: \"Proof tags emitted only when DEV_PROOFS=1.\" Guardrail: proof:dev_flag"},{"sha":"d15db569325eef38e564861509f191dee9687288","filename":".codex/polish/B2.md","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,2 @@\n+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.\n+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'."},{"sha":"c434bdd3898e1ed0286eada6f934fb1588576103","filename":".codex/self-plans/B2.md","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,25 @@\n+# Plan for B2\n+\n+## Steps\n+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.\n+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.\n+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.\n+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.\n+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.\n+6. Add Rust tests ensuring tags are emitted only in dev mode.\n+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.\n+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.\n+\n+## Tests\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks\n+- Environment variable may leak between tests; ensure logs are flushed and variables reset.\n+- Synchronizing tag structures across runtimes might be inconsistent.\n+- Adding dependency `once_cell` for Rust logging could impact build.\n+\n+## Definition of Done\n+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.\n+- Tests cover presence and absence of tags.\n+- Journal updated and repository tests pass."},{"sha":"307911ddff06feca12c7c48e4d09cc0328542053","filename":"packages/tf-lang-l0-rs/Cargo.lock","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.lock","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.lock","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.lock?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -79,6 +79,12 @@ version = \"2.7.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0\"\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.21.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n+\n [[package]]\n name = \"pretty_assertions\"\n version = \"1.4.1\"\n@@ -168,6 +174,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"blake3\",\n+ \"once_cell\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\","},{"sha":"b007053d53a73ac579af68fc9155f1a7f3582a7f","filename":"packages/tf-lang-l0-rs/Cargo.toml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.toml","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2FCargo.toml","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.toml?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -17,6 +17,7 @@ thiserror = \"1\"\n serde = { version = \"1\", features = [\"derive\"] }\n serde_json = \"1\"\n blake3 = \"1.5\"\n+once_cell = \"1\"\n \n [dev-dependencies]\n pretty_assertions = \"1\""},{"sha":"f045263d515daabd2de3a95cbf854985a7df9f26","filename":"packages/tf-lang-l0-rs/src/proof.rs","status":"modified","additions":15,"deletions":0,"changes":15,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -42,3 +42,18 @@ pub enum ProofTag {\n     Refutation { code: String, msg: Option<String> },\n     Conservativity { callee: String, expected: String, found: String },\n }\n+\n+use once_cell::sync::Lazy;\n+use std::sync::Mutex;\n+\n+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));\n+\n+pub fn emit(tag: ProofTag) {\n+    if std::env::var(\"DEV_PROOFS\").unwrap_or_default() == \"1\" {\n+        PROOF_LOG.lock().unwrap().push(tag);\n+    }\n+}\n+\n+pub fn flush() -> Vec<ProofTag> {\n+    PROOF_LOG.lock().unwrap().drain(..).collect()\n+}"},{"sha":"383cd8315c311ce7237e43987f2b54a194b3618b","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":22,"deletions":7,"changes":29,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n use crate::vm::opcode::Host;\n+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n@@ -37,6 +38,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        emit(ProofTag::Refutation { code: \"ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -97,6 +99,7 @@ impl<'h> VM<'h> {\n                 }\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });\n                     regs[*dst as usize] = sub;\n                 }\n                 Instr::LensMerge {\n@@ -105,9 +108,10 @@ impl<'h> VM<'h> {\n                     region,\n                     sub,\n                 } => {\n-                    let merged =\n-                        self.host\n-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    let merged = self\n+                        .host\n+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });\n                     regs[*dst as usize] = merged;\n                 }\n                 Instr::PlanSim {\n@@ -173,7 +177,10 @@ impl<'h> VM<'h> {\n                     for r in args {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n-                    let out = self.host.call_tf(tf_id, &a)?;\n+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {\n+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: \"ok\".into(), found: format!(\"{}\", e) });\n+                        e\n+                    })?;\n                     regs[*dst as usize] = out;\n                 }\n             }\n@@ -184,10 +191,18 @@ impl<'h> VM<'h> {\n         }\n \n         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);\n-        let out = if final_state == initial_state {\n-            serde_json::Value::Null\n+        let delta = if final_state == initial_state {\n+            None\n         } else {\n-            serde_json::json!({ \"replace\": final_state })\n+            Some(Replace { replace: final_state.clone() })\n+        };\n+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });\n+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {\n+            emit(ProofTag::Normalization { target });\n+        }\n+        let out = match delta {\n+            None => serde_json::Value::Null,\n+            Some(d) => serde_json::json!({ \"replace\": d.replace }),\n         };\n \n         Ok(out)"},{"sha":"5301c8487c8e4dfc7b1f8715bcf8682113ce936e","filename":"packages/tf-lang-l0-rs/tests/proof_dev.rs","status":"added","additions":55,"deletions":0,"changes":55,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,55 @@\n+use serde_json::json;\n+use tflang_l0::model::{Instr, Program};\n+use tflang_l0::vm::interpreter::VM;\n+use tflang_l0::vm::opcode::Host;\n+use tflang_l0::proof::{flush, ProofTag, TransportOp};\n+\n+struct DummyHost;\n+\n+impl Host for DummyHost {\n+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"region\": region, \"state\": state}))\n+    }\n+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"orig\": state, \"sub\": substate}))\n+    }\n+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok(\"id\".into()) }\n+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }\n+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {\n+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))\n+    }\n+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {\n+        Ok(tflang_l0::model::World(world.0.clone()))\n+    }\n+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }\n+}\n+\n+fn sample_prog() -> Program {\n+    Program {\n+        version: \"0.1\".into(),\n+        regs: 2,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!({}) },\n+            Instr::LensProj { dst: 1, state: 0, region: \"r\".into() },\n+            Instr::Const { dst: 0, value: json!({\"x\":1}) },\n+            Instr::Halt,\n+        ],\n+    }\n+}\n+\n+#[test]\n+fn dev_proofs_toggles_tags() {\n+    std::env::set_var(\"DEV_PROOFS\", \"1\");\n+    let vm = VM { host: &DummyHost };\n+    let _ = vm.run(&sample_prog()).unwrap();\n+    let tags = flush();\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));\n+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+\n+    std::env::remove_var(\"DEV_PROOFS\");\n+    let _ = vm.run(&sample_prog()).unwrap();\n+    let tags = flush();\n+    assert!(tags.is_empty());\n+}"},{"sha":"3588d098e018b666f5b502857717d14bbccb5a2b","filename":"packages/tf-lang-l0-ts/src/index.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -5,4 +5,4 @@ export * as check from './check/index.js';\n export { canonicalJsonBytes } from './canon/json.js';\n export { blake3hex } from './canon/hash.js';\n export * as ops from './ops/index.js';\n-export * as proof from './proof/tags.js';\n+export * as proof from './proof/index.js';"},{"sha":"991c932188806f388d3d6fae650a7d2e417609ea","filename":"packages/tf-lang-l0-ts/src/proof/index.ts","status":"added","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,16 @@\n+export * from './tags.js';\n+import type { ProofTag } from './tags.js';\n+\n+const log: ProofTag[] = [];\n+\n+export function emit(tag: ProofTag): void {\n+  if (process.env.DEV_PROOFS === '1') {\n+    log.push(tag);\n+  }\n+}\n+\n+export function flush(): ProofTag[] {\n+  const out = log.slice();\n+  log.length = 0;\n+  return out;\n+}"},{"sha":"c4b5fbe67565531cf1db48186290f87fc5a36451","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n+import { emit } from '../proof/index.js';\n \n export class VM {\n   constructor(public host: Host) {}\n@@ -41,8 +42,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +76,20 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          try {\n+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          } catch (e: any) {\n+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });\n+            throw e;\n+          }\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -91,10 +108,10 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    if (Buffer.from(a).equals(Buffer.from(b))) {\n-      return null;\n-    }\n-    return { replace: finalState };\n+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };\n+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));\n+    return delta;\n   }\n }\n "},{"sha":"691e4679f85237b347d8692bb2b4c81e7a982170","filename":"packages/tf-lang-l0-ts/tests/proof-dev.test.ts","status":"added","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -0,0 +1,35 @@\n+import { describe, it, expect } from 'vitest';\n+import { VM } from '../src/vm/index.js';\n+import type { Program } from '../src/model/bytecode.js';\n+import { DummyHost } from '../src/host/memory.js';\n+import { flush } from '../src/proof/index.js';\n+\n+describe('proof dev mode', () => {\n+  const prog: Program = {\n+    version: '0.1',\n+    regs: 2,\n+    instrs: [\n+      { op: 'CONST', dst: 0, value: {} },\n+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },\n+      { op: 'CONST', dst: 0, value: { x: 1 } },\n+      { op: 'HALT' },\n+    ],\n+  };\n+\n+  it('emits tags when DEV_PROOFS=1', async () => {\n+    process.env.DEV_PROOFS = '1';\n+    const vm = new VM(DummyHost);\n+    await vm.run(prog);\n+    const tags = flush();\n+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);\n+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);\n+    delete process.env.DEV_PROOFS;\n+  });\n+\n+  it('no tags when DEV_PROOFS is unset', async () => {\n+    const vm = new VM(DummyHost);\n+    await vm.run(prog);\n+    const tags = flush();\n+    expect(tags.length).toBe(0);\n+  });\n+});"},{"sha":"84020f7a6fb48f42653c12ed963f928fe34b852f","filename":"packages/tf-lang-l0-ts/tests/proof-tags.test.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/f8920220396bfa1869abd6d2a52d469efb2cd4c0/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts?ref=f8920220396bfa1869abd6d2a52d469efb2cd4c0","patch":"@@ -1,5 +1,5 @@\n import { describe, it, expect } from 'vitest';\n-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';\n+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';\n \n describe('proof tags', () => {\n   it('compile tag shapes', () => {"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..eb92ae6 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,15 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+## [B2] Proof tag emission
+- Start: 2025-09-11 23:00 UTC
+- End:   2025-09-11 23:30 UTC
+- Changes:
+  - added DEV_PROOFS-gated proof log in TS and Rust
+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags
+  - tests cover tag emission toggled by DEV_PROOFS
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests passed
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..8f93114 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,4 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-11] Rule: "Proof tags emitted only when DEV_PROOFS=1." Guardrail: proof:dev_flag
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..d15db56
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1,2 @@
+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.
+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..c434bdd
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,25 @@
+# Plan for B2
+
+## Steps
+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.
+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.
+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.
+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.
+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.
+6. Add Rust tests ensuring tags are emitted only in dev mode.
+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.
+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.
+
+## Tests
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks
+- Environment variable may leak between tests; ensure logs are flushed and variables reset.
+- Synchronizing tag structures across runtimes might be inconsistent.
+- Adding dependency `once_cell` for Rust logging could impact build.
+
+## Definition of Done
+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.
+- Tests cover presence and absence of tags.
+- Journal updated and repository tests pass.
diff --git a/packages/tf-lang-l0-rs/Cargo.lock b/packages/tf-lang-l0-rs/Cargo.lock
index 485414a..307911d 100644
--- a/packages/tf-lang-l0-rs/Cargo.lock
+++ b/packages/tf-lang-l0-rs/Cargo.lock
@@ -79,6 +79,12 @@ version = "2.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
 
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
 [[package]]
 name = "pretty_assertions"
 version = "1.4.1"
@@ -168,6 +174,7 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "blake3",
+ "once_cell",
  "pretty_assertions",
  "serde",
  "serde_json",
diff --git a/packages/tf-lang-l0-rs/Cargo.toml b/packages/tf-lang-l0-rs/Cargo.toml
index 253a2b2..b007053 100644
--- a/packages/tf-lang-l0-rs/Cargo.toml
+++ b/packages/tf-lang-l0-rs/Cargo.toml
@@ -17,6 +17,7 @@ thiserror = "1"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 blake3 = "1.5"
+once_cell = "1"
 
 [dev-dependencies]
 pretty_assertions = "1"
diff --git a/packages/tf-lang-l0-rs/src/proof.rs b/packages/tf-lang-l0-rs/src/proof.rs
index 4a4ea5e..f045263 100644
--- a/packages/tf-lang-l0-rs/src/proof.rs
+++ b/packages/tf-lang-l0-rs/src/proof.rs
@@ -42,3 +42,18 @@ pub enum ProofTag {
     Refutation { code: String, msg: Option<String> },
     Conservativity { callee: String, expected: String, found: String },
 }
+
+use once_cell::sync::Lazy;
+use std::sync::Mutex;
+
+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));
+
+pub fn emit(tag: ProofTag) {
+    if std::env::var("DEV_PROOFS").unwrap_or_default() == "1" {
+        PROOF_LOG.lock().unwrap().push(tag);
+    }
+}
+
+pub fn flush() -> Vec<ProofTag> {
+    PROOF_LOG.lock().unwrap().drain(..).collect()
+}
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..383cd83 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
 use crate::vm::opcode::Host;
+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
@@ -37,6 +38,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        emit(ProofTag::Refutation { code: "ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -97,6 +99,7 @@ impl<'h> VM<'h> {
                 }
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });
                     regs[*dst as usize] = sub;
                 }
                 Instr::LensMerge {
@@ -105,9 +108,10 @@ impl<'h> VM<'h> {
                     region,
                     sub,
                 } => {
-                    let merged =
-                        self.host
-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    let merged = self
+                        .host
+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });
                     regs[*dst as usize] = merged;
                 }
                 Instr::PlanSim {
@@ -173,7 +177,10 @@ impl<'h> VM<'h> {
                     for r in args {
                         a.push(get(*r, &regs)?.clone());
                     }
-                    let out = self.host.call_tf(tf_id, &a)?;
+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {
+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: "ok".into(), found: format!("{}", e) });
+                        e
+                    })?;
                     regs[*dst as usize] = out;
                 }
             }
@@ -184,10 +191,18 @@ impl<'h> VM<'h> {
         }
 
         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);
-        let out = if final_state == initial_state {
-            serde_json::Value::Null
+        let delta = if final_state == initial_state {
+            None
         } else {
-            serde_json::json!({ "replace": final_state })
+            Some(Replace { replace: final_state.clone() })
+        };
+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });
+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {
+            emit(ProofTag::Normalization { target });
+        }
+        let out = match delta {
+            None => serde_json::Value::Null,
+            Some(d) => serde_json::json!({ "replace": d.replace }),
         };
 
         Ok(out)
diff --git a/packages/tf-lang-l0-rs/tests/proof_dev.rs b/packages/tf-lang-l0-rs/tests/proof_dev.rs
new file mode 100644
index 0000000..5301c84
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/proof_dev.rs
@@ -0,0 +1,55 @@
+use serde_json::json;
+use tflang_l0::model::{Instr, Program};
+use tflang_l0::vm::interpreter::VM;
+use tflang_l0::vm::opcode::Host;
+use tflang_l0::proof::{flush, ProofTag, TransportOp};
+
+struct DummyHost;
+
+impl Host for DummyHost {
+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"region": region, "state": state}))
+    }
+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"orig": state, "sub": substate}))
+    }
+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok("id".into()) }
+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }
+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {
+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))
+    }
+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {
+        Ok(tflang_l0::model::World(world.0.clone()))
+    }
+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }
+}
+
+fn sample_prog() -> Program {
+    Program {
+        version: "0.1".into(),
+        regs: 2,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!({}) },
+            Instr::LensProj { dst: 1, state: 0, region: "r".into() },
+            Instr::Const { dst: 0, value: json!({"x":1}) },
+            Instr::Halt,
+        ],
+    }
+}
+
+#[test]
+fn dev_proofs_toggles_tags() {
+    std::env::set_var("DEV_PROOFS", "1");
+    let vm = VM { host: &DummyHost };
+    let _ = vm.run(&sample_prog()).unwrap();
+    let tags = flush();
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));
+    assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+
+    std::env::remove_var("DEV_PROOFS");
+    let _ = vm.run(&sample_prog()).unwrap();
+    let tags = flush();
+    assert!(tags.is_empty());
+}
diff --git a/packages/tf-lang-l0-ts/src/index.ts b/packages/tf-lang-l0-ts/src/index.ts
index 14746e5..3588d09 100644
--- a/packages/tf-lang-l0-ts/src/index.ts
+++ b/packages/tf-lang-l0-ts/src/index.ts
@@ -5,4 +5,4 @@ export * as check from './check/index.js';
 export { canonicalJsonBytes } from './canon/json.js';
 export { blake3hex } from './canon/hash.js';
 export * as ops from './ops/index.js';
-export * as proof from './proof/tags.js';
+export * as proof from './proof/index.js';
diff --git a/packages/tf-lang-l0-ts/src/proof/index.ts b/packages/tf-lang-l0-ts/src/proof/index.ts
new file mode 100644
index 0000000..991c932
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/index.ts
@@ -0,0 +1,16 @@
+export * from './tags.js';
+import type { ProofTag } from './tags.js';
+
+const log: ProofTag[] = [];
+
+export function emit(tag: ProofTag): void {
+  if (process.env.DEV_PROOFS === '1') {
+    log.push(tag);
+  }
+}
+
+export function flush(): ProofTag[] {
+  const out = log.slice();
+  log.length = 0;
+  return out;
+}
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..c4b5fbe 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
+import { emit } from '../proof/index.js';
 
 export class VM {
   constructor(public host: Host) {}
@@ -41,8 +42,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +76,20 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          try {
+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          } catch (e: any) {
+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });
+            throw e;
+          }
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -91,10 +108,10 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    if (Buffer.from(a).equals(Buffer.from(b))) {
-      return null;
-    }
-    return { replace: finalState };
+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };
+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));
+    return delta;
   }
 }
 
diff --git a/packages/tf-lang-l0-ts/tests/proof-dev.test.ts b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
new file mode 100644
index 0000000..691e467
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
@@ -0,0 +1,35 @@
+import { describe, it, expect } from 'vitest';
+import { VM } from '../src/vm/index.js';
+import type { Program } from '../src/model/bytecode.js';
+import { DummyHost } from '../src/host/memory.js';
+import { flush } from '../src/proof/index.js';
+
+describe('proof dev mode', () => {
+  const prog: Program = {
+    version: '0.1',
+    regs: 2,
+    instrs: [
+      { op: 'CONST', dst: 0, value: {} },
+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },
+      { op: 'CONST', dst: 0, value: { x: 1 } },
+      { op: 'HALT' },
+    ],
+  };
+
+  it('emits tags when DEV_PROOFS=1', async () => {
+    process.env.DEV_PROOFS = '1';
+    const vm = new VM(DummyHost);
+    await vm.run(prog);
+    const tags = flush();
+    expect(tags.some(t => t.kind === 'Transport')).toBe(true);
+    expect(tags.some(t => t.kind === 'Witness')).toBe(true);
+    delete process.env.DEV_PROOFS;
+  });
+
+  it('no tags when DEV_PROOFS is unset', async () => {
+    const vm = new VM(DummyHost);
+    await vm.run(prog);
+    const tags = flush();
+    expect(tags.length).toBe(0);
+  });
+});
diff --git a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
index 73f4ae2..84020f7 100644
--- a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
+++ b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
@@ -1,5 +1,5 @@
 import { describe, it, expect } from 'vitest';
-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';
+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';
 
 describe('proof tags', () => {
   it('compile tag shapes', () => {
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T03:03:27Z","isDraft":false,"mergeStateStatus":"CLEAN","number":24,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_mEuL","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request enhances the development experience by enabling detailed proof tag emission within the TypeScript and Rust virtual machines. The primary goal is to provide richer debugging and analysis capabilities for understanding VM execution flows, without impacting production performance or log verbosity, by making this feature strictly opt-in via an environment variable.\n\n### Highlights\n\n* **Conditional Proof Tag Emission**: Introduced a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust VMs, strictly gated by the `DEV_PROOFS=1` environment variable. This ensures that detailed proof logs are only generated in development environments.\n* **VM Interpreter Integration**: Modified the core VM interpreters in both TypeScript and Rust to integrate the new proof tag emission. Tags are now emitted at key operational points, such as assertion failures, lens operations, function calls, and at the completion of execution to capture witness and normalization data.\n* **New Proof Logging Modules**: Created dedicated proof logging modules in both Rust (`src/proof.rs`) and TypeScript (`src/proof/index.ts`) to manage the collection and flushing of proof tags. These modules provide `emit` and `flush` functions, centralizing the proof logging logic.\n* **Testing and Documentation**: Added new test files (`proof_dev.rs` and `proof-dev.test.ts`) to explicitly verify that proof tags are emitted only when `DEV_PROOFS` is set, and are absent otherwise. Internal documentation (`.codex/JOURNAL.md`, `.codex/LESSONS.md`, `.codex/polish/B2.md`, `.codex/self-plans/B2.md`) has been updated to reflect these changes and the associated development plan.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T03:03:45Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"f8920220396bfa1869abd6d2a52d469efb2cd4c0"}},{"id":"PRR_kwDOPs5-l86_mFJ5","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces a valuable debugging feature by emitting proof tags in development mode for both the Rust and TypeScript VMs. The implementation is gated by a `DEV_PROOFS` environment variable, and new tests are added to verify this behavior. The changes are logical and well-structured. My review includes suggestions to improve the robustness of the tests against parallelism issues and to enhance type safety in the TypeScript implementation.","submittedAt":"2025-09-12T03:05:28Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"f8920220396bfa1869abd6d2a52d469efb2cd4c0"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:58Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257057/job/50200351254","name":"conformance","startedAt":"2025-09-12T03:03:33Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:52Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351311","name":"TypeScript build & test","startedAt":"2025-09-12T03:03:32Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:40Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200351319","name":"changed","startedAt":"2025-09-12T03:03:32Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:04:11Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257062/job/50200351309","name":"Rust build & test","startedAt":"2025-09-12T03:03:33Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:50Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369983","name":"ts","startedAt":"2025-09-12T03:03:42Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:04:21Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200369976","name":"rust","startedAt":"2025-09-12T03:03:42Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T03:03:40Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17663257056/job/50200370216","name":"golden","startedAt":"2025-09-12T03:03:40Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"B2: emit proof tags in dev mode","updatedAt":"2025-09-12T03:05:28Z","url":"https://github.com/LexLattice/tf-lang/pull/24"}
```


---

# PR #27 — B2: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/27
- Author: @andreidita22
- Created: 2025-09-12T08:13:22Z
- Updated: 2025-09-12T08:37:53Z

## Checks
```
rust	pass	31s	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462922	
ts	pass	11s	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462938	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462872	
Rust build & test	pass	41s	https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453452	
TypeScript build & test	pass	8s	https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453439	
changed	pass	4s	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215453460	
conformance	pass	36s	https://github.com/LexLattice/tf-lang/actions/runs/17668720003/job/50215453407	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request enhances the debugging and introspection capabilities of the system by introducing "proof tags" that provide detailed insights into the execution flow of both TypeScript and Rust virtual machines. These tags, which capture events like state transformations, assertions, and function calls, are conditionally emitted only when a DEV_PROOFS environment variable is set, preventing performance overhead in production. The changes also include robust mechanisms for caching this environment variable and isolating its state during testing, ensuring reliable and predictable behavior across development and test environments.

### Highlights

* **Conditional Proof Tag Emission**: Implemented a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust runtimes, but only when the DEV_PROOFS environment variable is enabled.
* **Performance Optimization & Test Isolation**: Introduced caching for the DEV_PROOFS flag in both runtimes to avoid repeated environment variable lookups, along with test-only reset hooks and scoped environment helpers to ensure test isolation and prevent leakage of environment state.
* **Proof Tag Serialization Lock**: Added a test to lock the serialization shape of ProofTag::Normalization in Rust, ensuring consistency and preventing accidental breaking changes to the proof tag structure.
* **Comprehensive Tagging**: Integrated proof tag emission into key VM operations, including lens projections/merges, assertion failures, and function call errors, as well as final witness and normalization states.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces proof tag emission in dev mode for both Rust and TypeScript runtimes, controlled by a `DEV_PROOFS` environment variable. The changes include caching for the flag check to optimize performance and new test helpers for managing environment variables to ensure test stability. The implementation is solid, and my feedback focuses on potential performance improvements, enhancing robustness against panics in the Rust code, addressing thread-safety concerns in tests, and improving test coverage and type safety.
--
author:	chatgpt-codex-connector
association:	none
edited:	false
status:	commented
--
Codex Review: Here are some suggestions.

Reply with `@codex fix comments` to fix any unresolved comments.

<details> <summary>About Codex in GitHub</summary>

[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment "@codex review". If Codex has suggestions, it will comment; otherwise it will react with 👍.

Codex can also answer questions or update the PR. Try commenting "@codex fix this CI failure" or "@codex address that feedback".
</details>
--
```

## Files Changed (JSON)
```json
[{"sha":"7f0f35123d291477cc14db39486071770fdad2a7","filename":".codex/JOURNAL.md","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -500,3 +500,27 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+## [B2] Proof tag emission\n+- Start: 2025-09-11 23:00 UTC\n+- End:   2025-09-11 23:30 UTC\n+- Changes:\n+  - added DEV_PROOFS-gated proof log in TS and Rust\n+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags\n+  - tests cover tag emission toggled by DEV_PROOFS\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests passed\n+## [B2-polish] Cache DEV_PROOFS\n+- Start: 2025-09-11 23:40 UTC\n+- End:   2025-09-11 23:55 UTC\n+- Changes:\n+  - centralized cached DEV_PROOFS flag in TS and Rust runtimes\n+  - scoped env helpers for tests and JSON shape lock\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - pnpm -C packages/tf-lang-l0-ts vectors\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests and vectors passed"},{"sha":"c179ab8d0ce2ac18749f3fd59034b8fa0531b84d","filename":".codex/LESSONS.md","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -18,3 +18,5 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-11] Rule: \"Proof tags emitted only when DEV_PROOFS=1.\" Guardrail: proof:dev_flag\n+- [B2-polish][2025-09-11] Rule: \"Cache feature flags; tests use scoped env guards.\" Guardrail: proof:env_cache"},{"sha":"d15db569325eef38e564861509f191dee9687288","filename":".codex/polish/B2.md","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,2 @@\n+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.\n+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'."},{"sha":"c434bdd3898e1ed0286eada6f934fb1588576103","filename":".codex/self-plans/B2.md","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,25 @@\n+# Plan for B2\n+\n+## Steps\n+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.\n+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.\n+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.\n+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.\n+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.\n+6. Add Rust tests ensuring tags are emitted only in dev mode.\n+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.\n+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.\n+\n+## Tests\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks\n+- Environment variable may leak between tests; ensure logs are flushed and variables reset.\n+- Synchronizing tag structures across runtimes might be inconsistent.\n+- Adding dependency `once_cell` for Rust logging could impact build.\n+\n+## Definition of Done\n+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.\n+- Tests cover presence and absence of tags.\n+- Journal updated and repository tests pass."},{"sha":"307911ddff06feca12c7c48e4d09cc0328542053","filename":"packages/tf-lang-l0-rs/Cargo.lock","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.lock","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.lock","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.lock?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -79,6 +79,12 @@ version = \"2.7.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0\"\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.21.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n+\n [[package]]\n name = \"pretty_assertions\"\n version = \"1.4.1\"\n@@ -168,6 +174,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"blake3\",\n+ \"once_cell\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\","},{"sha":"b007053d53a73ac579af68fc9155f1a7f3582a7f","filename":"packages/tf-lang-l0-rs/Cargo.toml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.toml","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.toml","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.toml?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -17,6 +17,7 @@ thiserror = \"1\"\n serde = { version = \"1\", features = [\"derive\"] }\n serde_json = \"1\"\n blake3 = \"1.5\"\n+once_cell = \"1\"\n \n [dev-dependencies]\n pretty_assertions = \"1\""},{"sha":"a124ac313bdb0e99d008d13cd83219ef065caadc","filename":"packages/tf-lang-l0-rs/src/env.rs","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,25 @@\n+use std::sync::{Mutex, OnceLock};\n+/// Centralized, cached environment feature flags for the Rust runtime.\n+static DEV_PROOFS: OnceLock<Mutex<Option<bool>>> = OnceLock::new();\n+\n+pub fn dev_proofs_enabled() -> bool {\n+    let lock = DEV_PROOFS.get_or_init(|| Mutex::new(None));\n+    let mut cache = lock.lock().unwrap();\n+    if let Some(v) = *cache {\n+        v\n+    } else {\n+        let v = std::env::var(\"DEV_PROOFS\")\n+            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n+            .unwrap_or(false);\n+        *cache = Some(v);\n+        v\n+    }\n+}\n+\n+/// TESTS ONLY: clear cached flags\n+#[doc(hidden)]\n+pub fn __reset_env_cache_for_tests__() {\n+    if let Some(lock) = DEV_PROOFS.get() {\n+        *lock.lock().unwrap() = None;\n+    }\n+}"},{"sha":"ab13c3a315c661decb26bcb84eee7fe03b93a727","filename":"packages/tf-lang-l0-rs/src/lib.rs","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -5,5 +5,6 @@ pub mod util;\n pub mod vm;\n pub mod ops;\n pub mod proof;\n+pub mod env;\n \n // Avoid glob re-exports at crate root to prevent ambiguous names (e.g., `types`)."},{"sha":"cd0f0da4af8cea85f3da835df61d7462155c4196","filename":"packages/tf-lang-l0-rs/src/proof.rs","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -42,3 +42,19 @@ pub enum ProofTag {\n     Refutation { code: String, msg: Option<String> },\n     Conservativity { callee: String, expected: String, found: String },\n }\n+\n+use once_cell::sync::Lazy;\n+use std::sync::Mutex;\n+use crate::env::dev_proofs_enabled;\n+\n+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));\n+\n+pub fn emit(tag: ProofTag) {\n+    if dev_proofs_enabled() {\n+        PROOF_LOG.lock().unwrap().push(tag);\n+    }\n+}\n+\n+pub fn flush() -> Vec<ProofTag> {\n+    PROOF_LOG.lock().unwrap().drain(..).collect()\n+}"},{"sha":"383cd8315c311ce7237e43987f2b54a194b3618b","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":22,"deletions":7,"changes":29,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n use crate::vm::opcode::Host;\n+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n@@ -37,6 +38,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        emit(ProofTag::Refutation { code: \"ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -97,6 +99,7 @@ impl<'h> VM<'h> {\n                 }\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });\n                     regs[*dst as usize] = sub;\n                 }\n                 Instr::LensMerge {\n@@ -105,9 +108,10 @@ impl<'h> VM<'h> {\n                     region,\n                     sub,\n                 } => {\n-                    let merged =\n-                        self.host\n-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    let merged = self\n+                        .host\n+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });\n                     regs[*dst as usize] = merged;\n                 }\n                 Instr::PlanSim {\n@@ -173,7 +177,10 @@ impl<'h> VM<'h> {\n                     for r in args {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n-                    let out = self.host.call_tf(tf_id, &a)?;\n+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {\n+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: \"ok\".into(), found: format!(\"{}\", e) });\n+                        e\n+                    })?;\n                     regs[*dst as usize] = out;\n                 }\n             }\n@@ -184,10 +191,18 @@ impl<'h> VM<'h> {\n         }\n \n         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);\n-        let out = if final_state == initial_state {\n-            serde_json::Value::Null\n+        let delta = if final_state == initial_state {\n+            None\n         } else {\n-            serde_json::json!({ \"replace\": final_state })\n+            Some(Replace { replace: final_state.clone() })\n+        };\n+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });\n+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {\n+            emit(ProofTag::Normalization { target });\n+        }\n+        let out = match delta {\n+            None => serde_json::Value::Null,\n+            Some(d) => serde_json::json!({ \"replace\": d.replace }),\n         };\n \n         Ok(out)"},{"sha":"3ddfa82431a985165e6089ea253238944ad28d4d","filename":"packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs","status":"added","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,14 @@\n+use tflang_l0::env::{dev_proofs_enabled, __reset_env_cache_for_tests__};\n+mod util;\n+use util::env::EnvVarGuard;\n+\n+#[test]\n+fn dev_proofs_is_cached() {\n+    let _g = EnvVarGuard::set(\"DEV_PROOFS\", \"1\");\n+    assert!(dev_proofs_enabled());\n+    drop(_g); // restore\n+    // Flip env, but cache should hold until reset\n+    let _g2 = EnvVarGuard::unset(\"DEV_PROOFS\");\n+    assert!(dev_proofs_enabled());\n+    __reset_env_cache_for_tests__();\n+}"},{"sha":"4511d3589314cff38393ceb588856ed787201202","filename":"packages/tf-lang-l0-rs/tests/proof_dev.rs","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,65 @@\n+use serde_json::json;\n+use tflang_l0::model::{Instr, Program};\n+use tflang_l0::vm::interpreter::VM;\n+use tflang_l0::vm::opcode::Host;\n+use tflang_l0::proof::{flush, ProofTag, TransportOp};\n+use tflang_l0::env::__reset_env_cache_for_tests__;\n+mod util;\n+use util::env::EnvVarGuard;\n+\n+struct DummyHost;\n+\n+impl Host for DummyHost {\n+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"region\": region, \"state\": state}))\n+    }\n+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"orig\": state, \"sub\": substate}))\n+    }\n+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok(\"id\".into()) }\n+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }\n+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {\n+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))\n+    }\n+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {\n+        Ok(tflang_l0::model::World(world.0.clone()))\n+    }\n+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }\n+}\n+\n+fn sample_prog() -> Program {\n+    Program {\n+        version: \"0.1\".into(),\n+        regs: 2,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!({}) },\n+            Instr::LensProj { dst: 1, state: 0, region: \"r\".into() },\n+            Instr::Const { dst: 0, value: json!({\"x\":1}) },\n+            Instr::Halt,\n+        ],\n+    }\n+}\n+\n+#[test]\n+fn dev_proofs_toggles_tags() {\n+    {\n+        let _g = EnvVarGuard::set(\"DEV_PROOFS\", \"1\");\n+        __reset_env_cache_for_tests__();\n+        let vm = VM { host: &DummyHost };\n+        let _ = vm.run(&sample_prog()).unwrap();\n+        let tags = flush();\n+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));\n+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+    }\n+\n+    {\n+        let _g = EnvVarGuard::unset(\"DEV_PROOFS\");\n+        __reset_env_cache_for_tests__();\n+        let vm = VM { host: &DummyHost };\n+        let _ = vm.run(&sample_prog()).unwrap();\n+        let tags = flush();\n+        assert!(tags.is_empty());\n+    }\n+}"},{"sha":"e7135c4554bacb94f0c4ecb3699e20f522a94255","filename":"packages/tf-lang-l0-rs/tests/serde_shapes.rs","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,9 @@\n+use serde_json::json;\n+use tflang_l0::proof::{ProofTag, NormalizationTarget};\n+\n+#[test]\n+fn proof_tag_normalization_shape() {\n+    let n = ProofTag::Normalization { target: NormalizationTarget::Delta };\n+    let v = serde_json::to_value(&n).unwrap();\n+    assert_eq!(v, json!({\"kind\":\"Normalization\",\"target\":\"delta\"}));\n+}"},{"sha":"9cba035c9eed08e7cc0ecb0a763e824bb872178b","filename":"packages/tf-lang-l0-rs/tests/util/env.rs","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,26 @@\n+use std::env;\n+/// RAII guard for scoped env overrides to prevent test flakiness.\n+pub struct EnvVarGuard {\n+    key: String,\n+    prev: Option<String>,\n+}\n+impl EnvVarGuard {\n+    pub fn set(key: &str, val: &str) -> Self {\n+        let prev = env::var(key).ok();\n+        env::set_var(key, val);\n+        Self { key: key.to_string(), prev }\n+    }\n+    pub fn unset(key: &str) -> Self {\n+        let prev = env::var(key).ok();\n+        env::remove_var(key);\n+        Self { key: key.to_string(), prev }\n+    }\n+}\n+impl Drop for EnvVarGuard {\n+    fn drop(&mut self) {\n+        match &self.prev {\n+            Some(v) => env::set_var(&self.key, v),\n+            None => env::remove_var(&self.key),\n+        }\n+    }\n+}"},{"sha":"3d7924f6ab50a87d6c5d6e3418d3f1a9242f5681","filename":"packages/tf-lang-l0-rs/tests/util/mod.rs","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1 @@\n+pub mod env;"},{"sha":"3588d098e018b666f5b502857717d14bbccb5a2b","filename":"packages/tf-lang-l0-ts/src/index.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -5,4 +5,4 @@ export * as check from './check/index.js';\n export { canonicalJsonBytes } from './canon/json.js';\n export { blake3hex } from './canon/hash.js';\n export * as ops from './ops/index.js';\n-export * as proof from './proof/tags.js';\n+export * as proof from './proof/index.js';"},{"sha":"c1a33e47d7703f5707f2511da83bfc1f37464530","filename":"packages/tf-lang-l0-ts/src/proof/index.ts","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,17 @@\n+export * from './tags.js';\n+import type { ProofTag } from './tags.js';\n+import { devProofsEnabled } from '../util/env';\n+\n+const log: ProofTag[] = [];\n+\n+export function emit(tag: ProofTag): void {\n+  if (devProofsEnabled()) {\n+    log.push(tag);\n+  }\n+}\n+\n+export function flush(): ProofTag[] {\n+  const out = log.slice();\n+  log.length = 0;\n+  return out;\n+}"},{"sha":"75bef9afb9e0a1e622e378ab97d873986825c172","filename":"packages/tf-lang-l0-ts/src/util/env.ts","status":"added","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,14 @@\n+// Centralized, cached environment feature flags for the TS runtime.\n+let _devProofs: boolean | undefined;\n+export function devProofsEnabled(): boolean {\n+  if (_devProofs === undefined) {\n+    const v = (process.env.DEV_PROOFS || '').toLowerCase();\n+    _devProofs = v === '1' || v === 'true';\n+  }\n+  return _devProofs;\n+}\n+\n+// For tests only: reset the cached flag (not exported in build).\n+export function __resetEnvCacheForTests__() {\n+  _devProofs = undefined;\n+}"},{"sha":"c4b5fbe67565531cf1db48186290f87fc5a36451","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n+import { emit } from '../proof/index.js';\n \n export class VM {\n   constructor(public host: Host) {}\n@@ -41,8 +42,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +76,20 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          try {\n+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          } catch (e: any) {\n+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });\n+            throw e;\n+          }\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -91,10 +108,10 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    if (Buffer.from(a).equals(Buffer.from(b))) {\n-      return null;\n-    }\n-    return { replace: finalState };\n+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };\n+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));\n+    return delta;\n   }\n }\n "},{"sha":"306829767c2d96bf5c067c3bf147525e96ecbfe4","filename":"packages/tf-lang-l0-ts/tests/helpers/env.ts","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,22 @@\n+// Scoped env override for tests to avoid leaking state across parallel cases.\n+export async function withEnv<T>(\n+  vars: Record<string, string | undefined>,\n+  fn: () => Promise<T> | T\n+): Promise<T> {\n+  const prev: Record<string, string | undefined> = {};\n+  for (const k of Object.keys(vars)) {\n+    prev[k] = process.env[k];\n+    const v = vars[k];\n+    if (v === undefined) delete process.env[k];\n+    else process.env[k] = v;\n+  }\n+  try {\n+    return await fn();\n+  } finally {\n+    for (const k of Object.keys(vars)) {\n+      const v = prev[k];\n+      if (v === undefined) delete process.env[k];\n+      else process.env[k] = v;\n+    }\n+  }\n+}"},{"sha":"23f3f48412dd2eae26e5b46ea16215db2b9e3957","filename":"packages/tf-lang-l0-ts/tests/proof-dev.test.ts","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,40 @@\n+import { describe, it, expect, afterEach } from 'vitest';\n+import { VM } from '../src/vm/index.js';\n+import type { Program } from '../src/model/bytecode.js';\n+import { DummyHost } from '../src/host/memory.js';\n+import { flush } from '../src/proof/index.js';\n+import { withEnv } from './helpers/env';\n+import { __resetEnvCacheForTests__ } from '../src/util/env';\n+\n+describe('proof dev mode', () => {\n+  afterEach(() => __resetEnvCacheForTests__());\n+  const prog: Program = {\n+    version: '0.1',\n+    regs: 2,\n+    instrs: [\n+      { op: 'CONST', dst: 0, value: {} },\n+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },\n+      { op: 'CONST', dst: 0, value: { x: 1 } },\n+      { op: 'HALT' },\n+    ],\n+  };\n+\n+  it('emits tags when DEV_PROOFS=1', async () => {\n+    await withEnv({ DEV_PROOFS: '1' }, async () => {\n+      const vm = new VM(DummyHost);\n+      await vm.run(prog);\n+      const tags = flush();\n+      expect(tags.some(t => t.kind === 'Transport')).toBe(true);\n+      expect(tags.some(t => t.kind === 'Witness')).toBe(true);\n+    });\n+  });\n+\n+  it('no tags when DEV_PROOFS is unset', async () => {\n+    await withEnv({ DEV_PROOFS: undefined }, async () => {\n+      const vm = new VM(DummyHost);\n+      await vm.run(prog);\n+      const tags = flush();\n+      expect(tags.length).toBe(0);\n+    });\n+  });\n+});"},{"sha":"84020f7a6fb48f42653c12ed963f928fe34b852f","filename":"packages/tf-lang-l0-ts/tests/proof-tags.test.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -1,5 +1,5 @@\n import { describe, it, expect } from 'vitest';\n-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';\n+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';\n \n describe('proof tags', () => {\n   it('compile tag shapes', () => {"},{"sha":"62d88abc4ef50fd6aac5bc6cfa6b467f8d9b9ba3","filename":"packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,17 @@\n+import { describe, it, expect, afterEach } from 'vitest';\n+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';\n+import { withEnv } from '../helpers/env';\n+\n+describe('DEV_PROOFS caching (TS)', () => {\n+  afterEach(() => __resetEnvCacheForTests__());\n+\n+  it('reads once and caches', async () => {\n+    await withEnv({ DEV_PROOFS: '1' }, () => {\n+      expect(devProofsEnabled()).toBe(true);\n+    });\n+    // Flip env but cache should hold until reset\n+    await withEnv({ DEV_PROOFS: '0' }, () => {\n+      expect(devProofsEnabled()).toBe(true);\n+    });\n+  });\n+});"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..7f0f351 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,27 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+## [B2] Proof tag emission
+- Start: 2025-09-11 23:00 UTC
+- End:   2025-09-11 23:30 UTC
+- Changes:
+  - added DEV_PROOFS-gated proof log in TS and Rust
+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags
+  - tests cover tag emission toggled by DEV_PROOFS
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests passed
+## [B2-polish] Cache DEV_PROOFS
+- Start: 2025-09-11 23:40 UTC
+- End:   2025-09-11 23:55 UTC
+- Changes:
+  - centralized cached DEV_PROOFS flag in TS and Rust runtimes
+  - scoped env helpers for tests and JSON shape lock
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - pnpm -C packages/tf-lang-l0-ts vectors
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests and vectors passed
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..c179ab8 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,5 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-11] Rule: "Proof tags emitted only when DEV_PROOFS=1." Guardrail: proof:dev_flag
+- [B2-polish][2025-09-11] Rule: "Cache feature flags; tests use scoped env guards." Guardrail: proof:env_cache
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..d15db56
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1,2 @@
+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.
+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..c434bdd
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,25 @@
+# Plan for B2
+
+## Steps
+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.
+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.
+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.
+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.
+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.
+6. Add Rust tests ensuring tags are emitted only in dev mode.
+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.
+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.
+
+## Tests
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks
+- Environment variable may leak between tests; ensure logs are flushed and variables reset.
+- Synchronizing tag structures across runtimes might be inconsistent.
+- Adding dependency `once_cell` for Rust logging could impact build.
+
+## Definition of Done
+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.
+- Tests cover presence and absence of tags.
+- Journal updated and repository tests pass.
diff --git a/packages/tf-lang-l0-rs/Cargo.lock b/packages/tf-lang-l0-rs/Cargo.lock
index 485414a..307911d 100644
--- a/packages/tf-lang-l0-rs/Cargo.lock
+++ b/packages/tf-lang-l0-rs/Cargo.lock
@@ -79,6 +79,12 @@ version = "2.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
 
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
 [[package]]
 name = "pretty_assertions"
 version = "1.4.1"
@@ -168,6 +174,7 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "blake3",
+ "once_cell",
  "pretty_assertions",
  "serde",
  "serde_json",
diff --git a/packages/tf-lang-l0-rs/Cargo.toml b/packages/tf-lang-l0-rs/Cargo.toml
index 253a2b2..b007053 100644
--- a/packages/tf-lang-l0-rs/Cargo.toml
+++ b/packages/tf-lang-l0-rs/Cargo.toml
@@ -17,6 +17,7 @@ thiserror = "1"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 blake3 = "1.5"
+once_cell = "1"
 
 [dev-dependencies]
 pretty_assertions = "1"
diff --git a/packages/tf-lang-l0-rs/src/env.rs b/packages/tf-lang-l0-rs/src/env.rs
new file mode 100644
index 0000000..a124ac3
--- /dev/null
+++ b/packages/tf-lang-l0-rs/src/env.rs
@@ -0,0 +1,25 @@
+use std::sync::{Mutex, OnceLock};
+/// Centralized, cached environment feature flags for the Rust runtime.
+static DEV_PROOFS: OnceLock<Mutex<Option<bool>>> = OnceLock::new();
+
+pub fn dev_proofs_enabled() -> bool {
+    let lock = DEV_PROOFS.get_or_init(|| Mutex::new(None));
+    let mut cache = lock.lock().unwrap();
+    if let Some(v) = *cache {
+        v
+    } else {
+        let v = std::env::var("DEV_PROOFS")
+            .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
+            .unwrap_or(false);
+        *cache = Some(v);
+        v
+    }
+}
+
+/// TESTS ONLY: clear cached flags
+#[doc(hidden)]
+pub fn __reset_env_cache_for_tests__() {
+    if let Some(lock) = DEV_PROOFS.get() {
+        *lock.lock().unwrap() = None;
+    }
+}
diff --git a/packages/tf-lang-l0-rs/src/lib.rs b/packages/tf-lang-l0-rs/src/lib.rs
index a0a116d..ab13c3a 100644
--- a/packages/tf-lang-l0-rs/src/lib.rs
+++ b/packages/tf-lang-l0-rs/src/lib.rs
@@ -5,5 +5,6 @@ pub mod util;
 pub mod vm;
 pub mod ops;
 pub mod proof;
+pub mod env;
 
 // Avoid glob re-exports at crate root to prevent ambiguous names (e.g., `types`).
diff --git a/packages/tf-lang-l0-rs/src/proof.rs b/packages/tf-lang-l0-rs/src/proof.rs
index 4a4ea5e..cd0f0da 100644
--- a/packages/tf-lang-l0-rs/src/proof.rs
+++ b/packages/tf-lang-l0-rs/src/proof.rs
@@ -42,3 +42,19 @@ pub enum ProofTag {
     Refutation { code: String, msg: Option<String> },
     Conservativity { callee: String, expected: String, found: String },
 }
+
+use once_cell::sync::Lazy;
+use std::sync::Mutex;
+use crate::env::dev_proofs_enabled;
+
+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));
+
+pub fn emit(tag: ProofTag) {
+    if dev_proofs_enabled() {
+        PROOF_LOG.lock().unwrap().push(tag);
+    }
+}
+
+pub fn flush() -> Vec<ProofTag> {
+    PROOF_LOG.lock().unwrap().drain(..).collect()
+}
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..383cd83 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
 use crate::vm::opcode::Host;
+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
@@ -37,6 +38,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        emit(ProofTag::Refutation { code: "ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -97,6 +99,7 @@ impl<'h> VM<'h> {
                 }
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });
                     regs[*dst as usize] = sub;
                 }
                 Instr::LensMerge {
@@ -105,9 +108,10 @@ impl<'h> VM<'h> {
                     region,
                     sub,
                 } => {
-                    let merged =
-                        self.host
-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    let merged = self
+                        .host
+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });
                     regs[*dst as usize] = merged;
                 }
                 Instr::PlanSim {
@@ -173,7 +177,10 @@ impl<'h> VM<'h> {
                     for r in args {
                         a.push(get(*r, &regs)?.clone());
                     }
-                    let out = self.host.call_tf(tf_id, &a)?;
+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {
+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: "ok".into(), found: format!("{}", e) });
+                        e
+                    })?;
                     regs[*dst as usize] = out;
                 }
             }
@@ -184,10 +191,18 @@ impl<'h> VM<'h> {
         }
 
         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);
-        let out = if final_state == initial_state {
-            serde_json::Value::Null
+        let delta = if final_state == initial_state {
+            None
         } else {
-            serde_json::json!({ "replace": final_state })
+            Some(Replace { replace: final_state.clone() })
+        };
+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });
+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {
+            emit(ProofTag::Normalization { target });
+        }
+        let out = match delta {
+            None => serde_json::Value::Null,
+            Some(d) => serde_json::json!({ "replace": d.replace }),
         };
 
         Ok(out)
diff --git a/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
new file mode 100644
index 0000000..3ddfa82
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
@@ -0,0 +1,14 @@
+use tflang_l0::env::{dev_proofs_enabled, __reset_env_cache_for_tests__};
+mod util;
+use util::env::EnvVarGuard;
+
+#[test]
+fn dev_proofs_is_cached() {
+    let _g = EnvVarGuard::set("DEV_PROOFS", "1");
+    assert!(dev_proofs_enabled());
+    drop(_g); // restore
+    // Flip env, but cache should hold until reset
+    let _g2 = EnvVarGuard::unset("DEV_PROOFS");
+    assert!(dev_proofs_enabled());
+    __reset_env_cache_for_tests__();
+}
diff --git a/packages/tf-lang-l0-rs/tests/proof_dev.rs b/packages/tf-lang-l0-rs/tests/proof_dev.rs
new file mode 100644
index 0000000..4511d35
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/proof_dev.rs
@@ -0,0 +1,65 @@
+use serde_json::json;
+use tflang_l0::model::{Instr, Program};
+use tflang_l0::vm::interpreter::VM;
+use tflang_l0::vm::opcode::Host;
+use tflang_l0::proof::{flush, ProofTag, TransportOp};
+use tflang_l0::env::__reset_env_cache_for_tests__;
+mod util;
+use util::env::EnvVarGuard;
+
+struct DummyHost;
+
+impl Host for DummyHost {
+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"region": region, "state": state}))
+    }
+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"orig": state, "sub": substate}))
+    }
+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok("id".into()) }
+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }
+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {
+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))
+    }
+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {
+        Ok(tflang_l0::model::World(world.0.clone()))
+    }
+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }
+}
+
+fn sample_prog() -> Program {
+    Program {
+        version: "0.1".into(),
+        regs: 2,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!({}) },
+            Instr::LensProj { dst: 1, state: 0, region: "r".into() },
+            Instr::Const { dst: 0, value: json!({"x":1}) },
+            Instr::Halt,
+        ],
+    }
+}
+
+#[test]
+fn dev_proofs_toggles_tags() {
+    {
+        let _g = EnvVarGuard::set("DEV_PROOFS", "1");
+        __reset_env_cache_for_tests__();
+        let vm = VM { host: &DummyHost };
+        let _ = vm.run(&sample_prog()).unwrap();
+        let tags = flush();
+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));
+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+    }
+
+    {
+        let _g = EnvVarGuard::unset("DEV_PROOFS");
+        __reset_env_cache_for_tests__();
+        let vm = VM { host: &DummyHost };
+        let _ = vm.run(&sample_prog()).unwrap();
+        let tags = flush();
+        assert!(tags.is_empty());
+    }
+}
diff --git a/packages/tf-lang-l0-rs/tests/serde_shapes.rs b/packages/tf-lang-l0-rs/tests/serde_shapes.rs
new file mode 100644
index 0000000..e7135c4
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/serde_shapes.rs
@@ -0,0 +1,9 @@
+use serde_json::json;
+use tflang_l0::proof::{ProofTag, NormalizationTarget};
+
+#[test]
+fn proof_tag_normalization_shape() {
+    let n = ProofTag::Normalization { target: NormalizationTarget::Delta };
+    let v = serde_json::to_value(&n).unwrap();
+    assert_eq!(v, json!({"kind":"Normalization","target":"delta"}));
+}
diff --git a/packages/tf-lang-l0-rs/tests/util/env.rs b/packages/tf-lang-l0-rs/tests/util/env.rs
new file mode 100644
index 0000000..9cba035
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/util/env.rs
@@ -0,0 +1,26 @@
+use std::env;
+/// RAII guard for scoped env overrides to prevent test flakiness.
+pub struct EnvVarGuard {
+    key: String,
+    prev: Option<String>,
+}
+impl EnvVarGuard {
+    pub fn set(key: &str, val: &str) -> Self {
+        let prev = env::var(key).ok();
+        env::set_var(key, val);
+        Self { key: key.to_string(), prev }
+    }
+    pub fn unset(key: &str) -> Self {
+        let prev = env::var(key).ok();
+        env::remove_var(key);
+        Self { key: key.to_string(), prev }
+    }
+}
+impl Drop for EnvVarGuard {
+    fn drop(&mut self) {
+        match &self.prev {
+            Some(v) => env::set_var(&self.key, v),
+            None => env::remove_var(&self.key),
+        }
+    }
+}
diff --git a/packages/tf-lang-l0-rs/tests/util/mod.rs b/packages/tf-lang-l0-rs/tests/util/mod.rs
new file mode 100644
index 0000000..3d7924f
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/util/mod.rs
@@ -0,0 +1 @@
+pub mod env;
diff --git a/packages/tf-lang-l0-ts/src/index.ts b/packages/tf-lang-l0-ts/src/index.ts
index 14746e5..3588d09 100644
--- a/packages/tf-lang-l0-ts/src/index.ts
+++ b/packages/tf-lang-l0-ts/src/index.ts
@@ -5,4 +5,4 @@ export * as check from './check/index.js';
 export { canonicalJsonBytes } from './canon/json.js';
 export { blake3hex } from './canon/hash.js';
 export * as ops from './ops/index.js';
-export * as proof from './proof/tags.js';
+export * as proof from './proof/index.js';
diff --git a/packages/tf-lang-l0-ts/src/proof/index.ts b/packages/tf-lang-l0-ts/src/proof/index.ts
new file mode 100644
index 0000000..c1a33e4
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/index.ts
@@ -0,0 +1,17 @@
+export * from './tags.js';
+import type { ProofTag } from './tags.js';
+import { devProofsEnabled } from '../util/env';
+
+const log: ProofTag[] = [];
+
+export function emit(tag: ProofTag): void {
+  if (devProofsEnabled()) {
+    log.push(tag);
+  }
+}
+
+export function flush(): ProofTag[] {
+  const out = log.slice();
+  log.length = 0;
+  return out;
+}
diff --git a/packages/tf-lang-l0-ts/src/util/env.ts b/packages/tf-lang-l0-ts/src/util/env.ts
new file mode 100644
index 0000000..75bef9a
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/util/env.ts
@@ -0,0 +1,14 @@
+// Centralized, cached environment feature flags for the TS runtime.
+let _devProofs: boolean | undefined;
+export function devProofsEnabled(): boolean {
+  if (_devProofs === undefined) {
+    const v = (process.env.DEV_PROOFS || '').toLowerCase();
+    _devProofs = v === '1' || v === 'true';
+  }
+  return _devProofs;
+}
+
+// For tests only: reset the cached flag (not exported in build).
+export function __resetEnvCacheForTests__() {
+  _devProofs = undefined;
+}
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..c4b5fbe 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
+import { emit } from '../proof/index.js';
 
 export class VM {
   constructor(public host: Host) {}
@@ -41,8 +42,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +76,20 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          try {
+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          } catch (e: any) {
+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });
+            throw e;
+          }
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -91,10 +108,10 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    if (Buffer.from(a).equals(Buffer.from(b))) {
-      return null;
-    }
-    return { replace: finalState };
+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };
+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));
+    return delta;
   }
 }
 
diff --git a/packages/tf-lang-l0-ts/tests/helpers/env.ts b/packages/tf-lang-l0-ts/tests/helpers/env.ts
new file mode 100644
index 0000000..3068297
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/helpers/env.ts
@@ -0,0 +1,22 @@
+// Scoped env override for tests to avoid leaking state across parallel cases.
+export async function withEnv<T>(
+  vars: Record<string, string | undefined>,
+  fn: () => Promise<T> | T
+): Promise<T> {
+  const prev: Record<string, string | undefined> = {};
+  for (const k of Object.keys(vars)) {
+    prev[k] = process.env[k];
+    const v = vars[k];
+    if (v === undefined) delete process.env[k];
+    else process.env[k] = v;
+  }
+  try {
+    return await fn();
+  } finally {
+    for (const k of Object.keys(vars)) {
+      const v = prev[k];
+      if (v === undefined) delete process.env[k];
+      else process.env[k] = v;
+    }
+  }
+}
diff --git a/packages/tf-lang-l0-ts/tests/proof-dev.test.ts b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
new file mode 100644
index 0000000..23f3f48
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
@@ -0,0 +1,40 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { VM } from '../src/vm/index.js';
+import type { Program } from '../src/model/bytecode.js';
+import { DummyHost } from '../src/host/memory.js';
+import { flush } from '../src/proof/index.js';
+import { withEnv } from './helpers/env';
+import { __resetEnvCacheForTests__ } from '../src/util/env';
+
+describe('proof dev mode', () => {
+  afterEach(() => __resetEnvCacheForTests__());
+  const prog: Program = {
+    version: '0.1',
+    regs: 2,
+    instrs: [
+      { op: 'CONST', dst: 0, value: {} },
+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },
+      { op: 'CONST', dst: 0, value: { x: 1 } },
+      { op: 'HALT' },
+    ],
+  };
+
+  it('emits tags when DEV_PROOFS=1', async () => {
+    await withEnv({ DEV_PROOFS: '1' }, async () => {
+      const vm = new VM(DummyHost);
+      await vm.run(prog);
+      const tags = flush();
+      expect(tags.some(t => t.kind === 'Transport')).toBe(true);
+      expect(tags.some(t => t.kind === 'Witness')).toBe(true);
+    });
+  });
+
+  it('no tags when DEV_PROOFS is unset', async () => {
+    await withEnv({ DEV_PROOFS: undefined }, async () => {
+      const vm = new VM(DummyHost);
+      await vm.run(prog);
+      const tags = flush();
+      expect(tags.length).toBe(0);
+    });
+  });
+});
diff --git a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
index 73f4ae2..84020f7 100644
--- a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
+++ b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
@@ -1,5 +1,5 @@
 import { describe, it, expect } from 'vitest';
-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';
+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';
 
 describe('proof tags', () => {
   it('compile tag shapes', () => {
diff --git a/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
new file mode 100644
index 0000000..62d88ab
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
@@ -0,0 +1,17 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';
+import { withEnv } from '../helpers/env';
+
+describe('DEV_PROOFS caching (TS)', () => {
+  afterEach(() => __resetEnvCacheForTests__());
+
+  it('reads once and caches', async () => {
+    await withEnv({ DEV_PROOFS: '1' }, () => {
+      expect(devProofsEnabled()).toBe(true);
+    });
+    // Flip env but cache should hold until reset
+    await withEnv({ DEV_PROOFS: '0' }, () => {
+      expect(devProofsEnabled()).toBe(true);
+    });
+  });
+});
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T08:13:22Z","isDraft":false,"mergeStateStatus":"CLEAN","number":27,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_pfhA","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request enhances the debugging and introspection capabilities of the system by introducing \"proof tags\" that provide detailed insights into the execution flow of both TypeScript and Rust virtual machines. These tags, which capture events like state transformations, assertions, and function calls, are conditionally emitted only when a DEV_PROOFS environment variable is set, preventing performance overhead in production. The changes also include robust mechanisms for caching this environment variable and isolating its state during testing, ensuring reliable and predictable behavior across development and test environments.\n\n### Highlights\n\n* **Conditional Proof Tag Emission**: Implemented a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust runtimes, but only when the DEV_PROOFS environment variable is enabled.\n* **Performance Optimization & Test Isolation**: Introduced caching for the DEV_PROOFS flag in both runtimes to avoid repeated environment variable lookups, along with test-only reset hooks and scoped environment helpers to ensure test isolation and prevent leakage of environment state.\n* **Proof Tag Serialization Lock**: Added a test to lock the serialization shape of ProofTag::Normalization in Rust, ensuring consistency and preventing accidental breaking changes to the proof tag structure.\n* **Comprehensive Tagging**: Integrated proof tag emission into key VM operations, including lens projections/merges, assertion failures, and function call errors, as well as final witness and normalization states.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T08:13:50Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2c4bc59231ec0823937911a7c4ee1bcbb2ec0343"}},{"id":"PRR_kwDOPs5-l86_phO4","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces proof tag emission in dev mode for both Rust and TypeScript runtimes, controlled by a `DEV_PROOFS` environment variable. The changes include caching for the flag check to optimize performance and new test helpers for managing environment variables to ensure test stability. The implementation is solid, and my feedback focuses on potential performance improvements, enhancing robustness against panics in the Rust code, addressing thread-safety concerns in tests, and improving test coverage and type safety.","submittedAt":"2025-09-12T08:16:12Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2c4bc59231ec0823937911a7c4ee1bcbb2ec0343"}},{"id":"PRR_kwDOPs5-l86_phiy","author":{"login":"chatgpt-codex-connector"},"authorAssociation":"NONE","body":"Codex Review: Here are some suggestions.\n\nReply with `@codex fix comments` to fix any unresolved comments.\n\n<details> <summary>About Codex in GitHub</summary>\n\n[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment \"@codex review\". If Codex has suggestions, it will comment; otherwise it will react with 👍.\n\nCodex can also answer questions or update the PR. Try commenting \"@codex fix this CI failure\" or \"@codex address that feedback\".\n</details>","submittedAt":"2025-09-12T08:16:28Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2c4bc59231ec0823937911a7c4ee1bcbb2ec0343"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T08:14:04Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668720003/job/50215453407","name":"conformance","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:36Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453439","name":"TypeScript build & test","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:32Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215453460","name":"changed","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:14:09Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453452","name":"Rust build & test","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:47Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462938","name":"ts","startedAt":"2025-09-12T08:13:36Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:14:09Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462922","name":"rust","startedAt":"2025-09-12T08:13:38Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:33Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462872","name":"golden","startedAt":"2025-09-12T08:13:33Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"B2: emit proof tags in dev mode","updatedAt":"2025-09-12T08:37:53Z","url":"https://github.com/LexLattice/tf-lang/pull/27"}
```


---

# PR #28 — B2: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/28
- Author: @andreidita22
- Created: 2025-09-12T08:33:46Z
- Updated: 2025-09-12T08:46:27Z

## Checks
```
rust	pass	32s	https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216905757	
ts	pass	9s	https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216905721	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216905879	
Rust build & test	pass	35s	https://github.com/LexLattice/tf-lang/actions/runs/17669193725/job/50216897507	
TypeScript build & test	pass	14s	https://github.com/LexLattice/tf-lang/actions/runs/17669193725/job/50216897497	
changed	pass	5s	https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216896896	
conformance	pass	32s	https://github.com/LexLattice/tf-lang/actions/runs/17669193724/job/50216896859	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request introduces a new development-focused feature that enables the emission of detailed proof tags within both the TypeScript and Rust virtual machine runtimes. This functionality is strictly gated by the `DEV_PROOFS` environment variable, allowing developers to gain granular insights into VM operations during debugging and testing without affecting production performance. The implementation prioritizes efficiency through cached feature flag checks and ensures test reliability with robust isolation mechanisms, including thread-local logging.

### Highlights

* **Conditional Proof Tag Emission**: Introduced a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) from both TypeScript and Rust VM interpreters, exclusively when the `DEV_PROOFS` environment variable is set.
* **Performance Optimization for Feature Flag**: Implemented caching for the `DEV_PROOFS` environment variable check in both runtimes using `OnceLock` in Rust and a simple `undefined` check in TypeScript, ensuring efficient, lock-free reads after initial evaluation.
* **Enhanced Test Isolation**: Added test-only reset hooks (`__reset_env_cache_for_tests__`) and scoped environment variable helpers (`EnvVarGuard` in Rust, `withEnv` in TypeScript) to prevent environment variable leakage and ensure reliable, isolated test execution.
* **Thread-Local Proof Logging**: Configured the Rust proof log to be thread-local using `RefCell` within a `thread_local!` macro, effectively preventing cross-test interference when running tests in parallel.
* **Serialization Shape Verification**: Included a new test to specifically verify the Serde serialization shape of the `ProofTag::Normalization` variant, ensuring consistency in data representation.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	chatgpt-codex-connector
association:	none
edited:	false
status:	commented
--
Codex Review: Here are some suggestions.

Reply with `@codex fix comments` to fix any unresolved comments.

<details> <summary>About Codex in GitHub</summary>

[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment "@codex review". If Codex has suggestions, it will comment; otherwise it will react with 👍.

Codex can also answer questions or update the PR. Try commenting "@codex fix this CI failure" or "@codex address that feedback".
</details>
--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces proof tag emission in development mode for both Rust and TypeScript runtimes, controlled by a `DEV_PROOFS` environment variable. The changes include caching this flag for performance, adding test helpers for environment management, and ensuring test isolation with thread-local logging in Rust. My review focuses on improving safety, performance, and test robustness. Key points include addressing a critical data race in the Rust caching implementation, fixing a test isolation issue in the TypeScript proof logger, and suggesting performance and type safety improvements in both runtimes.
--
author:	andreidita22
association:	member
edited:	false
status:	none
--
@codex fix comments
--
author:	chatgpt-codex-connector
association:	none
edited:	false
status:	none
--
### Summary
- Reworked the TypeScript proof logger to use `AsyncLocalStorage` with an explicit `.js` env import, ensuring per-context isolation and ESM compatibility [packages/tf-lang-l0-ts/src/proof/index.tsL1-L23](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-ts/src/proof/index.ts#L1-L23)
- Updated the test environment helper to wrap execution in the proof-log context and reuse a single list of env keys for both setup and teardown loops [packages/tf-lang-l0-ts/tests/helpers/env.tsL1-L24](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-ts/tests/helpers/env.ts#L1-L24)
- Simplified delta detection with byte-wise comparison and typed normalization targets, eliminating buffer copies and unsafe casts in the TS VM interpreter [packages/tf-lang-l0-ts/src/vm/interpreter.tsL7-L10](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-ts/src/vm/interpreter.ts#L7-L10) [packages/tf-lang-l0-ts/src/vm/interpreter.tsL112-L119](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-ts/src/vm/interpreter.ts#L112-L119)
- Replaced the unsafe `static mut` flag cache with an atomic state machine and removed an unnecessary clone in the Rust VM, tightening thread safety and efficiency [packages/tf-lang-l0-rs/src/env.rsL1-L26](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-rs/src/env.rs#L1-L26) [packages/tf-lang-l0-rs/src/vm/interpreter.rsL193-L206](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-rs/src/vm/interpreter.rs#L193-L206)
- Strengthened environment-flag caching tests in both runtimes by asserting behavior after cache resets [packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.tsL1-L22](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts#L1-L22) [packages/tf-lang-l0-rs/tests/dev_proofs_flag.rsL1-L15](https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs#L1-L15)

### Testing
- ✅ `pnpm -C packages/tf-lang-l0-ts test`
- ✅ `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`

 [View task →](https://chatgpt.com/codex/tasks/task_e_68c3dc99a1a08320b8b8f66639966c1e)
--
```

## Files Changed (JSON)
```json
[{"sha":"62e0117f3dc28ea7df9f5f9aefaa969cd83d4fb8","filename":".codex/JOURNAL.md","status":"modified","additions":35,"deletions":0,"changes":35,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -500,3 +500,38 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+## [B2] Proof tag emission\n+- Start: 2025-09-11 23:00 UTC\n+- End:   2025-09-11 23:30 UTC\n+- Changes:\n+  - added DEV_PROOFS-gated proof log in TS and Rust\n+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags\n+  - tests cover tag emission toggled by DEV_PROOFS\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests passed\n+## [B2-polish] Cache DEV_PROOFS\n+- Start: 2025-09-11 23:40 UTC\n+- End:   2025-09-11 23:55 UTC\n+- Changes:\n+  - centralized cached DEV_PROOFS flag in TS and Rust runtimes\n+  - scoped env helpers for tests and JSON shape lock\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - pnpm -C packages/tf-lang-l0-ts vectors\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests and vectors passed\n+## [B2-polish2] Lock-free env flag & thread-local proof log\n+- Start: 2025-09-11 23:55 UTC\n+- End:   2025-09-12 00:05 UTC\n+- Changes:\n+  - switched Rust DEV_PROOFS cache to OnceCell<bool> for lock-free reads\n+  - moved proof log to thread-local RefCell to isolate parallel tests\n+- Verification:\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+  - pnpm -C packages/tf-lang-l0-ts test\n+- Results:\n+  - tests passed"},{"sha":"e53c409a9b2325a204867559b30146c8638a946e","filename":".codex/LESSONS.md","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -18,3 +18,6 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-11] Rule: \"Proof tags emitted only when DEV_PROOFS=1.\" Guardrail: proof:dev_flag\n+- [B2-polish][2025-09-11] Rule: \"Cache feature flags; tests use scoped env guards.\" Guardrail: proof:env_cache\n+- [B2-polish2][2025-09-11] Rule: \"Proof logs are thread-local; avoid cross-test interference.\" Guardrail: proof:thread_local_log"},{"sha":"d15db569325eef38e564861509f191dee9687288","filename":".codex/polish/B2.md","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,2 @@\n+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.\n+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'."},{"sha":"c434bdd3898e1ed0286eada6f934fb1588576103","filename":".codex/self-plans/B2.md","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,25 @@\n+# Plan for B2\n+\n+## Steps\n+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.\n+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.\n+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.\n+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.\n+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.\n+6. Add Rust tests ensuring tags are emitted only in dev mode.\n+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.\n+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.\n+\n+## Tests\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks\n+- Environment variable may leak between tests; ensure logs are flushed and variables reset.\n+- Synchronizing tag structures across runtimes might be inconsistent.\n+- Adding dependency `once_cell` for Rust logging could impact build.\n+\n+## Definition of Done\n+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.\n+- Tests cover presence and absence of tags.\n+- Journal updated and repository tests pass."},{"sha":"307911ddff06feca12c7c48e4d09cc0328542053","filename":"packages/tf-lang-l0-rs/Cargo.lock","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2FCargo.lock","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2FCargo.lock","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.lock?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -79,6 +79,12 @@ version = \"2.7.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0\"\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.21.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n+\n [[package]]\n name = \"pretty_assertions\"\n version = \"1.4.1\"\n@@ -168,6 +174,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"blake3\",\n+ \"once_cell\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\","},{"sha":"b007053d53a73ac579af68fc9155f1a7f3582a7f","filename":"packages/tf-lang-l0-rs/Cargo.toml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2FCargo.toml","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2FCargo.toml","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.toml?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -17,6 +17,7 @@ thiserror = \"1\"\n serde = { version = \"1\", features = [\"derive\"] }\n serde_json = \"1\"\n blake3 = \"1.5\"\n+once_cell = \"1\"\n \n [dev-dependencies]\n pretty_assertions = \"1\""},{"sha":"e3dd2784e05ea65602ec2d0e64003686c7baca1c","filename":"packages/tf-lang-l0-rs/src/env.rs","status":"added","additions":20,"deletions":0,"changes":20,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,20 @@\n+use std::sync::OnceLock;\n+/// Centralized, cached environment feature flags for the Rust runtime.\n+static mut DEV_PROOFS: OnceLock<bool> = OnceLock::new();\n+\n+pub fn dev_proofs_enabled() -> bool {\n+    unsafe {\n+        *DEV_PROOFS.get_or_init(|| {\n+            std::env::var(\"DEV_PROOFS\")\n+                .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n+                .unwrap_or(false)\n+        })\n+    }\n+}\n+\n+/// TESTS ONLY: clear cached flags\n+pub fn __reset_env_cache_for_tests__() {\n+    unsafe {\n+        DEV_PROOFS.take();\n+    }\n+}"},{"sha":"ab13c3a315c661decb26bcb84eee7fe03b93a727","filename":"packages/tf-lang-l0-rs/src/lib.rs","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -5,5 +5,6 @@ pub mod util;\n pub mod vm;\n pub mod ops;\n pub mod proof;\n+pub mod env;\n \n // Avoid glob re-exports at crate root to prevent ambiguous names (e.g., `types`)."},{"sha":"c38df65501effd590880449d4844015de643ffe8","filename":"packages/tf-lang-l0-rs/src/proof.rs","status":"modified","additions":21,"deletions":0,"changes":21,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -42,3 +42,24 @@ pub enum ProofTag {\n     Refutation { code: String, msg: Option<String> },\n     Conservativity { callee: String, expected: String, found: String },\n }\n+\n+use crate::env::dev_proofs_enabled;\n+use std::cell::RefCell;\n+\n+thread_local! {\n+    /// Thread-local proof log to avoid cross-test interference under parallel runs.\n+    static PROOF_LOG: RefCell<Vec<ProofTag>> = RefCell::new(Vec::new());\n+}\n+\n+pub fn emit(tag: ProofTag) {\n+    if dev_proofs_enabled() {\n+        PROOF_LOG.with(|log| log.borrow_mut().push(tag));\n+    }\n+}\n+\n+pub fn flush() -> Vec<ProofTag> {\n+    PROOF_LOG.with(|log| {\n+        let mut v = log.borrow_mut();\n+        v.drain(..).collect()\n+    })\n+}"},{"sha":"383cd8315c311ce7237e43987f2b54a194b3618b","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":22,"deletions":7,"changes":29,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n use crate::vm::opcode::Host;\n+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n@@ -37,6 +38,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        emit(ProofTag::Refutation { code: \"ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -97,6 +99,7 @@ impl<'h> VM<'h> {\n                 }\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });\n                     regs[*dst as usize] = sub;\n                 }\n                 Instr::LensMerge {\n@@ -105,9 +108,10 @@ impl<'h> VM<'h> {\n                     region,\n                     sub,\n                 } => {\n-                    let merged =\n-                        self.host\n-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    let merged = self\n+                        .host\n+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });\n                     regs[*dst as usize] = merged;\n                 }\n                 Instr::PlanSim {\n@@ -173,7 +177,10 @@ impl<'h> VM<'h> {\n                     for r in args {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n-                    let out = self.host.call_tf(tf_id, &a)?;\n+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {\n+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: \"ok\".into(), found: format!(\"{}\", e) });\n+                        e\n+                    })?;\n                     regs[*dst as usize] = out;\n                 }\n             }\n@@ -184,10 +191,18 @@ impl<'h> VM<'h> {\n         }\n \n         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);\n-        let out = if final_state == initial_state {\n-            serde_json::Value::Null\n+        let delta = if final_state == initial_state {\n+            None\n         } else {\n-            serde_json::json!({ \"replace\": final_state })\n+            Some(Replace { replace: final_state.clone() })\n+        };\n+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });\n+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {\n+            emit(ProofTag::Normalization { target });\n+        }\n+        let out = match delta {\n+            None => serde_json::Value::Null,\n+            Some(d) => serde_json::json!({ \"replace\": d.replace }),\n         };\n \n         Ok(out)"},{"sha":"3ddfa82431a985165e6089ea253238944ad28d4d","filename":"packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs","status":"added","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,14 @@\n+use tflang_l0::env::{dev_proofs_enabled, __reset_env_cache_for_tests__};\n+mod util;\n+use util::env::EnvVarGuard;\n+\n+#[test]\n+fn dev_proofs_is_cached() {\n+    let _g = EnvVarGuard::set(\"DEV_PROOFS\", \"1\");\n+    assert!(dev_proofs_enabled());\n+    drop(_g); // restore\n+    // Flip env, but cache should hold until reset\n+    let _g2 = EnvVarGuard::unset(\"DEV_PROOFS\");\n+    assert!(dev_proofs_enabled());\n+    __reset_env_cache_for_tests__();\n+}"},{"sha":"4511d3589314cff38393ceb588856ed787201202","filename":"packages/tf-lang-l0-rs/tests/proof_dev.rs","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,65 @@\n+use serde_json::json;\n+use tflang_l0::model::{Instr, Program};\n+use tflang_l0::vm::interpreter::VM;\n+use tflang_l0::vm::opcode::Host;\n+use tflang_l0::proof::{flush, ProofTag, TransportOp};\n+use tflang_l0::env::__reset_env_cache_for_tests__;\n+mod util;\n+use util::env::EnvVarGuard;\n+\n+struct DummyHost;\n+\n+impl Host for DummyHost {\n+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"region\": region, \"state\": state}))\n+    }\n+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"orig\": state, \"sub\": substate}))\n+    }\n+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok(\"id\".into()) }\n+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }\n+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {\n+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))\n+    }\n+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {\n+        Ok(tflang_l0::model::World(world.0.clone()))\n+    }\n+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }\n+}\n+\n+fn sample_prog() -> Program {\n+    Program {\n+        version: \"0.1\".into(),\n+        regs: 2,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!({}) },\n+            Instr::LensProj { dst: 1, state: 0, region: \"r\".into() },\n+            Instr::Const { dst: 0, value: json!({\"x\":1}) },\n+            Instr::Halt,\n+        ],\n+    }\n+}\n+\n+#[test]\n+fn dev_proofs_toggles_tags() {\n+    {\n+        let _g = EnvVarGuard::set(\"DEV_PROOFS\", \"1\");\n+        __reset_env_cache_for_tests__();\n+        let vm = VM { host: &DummyHost };\n+        let _ = vm.run(&sample_prog()).unwrap();\n+        let tags = flush();\n+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));\n+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+    }\n+\n+    {\n+        let _g = EnvVarGuard::unset(\"DEV_PROOFS\");\n+        __reset_env_cache_for_tests__();\n+        let vm = VM { host: &DummyHost };\n+        let _ = vm.run(&sample_prog()).unwrap();\n+        let tags = flush();\n+        assert!(tags.is_empty());\n+    }\n+}"},{"sha":"e7135c4554bacb94f0c4ecb3699e20f522a94255","filename":"packages/tf-lang-l0-rs/tests/serde_shapes.rs","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,9 @@\n+use serde_json::json;\n+use tflang_l0::proof::{ProofTag, NormalizationTarget};\n+\n+#[test]\n+fn proof_tag_normalization_shape() {\n+    let n = ProofTag::Normalization { target: NormalizationTarget::Delta };\n+    let v = serde_json::to_value(&n).unwrap();\n+    assert_eq!(v, json!({\"kind\":\"Normalization\",\"target\":\"delta\"}));\n+}"},{"sha":"9cba035c9eed08e7cc0ecb0a763e824bb872178b","filename":"packages/tf-lang-l0-rs/tests/util/env.rs","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,26 @@\n+use std::env;\n+/// RAII guard for scoped env overrides to prevent test flakiness.\n+pub struct EnvVarGuard {\n+    key: String,\n+    prev: Option<String>,\n+}\n+impl EnvVarGuard {\n+    pub fn set(key: &str, val: &str) -> Self {\n+        let prev = env::var(key).ok();\n+        env::set_var(key, val);\n+        Self { key: key.to_string(), prev }\n+    }\n+    pub fn unset(key: &str) -> Self {\n+        let prev = env::var(key).ok();\n+        env::remove_var(key);\n+        Self { key: key.to_string(), prev }\n+    }\n+}\n+impl Drop for EnvVarGuard {\n+    fn drop(&mut self) {\n+        match &self.prev {\n+            Some(v) => env::set_var(&self.key, v),\n+            None => env::remove_var(&self.key),\n+        }\n+    }\n+}"},{"sha":"3d7924f6ab50a87d6c5d6e3418d3f1a9242f5681","filename":"packages/tf-lang-l0-rs/tests/util/mod.rs","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1 @@\n+pub mod env;"},{"sha":"3588d098e018b666f5b502857717d14bbccb5a2b","filename":"packages/tf-lang-l0-ts/src/index.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -5,4 +5,4 @@ export * as check from './check/index.js';\n export { canonicalJsonBytes } from './canon/json.js';\n export { blake3hex } from './canon/hash.js';\n export * as ops from './ops/index.js';\n-export * as proof from './proof/tags.js';\n+export * as proof from './proof/index.js';"},{"sha":"c1a33e47d7703f5707f2511da83bfc1f37464530","filename":"packages/tf-lang-l0-ts/src/proof/index.ts","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,17 @@\n+export * from './tags.js';\n+import type { ProofTag } from './tags.js';\n+import { devProofsEnabled } from '../util/env';\n+\n+const log: ProofTag[] = [];\n+\n+export function emit(tag: ProofTag): void {\n+  if (devProofsEnabled()) {\n+    log.push(tag);\n+  }\n+}\n+\n+export function flush(): ProofTag[] {\n+  const out = log.slice();\n+  log.length = 0;\n+  return out;\n+}"},{"sha":"75bef9afb9e0a1e622e378ab97d873986825c172","filename":"packages/tf-lang-l0-ts/src/util/env.ts","status":"added","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,14 @@\n+// Centralized, cached environment feature flags for the TS runtime.\n+let _devProofs: boolean | undefined;\n+export function devProofsEnabled(): boolean {\n+  if (_devProofs === undefined) {\n+    const v = (process.env.DEV_PROOFS || '').toLowerCase();\n+    _devProofs = v === '1' || v === 'true';\n+  }\n+  return _devProofs;\n+}\n+\n+// For tests only: reset the cached flag (not exported in build).\n+export function __resetEnvCacheForTests__() {\n+  _devProofs = undefined;\n+}"},{"sha":"c4b5fbe67565531cf1db48186290f87fc5a36451","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n+import { emit } from '../proof/index.js';\n \n export class VM {\n   constructor(public host: Host) {}\n@@ -41,8 +42,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +76,20 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          try {\n+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          } catch (e: any) {\n+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });\n+            throw e;\n+          }\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -91,10 +108,10 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    if (Buffer.from(a).equals(Buffer.from(b))) {\n-      return null;\n-    }\n-    return { replace: finalState };\n+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };\n+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));\n+    return delta;\n   }\n }\n "},{"sha":"306829767c2d96bf5c067c3bf147525e96ecbfe4","filename":"packages/tf-lang-l0-ts/tests/helpers/env.ts","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,22 @@\n+// Scoped env override for tests to avoid leaking state across parallel cases.\n+export async function withEnv<T>(\n+  vars: Record<string, string | undefined>,\n+  fn: () => Promise<T> | T\n+): Promise<T> {\n+  const prev: Record<string, string | undefined> = {};\n+  for (const k of Object.keys(vars)) {\n+    prev[k] = process.env[k];\n+    const v = vars[k];\n+    if (v === undefined) delete process.env[k];\n+    else process.env[k] = v;\n+  }\n+  try {\n+    return await fn();\n+  } finally {\n+    for (const k of Object.keys(vars)) {\n+      const v = prev[k];\n+      if (v === undefined) delete process.env[k];\n+      else process.env[k] = v;\n+    }\n+  }\n+}"},{"sha":"23f3f48412dd2eae26e5b46ea16215db2b9e3957","filename":"packages/tf-lang-l0-ts/tests/proof-dev.test.ts","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,40 @@\n+import { describe, it, expect, afterEach } from 'vitest';\n+import { VM } from '../src/vm/index.js';\n+import type { Program } from '../src/model/bytecode.js';\n+import { DummyHost } from '../src/host/memory.js';\n+import { flush } from '../src/proof/index.js';\n+import { withEnv } from './helpers/env';\n+import { __resetEnvCacheForTests__ } from '../src/util/env';\n+\n+describe('proof dev mode', () => {\n+  afterEach(() => __resetEnvCacheForTests__());\n+  const prog: Program = {\n+    version: '0.1',\n+    regs: 2,\n+    instrs: [\n+      { op: 'CONST', dst: 0, value: {} },\n+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },\n+      { op: 'CONST', dst: 0, value: { x: 1 } },\n+      { op: 'HALT' },\n+    ],\n+  };\n+\n+  it('emits tags when DEV_PROOFS=1', async () => {\n+    await withEnv({ DEV_PROOFS: '1' }, async () => {\n+      const vm = new VM(DummyHost);\n+      await vm.run(prog);\n+      const tags = flush();\n+      expect(tags.some(t => t.kind === 'Transport')).toBe(true);\n+      expect(tags.some(t => t.kind === 'Witness')).toBe(true);\n+    });\n+  });\n+\n+  it('no tags when DEV_PROOFS is unset', async () => {\n+    await withEnv({ DEV_PROOFS: undefined }, async () => {\n+      const vm = new VM(DummyHost);\n+      await vm.run(prog);\n+      const tags = flush();\n+      expect(tags.length).toBe(0);\n+    });\n+  });\n+});"},{"sha":"84020f7a6fb48f42653c12ed963f928fe34b852f","filename":"packages/tf-lang-l0-ts/tests/proof-tags.test.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -1,5 +1,5 @@\n import { describe, it, expect } from 'vitest';\n-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';\n+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';\n \n describe('proof tags', () => {\n   it('compile tag shapes', () => {"},{"sha":"62d88abc4ef50fd6aac5bc6cfa6b467f8d9b9ba3","filename":"packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts?ref=cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f","patch":"@@ -0,0 +1,17 @@\n+import { describe, it, expect, afterEach } from 'vitest';\n+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';\n+import { withEnv } from '../helpers/env';\n+\n+describe('DEV_PROOFS caching (TS)', () => {\n+  afterEach(() => __resetEnvCacheForTests__());\n+\n+  it('reads once and caches', async () => {\n+    await withEnv({ DEV_PROOFS: '1' }, () => {\n+      expect(devProofsEnabled()).toBe(true);\n+    });\n+    // Flip env but cache should hold until reset\n+    await withEnv({ DEV_PROOFS: '0' }, () => {\n+      expect(devProofsEnabled()).toBe(true);\n+    });\n+  });\n+});"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..62e0117 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,38 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+## [B2] Proof tag emission
+- Start: 2025-09-11 23:00 UTC
+- End:   2025-09-11 23:30 UTC
+- Changes:
+  - added DEV_PROOFS-gated proof log in TS and Rust
+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags
+  - tests cover tag emission toggled by DEV_PROOFS
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests passed
+## [B2-polish] Cache DEV_PROOFS
+- Start: 2025-09-11 23:40 UTC
+- End:   2025-09-11 23:55 UTC
+- Changes:
+  - centralized cached DEV_PROOFS flag in TS and Rust runtimes
+  - scoped env helpers for tests and JSON shape lock
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - pnpm -C packages/tf-lang-l0-ts vectors
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests and vectors passed
+## [B2-polish2] Lock-free env flag & thread-local proof log
+- Start: 2025-09-11 23:55 UTC
+- End:   2025-09-12 00:05 UTC
+- Changes:
+  - switched Rust DEV_PROOFS cache to OnceCell<bool> for lock-free reads
+  - moved proof log to thread-local RefCell to isolate parallel tests
+- Verification:
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+  - pnpm -C packages/tf-lang-l0-ts test
+- Results:
+  - tests passed
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..e53c409 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,6 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-11] Rule: "Proof tags emitted only when DEV_PROOFS=1." Guardrail: proof:dev_flag
+- [B2-polish][2025-09-11] Rule: "Cache feature flags; tests use scoped env guards." Guardrail: proof:env_cache
+- [B2-polish2][2025-09-11] Rule: "Proof logs are thread-local; avoid cross-test interference." Guardrail: proof:thread_local_log
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..d15db56
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1,2 @@
+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.
+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..c434bdd
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,25 @@
+# Plan for B2
+
+## Steps
+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.
+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.
+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.
+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.
+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.
+6. Add Rust tests ensuring tags are emitted only in dev mode.
+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.
+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.
+
+## Tests
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks
+- Environment variable may leak between tests; ensure logs are flushed and variables reset.
+- Synchronizing tag structures across runtimes might be inconsistent.
+- Adding dependency `once_cell` for Rust logging could impact build.
+
+## Definition of Done
+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.
+- Tests cover presence and absence of tags.
+- Journal updated and repository tests pass.
diff --git a/packages/tf-lang-l0-rs/Cargo.lock b/packages/tf-lang-l0-rs/Cargo.lock
index 485414a..307911d 100644
--- a/packages/tf-lang-l0-rs/Cargo.lock
+++ b/packages/tf-lang-l0-rs/Cargo.lock
@@ -79,6 +79,12 @@ version = "2.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
 
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
 [[package]]
 name = "pretty_assertions"
 version = "1.4.1"
@@ -168,6 +174,7 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "blake3",
+ "once_cell",
  "pretty_assertions",
  "serde",
  "serde_json",
diff --git a/packages/tf-lang-l0-rs/Cargo.toml b/packages/tf-lang-l0-rs/Cargo.toml
index 253a2b2..b007053 100644
--- a/packages/tf-lang-l0-rs/Cargo.toml
+++ b/packages/tf-lang-l0-rs/Cargo.toml
@@ -17,6 +17,7 @@ thiserror = "1"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 blake3 = "1.5"
+once_cell = "1"
 
 [dev-dependencies]
 pretty_assertions = "1"
diff --git a/packages/tf-lang-l0-rs/src/env.rs b/packages/tf-lang-l0-rs/src/env.rs
new file mode 100644
index 0000000..e3dd278
--- /dev/null
+++ b/packages/tf-lang-l0-rs/src/env.rs
@@ -0,0 +1,20 @@
+use std::sync::OnceLock;
+/// Centralized, cached environment feature flags for the Rust runtime.
+static mut DEV_PROOFS: OnceLock<bool> = OnceLock::new();
+
+pub fn dev_proofs_enabled() -> bool {
+    unsafe {
+        *DEV_PROOFS.get_or_init(|| {
+            std::env::var("DEV_PROOFS")
+                .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
+                .unwrap_or(false)
+        })
+    }
+}
+
+/// TESTS ONLY: clear cached flags
+pub fn __reset_env_cache_for_tests__() {
+    unsafe {
+        DEV_PROOFS.take();
+    }
+}
diff --git a/packages/tf-lang-l0-rs/src/lib.rs b/packages/tf-lang-l0-rs/src/lib.rs
index a0a116d..ab13c3a 100644
--- a/packages/tf-lang-l0-rs/src/lib.rs
+++ b/packages/tf-lang-l0-rs/src/lib.rs
@@ -5,5 +5,6 @@ pub mod util;
 pub mod vm;
 pub mod ops;
 pub mod proof;
+pub mod env;
 
 // Avoid glob re-exports at crate root to prevent ambiguous names (e.g., `types`).
diff --git a/packages/tf-lang-l0-rs/src/proof.rs b/packages/tf-lang-l0-rs/src/proof.rs
index 4a4ea5e..c38df65 100644
--- a/packages/tf-lang-l0-rs/src/proof.rs
+++ b/packages/tf-lang-l0-rs/src/proof.rs
@@ -42,3 +42,24 @@ pub enum ProofTag {
     Refutation { code: String, msg: Option<String> },
     Conservativity { callee: String, expected: String, found: String },
 }
+
+use crate::env::dev_proofs_enabled;
+use std::cell::RefCell;
+
+thread_local! {
+    /// Thread-local proof log to avoid cross-test interference under parallel runs.
+    static PROOF_LOG: RefCell<Vec<ProofTag>> = RefCell::new(Vec::new());
+}
+
+pub fn emit(tag: ProofTag) {
+    if dev_proofs_enabled() {
+        PROOF_LOG.with(|log| log.borrow_mut().push(tag));
+    }
+}
+
+pub fn flush() -> Vec<ProofTag> {
+    PROOF_LOG.with(|log| {
+        let mut v = log.borrow_mut();
+        v.drain(..).collect()
+    })
+}
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..383cd83 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
 use crate::vm::opcode::Host;
+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
@@ -37,6 +38,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        emit(ProofTag::Refutation { code: "ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -97,6 +99,7 @@ impl<'h> VM<'h> {
                 }
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });
                     regs[*dst as usize] = sub;
                 }
                 Instr::LensMerge {
@@ -105,9 +108,10 @@ impl<'h> VM<'h> {
                     region,
                     sub,
                 } => {
-                    let merged =
-                        self.host
-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    let merged = self
+                        .host
+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });
                     regs[*dst as usize] = merged;
                 }
                 Instr::PlanSim {
@@ -173,7 +177,10 @@ impl<'h> VM<'h> {
                     for r in args {
                         a.push(get(*r, &regs)?.clone());
                     }
-                    let out = self.host.call_tf(tf_id, &a)?;
+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {
+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: "ok".into(), found: format!("{}", e) });
+                        e
+                    })?;
                     regs[*dst as usize] = out;
                 }
             }
@@ -184,10 +191,18 @@ impl<'h> VM<'h> {
         }
 
         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);
-        let out = if final_state == initial_state {
-            serde_json::Value::Null
+        let delta = if final_state == initial_state {
+            None
         } else {
-            serde_json::json!({ "replace": final_state })
+            Some(Replace { replace: final_state.clone() })
+        };
+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });
+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {
+            emit(ProofTag::Normalization { target });
+        }
+        let out = match delta {
+            None => serde_json::Value::Null,
+            Some(d) => serde_json::json!({ "replace": d.replace }),
         };
 
         Ok(out)
diff --git a/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
new file mode 100644
index 0000000..3ddfa82
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
@@ -0,0 +1,14 @@
+use tflang_l0::env::{dev_proofs_enabled, __reset_env_cache_for_tests__};
+mod util;
+use util::env::EnvVarGuard;
+
+#[test]
+fn dev_proofs_is_cached() {
+    let _g = EnvVarGuard::set("DEV_PROOFS", "1");
+    assert!(dev_proofs_enabled());
+    drop(_g); // restore
+    // Flip env, but cache should hold until reset
+    let _g2 = EnvVarGuard::unset("DEV_PROOFS");
+    assert!(dev_proofs_enabled());
+    __reset_env_cache_for_tests__();
+}
diff --git a/packages/tf-lang-l0-rs/tests/proof_dev.rs b/packages/tf-lang-l0-rs/tests/proof_dev.rs
new file mode 100644
index 0000000..4511d35
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/proof_dev.rs
@@ -0,0 +1,65 @@
+use serde_json::json;
+use tflang_l0::model::{Instr, Program};
+use tflang_l0::vm::interpreter::VM;
+use tflang_l0::vm::opcode::Host;
+use tflang_l0::proof::{flush, ProofTag, TransportOp};
+use tflang_l0::env::__reset_env_cache_for_tests__;
+mod util;
+use util::env::EnvVarGuard;
+
+struct DummyHost;
+
+impl Host for DummyHost {
+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"region": region, "state": state}))
+    }
+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"orig": state, "sub": substate}))
+    }
+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok("id".into()) }
+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }
+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {
+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))
+    }
+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {
+        Ok(tflang_l0::model::World(world.0.clone()))
+    }
+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }
+}
+
+fn sample_prog() -> Program {
+    Program {
+        version: "0.1".into(),
+        regs: 2,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!({}) },
+            Instr::LensProj { dst: 1, state: 0, region: "r".into() },
+            Instr::Const { dst: 0, value: json!({"x":1}) },
+            Instr::Halt,
+        ],
+    }
+}
+
+#[test]
+fn dev_proofs_toggles_tags() {
+    {
+        let _g = EnvVarGuard::set("DEV_PROOFS", "1");
+        __reset_env_cache_for_tests__();
+        let vm = VM { host: &DummyHost };
+        let _ = vm.run(&sample_prog()).unwrap();
+        let tags = flush();
+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));
+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+    }
+
+    {
+        let _g = EnvVarGuard::unset("DEV_PROOFS");
+        __reset_env_cache_for_tests__();
+        let vm = VM { host: &DummyHost };
+        let _ = vm.run(&sample_prog()).unwrap();
+        let tags = flush();
+        assert!(tags.is_empty());
+    }
+}
diff --git a/packages/tf-lang-l0-rs/tests/serde_shapes.rs b/packages/tf-lang-l0-rs/tests/serde_shapes.rs
new file mode 100644
index 0000000..e7135c4
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/serde_shapes.rs
@@ -0,0 +1,9 @@
+use serde_json::json;
+use tflang_l0::proof::{ProofTag, NormalizationTarget};
+
+#[test]
+fn proof_tag_normalization_shape() {
+    let n = ProofTag::Normalization { target: NormalizationTarget::Delta };
+    let v = serde_json::to_value(&n).unwrap();
+    assert_eq!(v, json!({"kind":"Normalization","target":"delta"}));
+}
diff --git a/packages/tf-lang-l0-rs/tests/util/env.rs b/packages/tf-lang-l0-rs/tests/util/env.rs
new file mode 100644
index 0000000..9cba035
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/util/env.rs
@@ -0,0 +1,26 @@
+use std::env;
+/// RAII guard for scoped env overrides to prevent test flakiness.
+pub struct EnvVarGuard {
+    key: String,
+    prev: Option<String>,
+}
+impl EnvVarGuard {
+    pub fn set(key: &str, val: &str) -> Self {
+        let prev = env::var(key).ok();
+        env::set_var(key, val);
+        Self { key: key.to_string(), prev }
+    }
+    pub fn unset(key: &str) -> Self {
+        let prev = env::var(key).ok();
+        env::remove_var(key);
+        Self { key: key.to_string(), prev }
+    }
+}
+impl Drop for EnvVarGuard {
+    fn drop(&mut self) {
+        match &self.prev {
+            Some(v) => env::set_var(&self.key, v),
+            None => env::remove_var(&self.key),
+        }
+    }
+}
diff --git a/packages/tf-lang-l0-rs/tests/util/mod.rs b/packages/tf-lang-l0-rs/tests/util/mod.rs
new file mode 100644
index 0000000..3d7924f
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/util/mod.rs
@@ -0,0 +1 @@
+pub mod env;
diff --git a/packages/tf-lang-l0-ts/src/index.ts b/packages/tf-lang-l0-ts/src/index.ts
index 14746e5..3588d09 100644
--- a/packages/tf-lang-l0-ts/src/index.ts
+++ b/packages/tf-lang-l0-ts/src/index.ts
@@ -5,4 +5,4 @@ export * as check from './check/index.js';
 export { canonicalJsonBytes } from './canon/json.js';
 export { blake3hex } from './canon/hash.js';
 export * as ops from './ops/index.js';
-export * as proof from './proof/tags.js';
+export * as proof from './proof/index.js';
diff --git a/packages/tf-lang-l0-ts/src/proof/index.ts b/packages/tf-lang-l0-ts/src/proof/index.ts
new file mode 100644
index 0000000..c1a33e4
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/index.ts
@@ -0,0 +1,17 @@
+export * from './tags.js';
+import type { ProofTag } from './tags.js';
+import { devProofsEnabled } from '../util/env';
+
+const log: ProofTag[] = [];
+
+export function emit(tag: ProofTag): void {
+  if (devProofsEnabled()) {
+    log.push(tag);
+  }
+}
+
+export function flush(): ProofTag[] {
+  const out = log.slice();
+  log.length = 0;
+  return out;
+}
diff --git a/packages/tf-lang-l0-ts/src/util/env.ts b/packages/tf-lang-l0-ts/src/util/env.ts
new file mode 100644
index 0000000..75bef9a
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/util/env.ts
@@ -0,0 +1,14 @@
+// Centralized, cached environment feature flags for the TS runtime.
+let _devProofs: boolean | undefined;
+export function devProofsEnabled(): boolean {
+  if (_devProofs === undefined) {
+    const v = (process.env.DEV_PROOFS || '').toLowerCase();
+    _devProofs = v === '1' || v === 'true';
+  }
+  return _devProofs;
+}
+
+// For tests only: reset the cached flag (not exported in build).
+export function __resetEnvCacheForTests__() {
+  _devProofs = undefined;
+}
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..c4b5fbe 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
+import { emit } from '../proof/index.js';
 
 export class VM {
   constructor(public host: Host) {}
@@ -41,8 +42,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +76,20 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          try {
+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          } catch (e: any) {
+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });
+            throw e;
+          }
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -91,10 +108,10 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    if (Buffer.from(a).equals(Buffer.from(b))) {
-      return null;
-    }
-    return { replace: finalState };
+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };
+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));
+    return delta;
   }
 }
 
diff --git a/packages/tf-lang-l0-ts/tests/helpers/env.ts b/packages/tf-lang-l0-ts/tests/helpers/env.ts
new file mode 100644
index 0000000..3068297
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/helpers/env.ts
@@ -0,0 +1,22 @@
+// Scoped env override for tests to avoid leaking state across parallel cases.
+export async function withEnv<T>(
+  vars: Record<string, string | undefined>,
+  fn: () => Promise<T> | T
+): Promise<T> {
+  const prev: Record<string, string | undefined> = {};
+  for (const k of Object.keys(vars)) {
+    prev[k] = process.env[k];
+    const v = vars[k];
+    if (v === undefined) delete process.env[k];
+    else process.env[k] = v;
+  }
+  try {
+    return await fn();
+  } finally {
+    for (const k of Object.keys(vars)) {
+      const v = prev[k];
+      if (v === undefined) delete process.env[k];
+      else process.env[k] = v;
+    }
+  }
+}
diff --git a/packages/tf-lang-l0-ts/tests/proof-dev.test.ts b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
new file mode 100644
index 0000000..23f3f48
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
@@ -0,0 +1,40 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { VM } from '../src/vm/index.js';
+import type { Program } from '../src/model/bytecode.js';
+import { DummyHost } from '../src/host/memory.js';
+import { flush } from '../src/proof/index.js';
+import { withEnv } from './helpers/env';
+import { __resetEnvCacheForTests__ } from '../src/util/env';
+
+describe('proof dev mode', () => {
+  afterEach(() => __resetEnvCacheForTests__());
+  const prog: Program = {
+    version: '0.1',
+    regs: 2,
+    instrs: [
+      { op: 'CONST', dst: 0, value: {} },
+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },
+      { op: 'CONST', dst: 0, value: { x: 1 } },
+      { op: 'HALT' },
+    ],
+  };
+
+  it('emits tags when DEV_PROOFS=1', async () => {
+    await withEnv({ DEV_PROOFS: '1' }, async () => {
+      const vm = new VM(DummyHost);
+      await vm.run(prog);
+      const tags = flush();
+      expect(tags.some(t => t.kind === 'Transport')).toBe(true);
+      expect(tags.some(t => t.kind === 'Witness')).toBe(true);
+    });
+  });
+
+  it('no tags when DEV_PROOFS is unset', async () => {
+    await withEnv({ DEV_PROOFS: undefined }, async () => {
+      const vm = new VM(DummyHost);
+      await vm.run(prog);
+      const tags = flush();
+      expect(tags.length).toBe(0);
+    });
+  });
+});
diff --git a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
index 73f4ae2..84020f7 100644
--- a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
+++ b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
@@ -1,5 +1,5 @@
 import { describe, it, expect } from 'vitest';
-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';
+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';
 
 describe('proof tags', () => {
   it('compile tag shapes', () => {
diff --git a/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
new file mode 100644
index 0000000..62d88ab
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
@@ -0,0 +1,17 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';
+import { withEnv } from '../helpers/env';
+
+describe('DEV_PROOFS caching (TS)', () => {
+  afterEach(() => __resetEnvCacheForTests__());
+
+  it('reads once and caches', async () => {
+    await withEnv({ DEV_PROOFS: '1' }, () => {
+      expect(devProofsEnabled()).toBe(true);
+    });
+    // Flip env but cache should hold until reset
+    await withEnv({ DEV_PROOFS: '0' }, () => {
+      expect(devProofsEnabled()).toBe(true);
+    });
+  });
+});
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T08:33:46Z","isDraft":false,"mergeStateStatus":"CLEAN","number":28,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_pyqq","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request introduces a new development-focused feature that enables the emission of detailed proof tags within both the TypeScript and Rust virtual machine runtimes. This functionality is strictly gated by the `DEV_PROOFS` environment variable, allowing developers to gain granular insights into VM operations during debugging and testing without affecting production performance. The implementation prioritizes efficiency through cached feature flag checks and ensures test reliability with robust isolation mechanisms, including thread-local logging.\n\n### Highlights\n\n* **Conditional Proof Tag Emission**: Introduced a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) from both TypeScript and Rust VM interpreters, exclusively when the `DEV_PROOFS` environment variable is set.\n* **Performance Optimization for Feature Flag**: Implemented caching for the `DEV_PROOFS` environment variable check in both runtimes using `OnceLock` in Rust and a simple `undefined` check in TypeScript, ensuring efficient, lock-free reads after initial evaluation.\n* **Enhanced Test Isolation**: Added test-only reset hooks (`__reset_env_cache_for_tests__`) and scoped environment variable helpers (`EnvVarGuard` in Rust, `withEnv` in TypeScript) to prevent environment variable leakage and ensure reliable, isolated test execution.\n* **Thread-Local Proof Logging**: Configured the Rust proof log to be thread-local using `RefCell` within a `thread_local!` macro, effectively preventing cross-test interference when running tests in parallel.\n* **Serialization Shape Verification**: Included a new test to specifically verify the Serde serialization shape of the `ProofTag::Normalization` variant, ensuring consistency in data representation.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T08:34:15Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f"}},{"id":"PRR_kwDOPs5-l86_p2hG","author":{"login":"chatgpt-codex-connector"},"authorAssociation":"NONE","body":"Codex Review: Here are some suggestions.\n\nReply with `@codex fix comments` to fix any unresolved comments.\n\n<details> <summary>About Codex in GitHub</summary>\n\n[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment \"@codex review\". If Codex has suggestions, it will comment; otherwise it will react with 👍.\n\nCodex can also answer questions or update the PR. Try commenting \"@codex fix this CI failure\" or \"@codex address that feedback\".\n</details>","submittedAt":"2025-09-12T08:36:23Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f"}},{"id":"PRR_kwDOPs5-l86_p2_r","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces proof tag emission in development mode for both Rust and TypeScript runtimes, controlled by a `DEV_PROOFS` environment variable. The changes include caching this flag for performance, adding test helpers for environment management, and ensuring test isolation with thread-local logging in Rust. My review focuses on improving safety, performance, and test robustness. Key points include addressing a critical data race in the Rust caching implementation, fixing a test isolation issue in the TypeScript proof logger, and suggesting performance and type safety improvements in both runtimes.","submittedAt":"2025-09-12T08:36:41Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"cbd13b2c1cb07dbc7d3078c6221ef9c498aaf86f"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T08:34:24Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669193724/job/50216896859","name":"conformance","startedAt":"2025-09-12T08:33:52Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:34:07Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669193725/job/50216897497","name":"TypeScript build & test","startedAt":"2025-09-12T08:33:53Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:33:57Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216896896","name":"changed","startedAt":"2025-09-12T08:33:52Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:34:28Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669193725/job/50216897507","name":"Rust build & test","startedAt":"2025-09-12T08:33:53Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:34:09Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216905721","name":"ts","startedAt":"2025-09-12T08:34:00Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:34:32Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216905757","name":"rust","startedAt":"2025-09-12T08:34:00Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:33:58Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669193738/job/50216905879","name":"golden","startedAt":"2025-09-12T08:33:58Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"B2: emit proof tags in dev mode","updatedAt":"2025-09-12T08:46:27Z","url":"https://github.com/LexLattice/tf-lang/pull/28"}
```


---

# PR #29 — B2: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/29
- Author: @andreidita22
- Created: 2025-09-12T08:48:58Z
- Updated: 2025-09-12T08:51:15Z

## Checks
```
conformance	pass	27s	https://github.com/LexLattice/tf-lang/actions/runs/17669541913/job/50218004658	
rust	pass	45s	https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218012522	
ts	pass	13s	https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218012523	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218012575	
Rust build & test	pass	43s	https://github.com/LexLattice/tf-lang/actions/runs/17669541927/job/50218004604	
TypeScript build & test	pass	14s	https://github.com/LexLattice/tf-lang/actions/runs/17669541927/job/50218004577	
changed	pass	5s	https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218004617	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request refines the handling of development-mode proof tags across the TypeScript and Rust components of the system. The changes focus on improving the isolation of proof logs in asynchronous TypeScript environments and optimizing the caching mechanism for environment flags in Rust, leading to more robust and efficient development tooling.

### Highlights

* **TypeScript Proof Logging**: Proof logs in TypeScript are now isolated using AsyncLocalStorage, ensuring that logs from different asynchronous operations do not intermingle. This also includes fixes for ESM imports.
* **Rust Environment Flag Caching**: The `DEV_PROOFS` flag in Rust is now cached atomically using `AtomicU8`, improving efficiency and thread safety. An unnecessary clone operation has also been removed.
* **Test Strengthening**: Environment cache tests in both TypeScript and Rust have been strengthened with additional assertions to ensure correct behavior after cache resets.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces several excellent improvements. The transition to `AsyncLocalStorage` in TypeScript for proof logs and `AtomicU8` in Rust for the environment flag cache are significant steps forward for safety in concurrent contexts, correctly moving away from a global mutable state and `unsafe` code respectively. The test suites for both languages have also been strengthened to better validate the caching logic. Additionally, the code quality is enhanced by removing a Node.js `Buffer` dependency in favor of a portable `bytesEqual` function, improving TypeScript type safety with `as const`, and eliminating an unnecessary clone in the Rust VM. I have one suggestion to improve the readability of the new atomic cache implementation in Rust by replacing magic numbers with named constants. Overall, this is a high-quality contribution.
--
author:	chatgpt-codex-connector
association:	none
edited:	false
status:	commented
--
Codex Review: Here are some suggestions.

Reply with `@codex fix comments` to fix any unresolved comments.

<details> <summary>About Codex in GitHub</summary>

[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment "@codex review". If Codex has suggestions, it will comment; otherwise it will react with 👍.

Codex can also answer questions or update the PR. Try commenting "@codex fix this CI failure" or "@codex address that feedback".
</details>
--
```

## Files Changed (JSON)
```json
[{"sha":"a1697cf1d1b0ef67f26664e23cc8e382ce5e0dce","filename":".codex/JOURNAL.md","status":"modified","additions":12,"deletions":0,"changes":12,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -535,3 +535,15 @@ Next suggested step:\n   - pnpm -C packages/tf-lang-l0-ts test\n - Results:\n   - tests passed\n+## [B2-polish3] Async proof log & atomic env cache\n+- Start: 2025-09-12 08:40 UTC\n+- End:   2025-09-12 08:45 UTC\n+- Changes:\n+  - replaced TS proof log with AsyncLocalStorage and added explicit .js imports\n+  - switched Rust DEV_PROOFS cache to atomic and removed unnecessary clone\n+  - strengthened env flag cache tests in TS and Rust\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests passed"},{"sha":"f1b4e06b68aef7dcf0ff6d80dba9fff8abbad111","filename":".codex/polish/B2.md","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -1,2 +1,3 @@\n - TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.\n - Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'.\n+- tests/helpers/env.ts: store `Object.keys(vars)` in a variable and reuse in both loops."},{"sha":"47faa4a5bd67e73a4b8883a4888dd33bc554862b","filename":".codex/self-plans/B2.md","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -23,3 +23,27 @@\n - Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.\n - Tests cover presence and absence of tags.\n - Journal updated and repository tests pass.\n+\n+## Plan 2025-09-12\n+1. Add `.js` extension to `packages/tf-lang-l0-ts/src/proof/index.ts` import.\n+2. Replace module-level proof log with `AsyncLocalStorage` and expose `withProofLog` wrapper.\n+3. Wrap test helper `withEnv` with `withProofLog` for isolated logs and add `.js` extensions in tests.\n+4. Implement byte-wise comparison in TS VM interpreter and remove `as any` cast using `as const`.\n+5. Swap Rust `static mut` cache for atomic `AtomicU8` implementation.\n+6. Avoid unnecessary clone of `final_state` in Rust VM interpreter.\n+7. Strengthen TS and Rust cache tests with post-reset assertions.\n+8. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`.\n+9. Append B2-polish3 entry to `.codex/JOURNAL.md`.\n+\n+## Tests\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks\n+- AsyncLocalStorage usage may not propagate in all async flows.\n+- Atomic env cache must correctly handle concurrent init.\n+- Test expectations may need updates after refactors.\n+\n+## Definition of Done\n+- All reviewer comments addressed.\n+- Tests pass and journal updated."},{"sha":"a94cefd426866652b0449b325e9be9f67021c000","filename":"packages/tf-lang-l0-rs/src/env.rs","status":"modified","additions":18,"deletions":11,"changes":29,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -1,20 +1,27 @@\n-use std::sync::OnceLock;\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n /// Centralized, cached environment feature flags for the Rust runtime.\n-static mut DEV_PROOFS: OnceLock<bool> = OnceLock::new();\n+/// 0: uninitialized, 1: false, 2: true\n+static DEV_PROOFS_STATE: AtomicU8 = AtomicU8::new(0);\n \n pub fn dev_proofs_enabled() -> bool {\n-    unsafe {\n-        *DEV_PROOFS.get_or_init(|| {\n-            std::env::var(\"DEV_PROOFS\")\n-                .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n-                .unwrap_or(false)\n-        })\n+    let state = DEV_PROOFS_STATE.load(Ordering::Acquire);\n+    if state != 0 {\n+        return state == 2;\n+    }\n+\n+    let val = std::env::var(\"DEV_PROOFS\")\n+        .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n+        .unwrap_or(false);\n+    let new_state = if val { 2 } else { 1 };\n+\n+    match DEV_PROOFS_STATE.compare_exchange(0, new_state, Ordering::Release, Ordering::Acquire) {\n+        Ok(_) => val,\n+        Err(current_state) => current_state == 2,\n     }\n }\n \n /// TESTS ONLY: clear cached flags\n pub fn __reset_env_cache_for_tests__() {\n-    unsafe {\n-        DEV_PROOFS.take();\n-    }\n+    DEV_PROOFS_STATE.store(0, Ordering::Release);\n }"},{"sha":"77e652a6a26ec5811a114a2fe962fb9c8a92ab99","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -194,15 +194,15 @@ impl<'h> VM<'h> {\n         let delta = if final_state == initial_state {\n             None\n         } else {\n-            Some(Replace { replace: final_state.clone() })\n+            Some(Replace { replace: final_state })\n         };\n         emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });\n         for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {\n             emit(ProofTag::Normalization { target });\n         }\n-        let out = match delta {\n+        let out = match &delta {\n             None => serde_json::Value::Null,\n-            Some(d) => serde_json::json!({ \"replace\": d.replace }),\n+            Some(d) => serde_json::json!({ \"replace\": d.replace.clone() }),\n         };\n \n         Ok(out)"},{"sha":"f8332ea0d419a7e1af13795b48a2b5b375d08002","filename":"packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -11,4 +11,5 @@ fn dev_proofs_is_cached() {\n     let _g2 = EnvVarGuard::unset(\"DEV_PROOFS\");\n     assert!(dev_proofs_enabled());\n     __reset_env_cache_for_tests__();\n+    assert!(!dev_proofs_enabled());\n }"},{"sha":"3388c27600bf6b49829d80e7365451dbbf21e7c7","filename":"packages/tf-lang-l0-ts/src/proof/index.ts","status":"modified","additions":12,"deletions":5,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -1,16 +1,23 @@\n export * from './tags.js';\n import type { ProofTag } from './tags.js';\n-import { devProofsEnabled } from '../util/env';\n+import { AsyncLocalStorage } from 'node:async_hooks';\n+import { devProofsEnabled } from '../util/env.js';\n \n-const log: ProofTag[] = [];\n+const storage = new AsyncLocalStorage<ProofTag[]>();\n+\n+export function withProofLog<T>(fn: () => T): T {\n+  return storage.run([], fn);\n+}\n \n export function emit(tag: ProofTag): void {\n-  if (devProofsEnabled()) {\n-    log.push(tag);\n-  }\n+  if (!devProofsEnabled()) return;\n+  const log = storage.getStore();\n+  if (log) log.push(tag);\n }\n \n export function flush(): ProofTag[] {\n+  const log = storage.getStore();\n+  if (!log) return [];\n   const out = log.slice();\n   log.length = 0;\n   return out;"},{"sha":"4fc333c1a16d4ffb6f36b2782081c045789e5cb9","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":8,"deletions":2,"changes":10,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -4,6 +4,12 @@ import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n import { emit } from '../proof/index.js';\n \n+function bytesEqual(a: Uint8Array, b: Uint8Array): boolean {\n+  if (a.length !== b.length) return false;\n+  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n+  return true;\n+}\n+\n export class VM {\n   constructor(public host: Host) {}\n \n@@ -108,9 +114,9 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };\n+    const delta = bytesEqual(a, b) ? null : { replace: finalState };\n     emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n-    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));\n+    (['delta', 'effect'] as const).forEach(target => emit({ kind: 'Normalization', target }));\n     return delta;\n   }\n }"},{"sha":"eadff67d5281591f78f5b200febd4c406beade99","filename":"packages/tf-lang-l0-ts/tests/helpers/env.ts","status":"modified","additions":6,"deletions":3,"changes":9,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -1,19 +1,22 @@\n // Scoped env override for tests to avoid leaking state across parallel cases.\n+import { withProofLog } from '../../src/proof/index.js';\n+\n export async function withEnv<T>(\n   vars: Record<string, string | undefined>,\n   fn: () => Promise<T> | T\n ): Promise<T> {\n   const prev: Record<string, string | undefined> = {};\n-  for (const k of Object.keys(vars)) {\n+  const keys = Object.keys(vars);\n+  for (const k of keys) {\n     prev[k] = process.env[k];\n     const v = vars[k];\n     if (v === undefined) delete process.env[k];\n     else process.env[k] = v;\n   }\n   try {\n-    return await fn();\n+    return await withProofLog(fn);\n   } finally {\n-    for (const k of Object.keys(vars)) {\n+    for (const k of keys) {\n       const v = prev[k];\n       if (v === undefined) delete process.env[k];\n       else process.env[k] = v;"},{"sha":"1eea2fe7f3537b0328149f20c368054c46454cb4","filename":"packages/tf-lang-l0-ts/tests/proof-dev.test.ts","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -3,8 +3,8 @@ import { VM } from '../src/vm/index.js';\n import type { Program } from '../src/model/bytecode.js';\n import { DummyHost } from '../src/host/memory.js';\n import { flush } from '../src/proof/index.js';\n-import { withEnv } from './helpers/env';\n-import { __resetEnvCacheForTests__ } from '../src/util/env';\n+import { withEnv } from './helpers/env.js';\n+import { __resetEnvCacheForTests__ } from '../src/util/env.js';\n \n describe('proof dev mode', () => {\n   afterEach(() => __resetEnvCacheForTests__());"},{"sha":"d53b00bcd3cc1f7a93d158fd83010325fa14440a","filename":"packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts","status":"modified","additions":9,"deletions":3,"changes":12,"blob_url":"https://github.com/LexLattice/tf-lang/blob/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/3988ccab2792f56118b629693c8974b608e77d5e/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts?ref=3988ccab2792f56118b629693c8974b608e77d5e","patch":"@@ -1,17 +1,23 @@\n import { describe, it, expect, afterEach } from 'vitest';\n-import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';\n-import { withEnv } from '../helpers/env';\n+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env.js';\n+import { withEnv } from '../helpers/env.js';\n \n describe('DEV_PROOFS caching (TS)', () => {\n   afterEach(() => __resetEnvCacheForTests__());\n \n-  it('reads once and caches', async () => {\n+  it('reads once, caches, and resets', async () => {\n     await withEnv({ DEV_PROOFS: '1' }, () => {\n       expect(devProofsEnabled()).toBe(true);\n     });\n     // Flip env but cache should hold until reset\n     await withEnv({ DEV_PROOFS: '0' }, () => {\n       expect(devProofsEnabled()).toBe(true);\n     });\n+\n+    __resetEnvCacheForTests__();\n+\n+    await withEnv({ DEV_PROOFS: '0' }, () => {\n+      expect(devProofsEnabled()).toBe(false);\n+    });\n   });\n });"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 62e0117..a1697cf 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -535,3 +535,15 @@ Next suggested step:
   - pnpm -C packages/tf-lang-l0-ts test
 - Results:
   - tests passed
+## [B2-polish3] Async proof log & atomic env cache
+- Start: 2025-09-12 08:40 UTC
+- End:   2025-09-12 08:45 UTC
+- Changes:
+  - replaced TS proof log with AsyncLocalStorage and added explicit .js imports
+  - switched Rust DEV_PROOFS cache to atomic and removed unnecessary clone
+  - strengthened env flag cache tests in TS and Rust
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests passed
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
index d15db56..f1b4e06 100644
--- a/.codex/polish/B2.md
+++ b/.codex/polish/B2.md
@@ -1,2 +1,3 @@
 - TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.
 - Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'.
+- tests/helpers/env.ts: store `Object.keys(vars)` in a variable and reuse in both loops.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
index c434bdd..47faa4a 100644
--- a/.codex/self-plans/B2.md
+++ b/.codex/self-plans/B2.md
@@ -23,3 +23,27 @@
 - Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.
 - Tests cover presence and absence of tags.
 - Journal updated and repository tests pass.
+
+## Plan 2025-09-12
+1. Add `.js` extension to `packages/tf-lang-l0-ts/src/proof/index.ts` import.
+2. Replace module-level proof log with `AsyncLocalStorage` and expose `withProofLog` wrapper.
+3. Wrap test helper `withEnv` with `withProofLog` for isolated logs and add `.js` extensions in tests.
+4. Implement byte-wise comparison in TS VM interpreter and remove `as any` cast using `as const`.
+5. Swap Rust `static mut` cache for atomic `AtomicU8` implementation.
+6. Avoid unnecessary clone of `final_state` in Rust VM interpreter.
+7. Strengthen TS and Rust cache tests with post-reset assertions.
+8. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`.
+9. Append B2-polish3 entry to `.codex/JOURNAL.md`.
+
+## Tests
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks
+- AsyncLocalStorage usage may not propagate in all async flows.
+- Atomic env cache must correctly handle concurrent init.
+- Test expectations may need updates after refactors.
+
+## Definition of Done
+- All reviewer comments addressed.
+- Tests pass and journal updated.
diff --git a/packages/tf-lang-l0-rs/src/env.rs b/packages/tf-lang-l0-rs/src/env.rs
index e3dd278..a94cefd 100644
--- a/packages/tf-lang-l0-rs/src/env.rs
+++ b/packages/tf-lang-l0-rs/src/env.rs
@@ -1,20 +1,27 @@
-use std::sync::OnceLock;
+use std::sync::atomic::{AtomicU8, Ordering};
+
 /// Centralized, cached environment feature flags for the Rust runtime.
-static mut DEV_PROOFS: OnceLock<bool> = OnceLock::new();
+/// 0: uninitialized, 1: false, 2: true
+static DEV_PROOFS_STATE: AtomicU8 = AtomicU8::new(0);
 
 pub fn dev_proofs_enabled() -> bool {
-    unsafe {
-        *DEV_PROOFS.get_or_init(|| {
-            std::env::var("DEV_PROOFS")
-                .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
-                .unwrap_or(false)
-        })
+    let state = DEV_PROOFS_STATE.load(Ordering::Acquire);
+    if state != 0 {
+        return state == 2;
+    }
+
+    let val = std::env::var("DEV_PROOFS")
+        .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
+        .unwrap_or(false);
+    let new_state = if val { 2 } else { 1 };
+
+    match DEV_PROOFS_STATE.compare_exchange(0, new_state, Ordering::Release, Ordering::Acquire) {
+        Ok(_) => val,
+        Err(current_state) => current_state == 2,
     }
 }
 
 /// TESTS ONLY: clear cached flags
 pub fn __reset_env_cache_for_tests__() {
-    unsafe {
-        DEV_PROOFS.take();
-    }
+    DEV_PROOFS_STATE.store(0, Ordering::Release);
 }
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index 383cd83..77e652a 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -194,15 +194,15 @@ impl<'h> VM<'h> {
         let delta = if final_state == initial_state {
             None
         } else {
-            Some(Replace { replace: final_state.clone() })
+            Some(Replace { replace: final_state })
         };
         emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });
         for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {
             emit(ProofTag::Normalization { target });
         }
-        let out = match delta {
+        let out = match &delta {
             None => serde_json::Value::Null,
-            Some(d) => serde_json::json!({ "replace": d.replace }),
+            Some(d) => serde_json::json!({ "replace": d.replace.clone() }),
         };
 
         Ok(out)
diff --git a/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
index 3ddfa82..f8332ea 100644
--- a/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
+++ b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
@@ -11,4 +11,5 @@ fn dev_proofs_is_cached() {
     let _g2 = EnvVarGuard::unset("DEV_PROOFS");
     assert!(dev_proofs_enabled());
     __reset_env_cache_for_tests__();
+    assert!(!dev_proofs_enabled());
 }
diff --git a/packages/tf-lang-l0-ts/src/proof/index.ts b/packages/tf-lang-l0-ts/src/proof/index.ts
index c1a33e4..3388c27 100644
--- a/packages/tf-lang-l0-ts/src/proof/index.ts
+++ b/packages/tf-lang-l0-ts/src/proof/index.ts
@@ -1,16 +1,23 @@
 export * from './tags.js';
 import type { ProofTag } from './tags.js';
-import { devProofsEnabled } from '../util/env';
+import { AsyncLocalStorage } from 'node:async_hooks';
+import { devProofsEnabled } from '../util/env.js';
 
-const log: ProofTag[] = [];
+const storage = new AsyncLocalStorage<ProofTag[]>();
+
+export function withProofLog<T>(fn: () => T): T {
+  return storage.run([], fn);
+}
 
 export function emit(tag: ProofTag): void {
-  if (devProofsEnabled()) {
-    log.push(tag);
-  }
+  if (!devProofsEnabled()) return;
+  const log = storage.getStore();
+  if (log) log.push(tag);
 }
 
 export function flush(): ProofTag[] {
+  const log = storage.getStore();
+  if (!log) return [];
   const out = log.slice();
   log.length = 0;
   return out;
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index c4b5fbe..4fc333c 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -4,6 +4,12 @@ import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
 import { emit } from '../proof/index.js';
 
+function bytesEqual(a: Uint8Array, b: Uint8Array): boolean {
+  if (a.length !== b.length) return false;
+  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
+  return true;
+}
+
 export class VM {
   constructor(public host: Host) {}
 
@@ -108,9 +114,9 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };
+    const delta = bytesEqual(a, b) ? null : { replace: finalState };
     emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
-    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));
+    (['delta', 'effect'] as const).forEach(target => emit({ kind: 'Normalization', target }));
     return delta;
   }
 }
diff --git a/packages/tf-lang-l0-ts/tests/helpers/env.ts b/packages/tf-lang-l0-ts/tests/helpers/env.ts
index 3068297..eadff67 100644
--- a/packages/tf-lang-l0-ts/tests/helpers/env.ts
+++ b/packages/tf-lang-l0-ts/tests/helpers/env.ts
@@ -1,19 +1,22 @@
 // Scoped env override for tests to avoid leaking state across parallel cases.
+import { withProofLog } from '../../src/proof/index.js';
+
 export async function withEnv<T>(
   vars: Record<string, string | undefined>,
   fn: () => Promise<T> | T
 ): Promise<T> {
   const prev: Record<string, string | undefined> = {};
-  for (const k of Object.keys(vars)) {
+  const keys = Object.keys(vars);
+  for (const k of keys) {
     prev[k] = process.env[k];
     const v = vars[k];
     if (v === undefined) delete process.env[k];
     else process.env[k] = v;
   }
   try {
-    return await fn();
+    return await withProofLog(fn);
   } finally {
-    for (const k of Object.keys(vars)) {
+    for (const k of keys) {
       const v = prev[k];
       if (v === undefined) delete process.env[k];
       else process.env[k] = v;
diff --git a/packages/tf-lang-l0-ts/tests/proof-dev.test.ts b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
index 23f3f48..1eea2fe 100644
--- a/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
+++ b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
@@ -3,8 +3,8 @@ import { VM } from '../src/vm/index.js';
 import type { Program } from '../src/model/bytecode.js';
 import { DummyHost } from '../src/host/memory.js';
 import { flush } from '../src/proof/index.js';
-import { withEnv } from './helpers/env';
-import { __resetEnvCacheForTests__ } from '../src/util/env';
+import { withEnv } from './helpers/env.js';
+import { __resetEnvCacheForTests__ } from '../src/util/env.js';
 
 describe('proof dev mode', () => {
   afterEach(() => __resetEnvCacheForTests__());
diff --git a/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
index 62d88ab..d53b00b 100644
--- a/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
+++ b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
@@ -1,11 +1,11 @@
 import { describe, it, expect, afterEach } from 'vitest';
-import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';
-import { withEnv } from '../helpers/env';
+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env.js';
+import { withEnv } from '../helpers/env.js';
 
 describe('DEV_PROOFS caching (TS)', () => {
   afterEach(() => __resetEnvCacheForTests__());
 
-  it('reads once and caches', async () => {
+  it('reads once, caches, and resets', async () => {
     await withEnv({ DEV_PROOFS: '1' }, () => {
       expect(devProofsEnabled()).toBe(true);
     });
@@ -13,5 +13,11 @@ describe('DEV_PROOFS caching (TS)', () => {
     await withEnv({ DEV_PROOFS: '0' }, () => {
       expect(devProofsEnabled()).toBe(true);
     });
+
+    __resetEnvCacheForTests__();
+
+    await withEnv({ DEV_PROOFS: '0' }, () => {
+      expect(devProofsEnabled()).toBe(false);
+    });
   });
 });
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T08:48:58Z","isDraft":false,"mergeStateStatus":"CLEAN","number":29,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_qFSr","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request refines the handling of development-mode proof tags across the TypeScript and Rust components of the system. The changes focus on improving the isolation of proof logs in asynchronous TypeScript environments and optimizing the caching mechanism for environment flags in Rust, leading to more robust and efficient development tooling.\n\n### Highlights\n\n* **TypeScript Proof Logging**: Proof logs in TypeScript are now isolated using AsyncLocalStorage, ensuring that logs from different asynchronous operations do not intermingle. This also includes fixes for ESM imports.\n* **Rust Environment Flag Caching**: The `DEV_PROOFS` flag in Rust is now cached atomically using `AtomicU8`, improving efficiency and thread safety. An unnecessary clone operation has also been removed.\n* **Test Strengthening**: Environment cache tests in both TypeScript and Rust have been strengthened with additional assertions to ensure correct behavior after cache resets.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T08:49:16Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"3988ccab2792f56118b629693c8974b608e77d5e"}},{"id":"PRR_kwDOPs5-l86_qG3-","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces several excellent improvements. The transition to `AsyncLocalStorage` in TypeScript for proof logs and `AtomicU8` in Rust for the environment flag cache are significant steps forward for safety in concurrent contexts, correctly moving away from a global mutable state and `unsafe` code respectively. The test suites for both languages have also been strengthened to better validate the caching logic. Additionally, the code quality is enhanced by removing a Node.js `Buffer` dependency in favor of a portable `bytesEqual` function, improving TypeScript type safety with `as const`, and eliminating an unnecessary clone in the Rust VM. I have one suggestion to improve the readability of the new atomic cache implementation in Rust by replacing magic numbers with named constants. Overall, this is a high-quality contribution.","submittedAt":"2025-09-12T08:50:43Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"3988ccab2792f56118b629693c8974b608e77d5e"}},{"id":"PRR_kwDOPs5-l86_qHaW","author":{"login":"chatgpt-codex-connector"},"authorAssociation":"NONE","body":"Codex Review: Here are some suggestions.\n\nReply with `@codex fix comments` to fix any unresolved comments.\n\n<details> <summary>About Codex in GitHub</summary>\n\n[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment \"@codex review\". If Codex has suggestions, it will comment; otherwise it will react with 👍.\n\nCodex can also answer questions or update the PR. Try commenting \"@codex fix this CI failure\" or \"@codex address that feedback\".\n</details>","submittedAt":"2025-09-12T08:51:15Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"3988ccab2792f56118b629693c8974b608e77d5e"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T08:49:49Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669541913/job/50218004658","name":"conformance","startedAt":"2025-09-12T08:49:22Z","status":"COMPLETED","workflowName":"Conformance (TS ↔ Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:49:18Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669541927/job/50218004577","name":"TypeScript build & test","startedAt":"2025-09-12T08:49:04Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:49:09Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218004617","name":"changed","startedAt":"2025-09-12T08:49:04Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:49:51Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669541927/job/50218004604","name":"Rust build & test","startedAt":"2025-09-12T08:49:08Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:49:27Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218012523","name":"ts","startedAt":"2025-09-12T08:49:14Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:49:58Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218012522","name":"rust","startedAt":"2025-09-12T08:49:13Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:49:10Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17669541905/job/50218012575","name":"golden","startedAt":"2025-09-12T08:49:10Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"B2: emit proof tags in dev mode","updatedAt":"2025-09-12T08:51:15Z","url":"https://github.com/LexLattice/tf-lang/pull/29"}
```
