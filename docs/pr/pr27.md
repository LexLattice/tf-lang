# PR Bundle for LexLattice/tf-lang
- Generated: 2025-09-12 11:20:11 UTC
- PRs: 27

## Summary

- **#27** ‚Äî B2: emit proof tags in dev mode ([link](https://github.com/LexLattice/tf-lang/pull/27)) ‚Äî by @andreidita22 ‚Äî checks: none


---

# PR #27 ‚Äî B2: emit proof tags in dev mode
- URL: https://github.com/LexLattice/tf-lang/pull/27
- Author: @andreidita22
- Created: 2025-09-12T08:13:22Z
- Updated: 2025-09-12T08:16:28Z

## Checks
```
rust	pass	31s	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462922	
ts	pass	11s	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462938	
golden	skipping	0	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462872	
Rust build & test	pass	41s	https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453452	
TypeScript build & test	pass	8s	https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453439	
changed	pass	4s	https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215453460	
conformance	pass	36s	https://github.com/LexLattice/tf-lang/actions/runs/17668720003/job/50215453407	
```

## Comments
```md
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Summary of Changes

Hello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

This pull request enhances the debugging and introspection capabilities of the system by introducing "proof tags" that provide detailed insights into the execution flow of both TypeScript and Rust virtual machines. These tags, which capture events like state transformations, assertions, and function calls, are conditionally emitted only when a DEV_PROOFS environment variable is set, preventing performance overhead in production. The changes also include robust mechanisms for caching this environment variable and isolating its state during testing, ensuring reliable and predictable behavior across development and test environments.

### Highlights

* **Conditional Proof Tag Emission**: Implemented a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust runtimes, but only when the DEV_PROOFS environment variable is enabled.
* **Performance Optimization & Test Isolation**: Introduced caching for the DEV_PROOFS flag in both runtimes to avoid repeated environment variable lookups, along with test-only reset hooks and scoped environment helpers to ensure test isolation and prevent leakage of environment state.
* **Proof Tag Serialization Lock**: Added a test to lock the serialization shape of ProofTag::Normalization in Rust, ensuring consistency and preventing accidental breaking changes to the proof tag structure.
* **Comprehensive Tagging**: Integrated proof tag emission into key VM operations, including lens projections/merges, assertion failures, and function call errors, as well as final witness and normalization states.





<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

--
author:	gemini-code-assist
association:	none
edited:	false
status:	commented
--
## Code Review

This pull request introduces proof tag emission in dev mode for both Rust and TypeScript runtimes, controlled by a `DEV_PROOFS` environment variable. The changes include caching for the flag check to optimize performance and new test helpers for managing environment variables to ensure test stability. The implementation is solid, and my feedback focuses on potential performance improvements, enhancing robustness against panics in the Rust code, addressing thread-safety concerns in tests, and improving test coverage and type safety.
--
author:	chatgpt-codex-connector
association:	none
edited:	false
status:	commented
--
Codex Review: Here are some suggestions.

Reply with `@codex fix comments` to fix any unresolved comments.

<details> <summary>About Codex in GitHub</summary>

[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment "@codex review". If Codex has suggestions, it will comment; otherwise it will react with üëç.

Codex can also answer questions or update the PR. Try commenting "@codex fix this CI failure" or "@codex address that feedback".
</details>
--
```

## Files Changed (JSON)
```json
[{"sha":"7f0f35123d291477cc14db39486071770fdad2a7","filename":".codex/JOURNAL.md","status":"modified","additions":24,"deletions":0,"changes":24,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FJOURNAL.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FJOURNAL.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FJOURNAL.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -500,3 +500,27 @@ Next suggested step:\n   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n - Results:\n   - tests and vectors passed\n+## [B2] Proof tag emission\n+- Start: 2025-09-11 23:00 UTC\n+- End:   2025-09-11 23:30 UTC\n+- Changes:\n+  - added DEV_PROOFS-gated proof log in TS and Rust\n+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags\n+  - tests cover tag emission toggled by DEV_PROOFS\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests passed\n+## [B2-polish] Cache DEV_PROOFS\n+- Start: 2025-09-11 23:40 UTC\n+- End:   2025-09-11 23:55 UTC\n+- Changes:\n+  - centralized cached DEV_PROOFS flag in TS and Rust runtimes\n+  - scoped env helpers for tests and JSON shape lock\n+- Verification:\n+  - pnpm -C packages/tf-lang-l0-ts test\n+  - pnpm -C packages/tf-lang-l0-ts vectors\n+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml\n+- Results:\n+  - tests and vectors passed"},{"sha":"c179ab8d0ce2ac18749f3fd59034b8fa0531b84d","filename":".codex/LESSONS.md","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FLESSONS.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2FLESSONS.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2FLESSONS.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -18,3 +18,5 @@\n - [A4/A5][2025-09-11] Rule: \"LENS ops restricted to dst:0; explicit opcode whitelist.\" Guardrail: lens:dst_only+opcode_whitelist\n - [A7][2025-09-11] Rule: \"Guardrail ops must propagate errors; hosts must not swallow them.\" Guardrail: host:propagate_guardrail_errors\n - [B1][2025-09-11] Rule: \"Proof tags are inert and excluded from hashes.\" Guardrail: proof:tag_inert\n+- [B2][2025-09-11] Rule: \"Proof tags emitted only when DEV_PROOFS=1.\" Guardrail: proof:dev_flag\n+- [B2-polish][2025-09-11] Rule: \"Cache feature flags; tests use scoped env guards.\" Guardrail: proof:env_cache"},{"sha":"d15db569325eef38e564861509f191dee9687288","filename":".codex/polish/B2.md","status":"added","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fpolish%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fpolish%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fpolish%2FB2.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,2 @@\n+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.\n+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'."},{"sha":"c434bdd3898e1ed0286eada6f934fb1588576103","filename":".codex/self-plans/B2.md","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fself-plans%2FB2.md","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/.codex%2Fself-plans%2FB2.md","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/.codex%2Fself-plans%2FB2.md?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,25 @@\n+# Plan for B2\n+\n+## Steps\n+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.\n+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.\n+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.\n+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.\n+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.\n+6. Add Rust tests ensuring tags are emitted only in dev mode.\n+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.\n+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.\n+\n+## Tests\n+- `pnpm -C packages/tf-lang-l0-ts test`\n+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`\n+\n+## Risks\n+- Environment variable may leak between tests; ensure logs are flushed and variables reset.\n+- Synchronizing tag structures across runtimes might be inconsistent.\n+- Adding dependency `once_cell` for Rust logging could impact build.\n+\n+## Definition of Done\n+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.\n+- Tests cover presence and absence of tags.\n+- Journal updated and repository tests pass."},{"sha":"307911ddff06feca12c7c48e4d09cc0328542053","filename":"packages/tf-lang-l0-rs/Cargo.lock","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.lock","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.lock","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.lock?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -79,6 +79,12 @@ version = \"2.7.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0\"\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.21.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n+\n [[package]]\n name = \"pretty_assertions\"\n version = \"1.4.1\"\n@@ -168,6 +174,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"blake3\",\n+ \"once_cell\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\","},{"sha":"b007053d53a73ac579af68fc9155f1a7f3582a7f","filename":"packages/tf-lang-l0-rs/Cargo.toml","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.toml","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2FCargo.toml","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2FCargo.toml?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -17,6 +17,7 @@ thiserror = \"1\"\n serde = { version = \"1\", features = [\"derive\"] }\n serde_json = \"1\"\n blake3 = \"1.5\"\n+once_cell = \"1\"\n \n [dev-dependencies]\n pretty_assertions = \"1\""},{"sha":"a124ac313bdb0e99d008d13cd83219ef065caadc","filename":"packages/tf-lang-l0-rs/src/env.rs","status":"added","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fenv.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,25 @@\n+use std::sync::{Mutex, OnceLock};\n+/// Centralized, cached environment feature flags for the Rust runtime.\n+static DEV_PROOFS: OnceLock<Mutex<Option<bool>>> = OnceLock::new();\n+\n+pub fn dev_proofs_enabled() -> bool {\n+    let lock = DEV_PROOFS.get_or_init(|| Mutex::new(None));\n+    let mut cache = lock.lock().unwrap();\n+    if let Some(v) = *cache {\n+        v\n+    } else {\n+        let v = std::env::var(\"DEV_PROOFS\")\n+            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n+            .unwrap_or(false);\n+        *cache = Some(v);\n+        v\n+    }\n+}\n+\n+/// TESTS ONLY: clear cached flags\n+#[doc(hidden)]\n+pub fn __reset_env_cache_for_tests__() {\n+    if let Some(lock) = DEV_PROOFS.get() {\n+        *lock.lock().unwrap() = None;\n+    }\n+}"},{"sha":"ab13c3a315c661decb26bcb84eee7fe03b93a727","filename":"packages/tf-lang-l0-rs/src/lib.rs","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Flib.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -5,5 +5,6 @@ pub mod util;\n pub mod vm;\n pub mod ops;\n pub mod proof;\n+pub mod env;\n \n // Avoid glob re-exports at crate root to prevent ambiguous names (e.g., `types`)."},{"sha":"cd0f0da4af8cea85f3da835df61d7462155c4196","filename":"packages/tf-lang-l0-rs/src/proof.rs","status":"modified","additions":16,"deletions":0,"changes":16,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fproof.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -42,3 +42,19 @@ pub enum ProofTag {\n     Refutation { code: String, msg: Option<String> },\n     Conservativity { callee: String, expected: String, found: String },\n }\n+\n+use once_cell::sync::Lazy;\n+use std::sync::Mutex;\n+use crate::env::dev_proofs_enabled;\n+\n+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));\n+\n+pub fn emit(tag: ProofTag) {\n+    if dev_proofs_enabled() {\n+        PROOF_LOG.lock().unwrap().push(tag);\n+    }\n+}\n+\n+pub fn flush() -> Vec<ProofTag> {\n+    PROOF_LOG.lock().unwrap().drain(..).collect()\n+}"},{"sha":"383cd8315c311ce7237e43987f2b54a194b3618b","filename":"packages/tf-lang-l0-rs/src/vm/interpreter.rs","status":"modified","additions":22,"deletions":7,"changes":29,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Fsrc%2Fvm%2Finterpreter.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};\n use crate::model::bytecode::Instr;\n use crate::model::{JournalEntry, Program, World};\n use crate::vm::opcode::Host;\n+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};\n use serde_json::Value;\n \n /// Simple VM running SSA bytecode with JSON values as registers.\n@@ -37,6 +38,7 @@ impl<'h> VM<'h> {\n                 Instr::Assert { pred, msg } => {\n                     let v = get(*pred, &regs)?;\n                     if !v.as_bool().unwrap_or(false) {\n+                        emit(ProofTag::Refutation { code: \"ASSERT\".into(), msg: Some(msg.clone()) });\n                         return Err(VmError::Invalid(format!(\"ASSERT failed: {}\", msg)).into());\n                     }\n                 }\n@@ -97,6 +99,7 @@ impl<'h> VM<'h> {\n                 }\n                 Instr::LensProj { dst, state, region } => {\n                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });\n                     regs[*dst as usize] = sub;\n                 }\n                 Instr::LensMerge {\n@@ -105,9 +108,10 @@ impl<'h> VM<'h> {\n                     region,\n                     sub,\n                 } => {\n-                    let merged =\n-                        self.host\n-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    let merged = self\n+                        .host\n+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;\n+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });\n                     regs[*dst as usize] = merged;\n                 }\n                 Instr::PlanSim {\n@@ -173,7 +177,10 @@ impl<'h> VM<'h> {\n                     for r in args {\n                         a.push(get(*r, &regs)?.clone());\n                     }\n-                    let out = self.host.call_tf(tf_id, &a)?;\n+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {\n+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: \"ok\".into(), found: format!(\"{}\", e) });\n+                        e\n+                    })?;\n                     regs[*dst as usize] = out;\n                 }\n             }\n@@ -184,10 +191,18 @@ impl<'h> VM<'h> {\n         }\n \n         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);\n-        let out = if final_state == initial_state {\n-            serde_json::Value::Null\n+        let delta = if final_state == initial_state {\n+            None\n         } else {\n-            serde_json::json!({ \"replace\": final_state })\n+            Some(Replace { replace: final_state.clone() })\n+        };\n+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });\n+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {\n+            emit(ProofTag::Normalization { target });\n+        }\n+        let out = match delta {\n+            None => serde_json::Value::Null,\n+            Some(d) => serde_json::json!({ \"replace\": d.replace }),\n         };\n \n         Ok(out)"},{"sha":"3ddfa82431a985165e6089ea253238944ad28d4d","filename":"packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs","status":"added","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fdev_proofs_flag.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,14 @@\n+use tflang_l0::env::{dev_proofs_enabled, __reset_env_cache_for_tests__};\n+mod util;\n+use util::env::EnvVarGuard;\n+\n+#[test]\n+fn dev_proofs_is_cached() {\n+    let _g = EnvVarGuard::set(\"DEV_PROOFS\", \"1\");\n+    assert!(dev_proofs_enabled());\n+    drop(_g); // restore\n+    // Flip env, but cache should hold until reset\n+    let _g2 = EnvVarGuard::unset(\"DEV_PROOFS\");\n+    assert!(dev_proofs_enabled());\n+    __reset_env_cache_for_tests__();\n+}"},{"sha":"4511d3589314cff38393ceb588856ed787201202","filename":"packages/tf-lang-l0-rs/tests/proof_dev.rs","status":"added","additions":65,"deletions":0,"changes":65,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fproof_dev.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,65 @@\n+use serde_json::json;\n+use tflang_l0::model::{Instr, Program};\n+use tflang_l0::vm::interpreter::VM;\n+use tflang_l0::vm::opcode::Host;\n+use tflang_l0::proof::{flush, ProofTag, TransportOp};\n+use tflang_l0::env::__reset_env_cache_for_tests__;\n+mod util;\n+use util::env::EnvVarGuard;\n+\n+struct DummyHost;\n+\n+impl Host for DummyHost {\n+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"region\": region, \"state\": state}))\n+    }\n+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {\n+        Ok(json!({\"orig\": state, \"sub\": substate}))\n+    }\n+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok(\"id\".into()) }\n+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }\n+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }\n+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {\n+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))\n+    }\n+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {\n+        Ok(tflang_l0::model::World(world.0.clone()))\n+    }\n+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }\n+}\n+\n+fn sample_prog() -> Program {\n+    Program {\n+        version: \"0.1\".into(),\n+        regs: 2,\n+        instrs: vec![\n+            Instr::Const { dst: 0, value: json!({}) },\n+            Instr::LensProj { dst: 1, state: 0, region: \"r\".into() },\n+            Instr::Const { dst: 0, value: json!({\"x\":1}) },\n+            Instr::Halt,\n+        ],\n+    }\n+}\n+\n+#[test]\n+fn dev_proofs_toggles_tags() {\n+    {\n+        let _g = EnvVarGuard::set(\"DEV_PROOFS\", \"1\");\n+        __reset_env_cache_for_tests__();\n+        let vm = VM { host: &DummyHost };\n+        let _ = vm.run(&sample_prog()).unwrap();\n+        let tags = flush();\n+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));\n+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));\n+    }\n+\n+    {\n+        let _g = EnvVarGuard::unset(\"DEV_PROOFS\");\n+        __reset_env_cache_for_tests__();\n+        let vm = VM { host: &DummyHost };\n+        let _ = vm.run(&sample_prog()).unwrap();\n+        let tags = flush();\n+        assert!(tags.is_empty());\n+    }\n+}"},{"sha":"e7135c4554bacb94f0c4ecb3699e20f522a94255","filename":"packages/tf-lang-l0-rs/tests/serde_shapes.rs","status":"added","additions":9,"deletions":0,"changes":9,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Fserde_shapes.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,9 @@\n+use serde_json::json;\n+use tflang_l0::proof::{ProofTag, NormalizationTarget};\n+\n+#[test]\n+fn proof_tag_normalization_shape() {\n+    let n = ProofTag::Normalization { target: NormalizationTarget::Delta };\n+    let v = serde_json::to_value(&n).unwrap();\n+    assert_eq!(v, json!({\"kind\":\"Normalization\",\"target\":\"delta\"}));\n+}"},{"sha":"9cba035c9eed08e7cc0ecb0a763e824bb872178b","filename":"packages/tf-lang-l0-rs/tests/util/env.rs","status":"added","additions":26,"deletions":0,"changes":26,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fenv.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,26 @@\n+use std::env;\n+/// RAII guard for scoped env overrides to prevent test flakiness.\n+pub struct EnvVarGuard {\n+    key: String,\n+    prev: Option<String>,\n+}\n+impl EnvVarGuard {\n+    pub fn set(key: &str, val: &str) -> Self {\n+        let prev = env::var(key).ok();\n+        env::set_var(key, val);\n+        Self { key: key.to_string(), prev }\n+    }\n+    pub fn unset(key: &str) -> Self {\n+        let prev = env::var(key).ok();\n+        env::remove_var(key);\n+        Self { key: key.to_string(), prev }\n+    }\n+}\n+impl Drop for EnvVarGuard {\n+    fn drop(&mut self) {\n+        match &self.prev {\n+            Some(v) => env::set_var(&self.key, v),\n+            None => env::remove_var(&self.key),\n+        }\n+    }\n+}"},{"sha":"3d7924f6ab50a87d6c5d6e3418d3f1a9242f5681","filename":"packages/tf-lang-l0-rs/tests/util/mod.rs","status":"added","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-rs%2Ftests%2Futil%2Fmod.rs?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1 @@\n+pub mod env;"},{"sha":"3588d098e018b666f5b502857717d14bbccb5a2b","filename":"packages/tf-lang-l0-ts/src/index.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Findex.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -5,4 +5,4 @@ export * as check from './check/index.js';\n export { canonicalJsonBytes } from './canon/json.js';\n export { blake3hex } from './canon/hash.js';\n export * as ops from './ops/index.js';\n-export * as proof from './proof/tags.js';\n+export * as proof from './proof/index.js';"},{"sha":"c1a33e47d7703f5707f2511da83bfc1f37464530","filename":"packages/tf-lang-l0-ts/src/proof/index.ts","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fproof%2Findex.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,17 @@\n+export * from './tags.js';\n+import type { ProofTag } from './tags.js';\n+import { devProofsEnabled } from '../util/env';\n+\n+const log: ProofTag[] = [];\n+\n+export function emit(tag: ProofTag): void {\n+  if (devProofsEnabled()) {\n+    log.push(tag);\n+  }\n+}\n+\n+export function flush(): ProofTag[] {\n+  const out = log.slice();\n+  log.length = 0;\n+  return out;\n+}"},{"sha":"75bef9afb9e0a1e622e378ab97d873986825c172","filename":"packages/tf-lang-l0-ts/src/util/env.ts","status":"added","additions":14,"deletions":0,"changes":14,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Futil%2Fenv.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,14 @@\n+// Centralized, cached environment feature flags for the TS runtime.\n+let _devProofs: boolean | undefined;\n+export function devProofsEnabled(): boolean {\n+  if (_devProofs === undefined) {\n+    const v = (process.env.DEV_PROOFS || '').toLowerCase();\n+    _devProofs = v === '1' || v === 'true';\n+  }\n+  return _devProofs;\n+}\n+\n+// For tests only: reset the cached flag (not exported in build).\n+export function __resetEnvCacheForTests__() {\n+  _devProofs = undefined;\n+}"},{"sha":"c4b5fbe67565531cf1db48186290f87fc5a36451","filename":"packages/tf-lang-l0-ts/src/vm/interpreter.ts","status":"modified","additions":25,"deletions":8,"changes":33,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Fsrc%2Fvm%2Finterpreter.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';\n import type { Host } from './opcode.js';\n import type { Value, World, JournalEntry } from '../model/types.js';\n import { canonicalJsonBytes, blake3hex } from '../canon/index.js';\n+import { emit } from '../proof/index.js';\n \n export class VM {\n   constructor(public host: Host) {}\n@@ -41,8 +42,16 @@ export class VM {\n         }\n         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;\n         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;\n-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;\n-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;\n+        case 'LENS_PROJ': {\n+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);\n+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });\n+          break;\n+        }\n+        case 'LENS_MERGE': {\n+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));\n+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });\n+          break;\n+        }\n         case 'PLAN_SIM': {\n           const res: any = await this.host.call_tf(\"tf://plan/simulate@0.1\", [this.get(regs, ins.world), this.get(regs, ins.plan)]);\n           regs[ins.dst_delta] = res?.delta ?? null;\n@@ -67,12 +76,20 @@ export class VM {\n         }\n         case 'CALL': {\n           const args = ins.args.map(a => this.get(regs, a));\n-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          try {\n+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);\n+          } catch (e: any) {\n+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });\n+            throw e;\n+          }\n           break;\n         }\n         case 'ASSERT': {\n           const v = this.get(regs, ins.pred);\n-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);\n+          if (v !== true) {\n+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });\n+            throw new Error(`ASSERT failed: ${ins.msg}`);\n+          }\n           break;\n         }\n         default: {\n@@ -91,10 +108,10 @@ export class VM {\n     // identity => null; otherwise full replace\n     const a = canonicalJsonBytes(initialState);\n     const b = canonicalJsonBytes(finalState);\n-    if (Buffer.from(a).equals(Buffer.from(b))) {\n-      return null;\n-    }\n-    return { replace: finalState };\n+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };\n+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });\n+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));\n+    return delta;\n   }\n }\n "},{"sha":"306829767c2d96bf5c067c3bf147525e96ecbfe4","filename":"packages/tf-lang-l0-ts/tests/helpers/env.ts","status":"added","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fhelpers%2Fenv.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,22 @@\n+// Scoped env override for tests to avoid leaking state across parallel cases.\n+export async function withEnv<T>(\n+  vars: Record<string, string | undefined>,\n+  fn: () => Promise<T> | T\n+): Promise<T> {\n+  const prev: Record<string, string | undefined> = {};\n+  for (const k of Object.keys(vars)) {\n+    prev[k] = process.env[k];\n+    const v = vars[k];\n+    if (v === undefined) delete process.env[k];\n+    else process.env[k] = v;\n+  }\n+  try {\n+    return await fn();\n+  } finally {\n+    for (const k of Object.keys(vars)) {\n+      const v = prev[k];\n+      if (v === undefined) delete process.env[k];\n+      else process.env[k] = v;\n+    }\n+  }\n+}"},{"sha":"23f3f48412dd2eae26e5b46ea16215db2b9e3957","filename":"packages/tf-lang-l0-ts/tests/proof-dev.test.ts","status":"added","additions":40,"deletions":0,"changes":40,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-dev.test.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,40 @@\n+import { describe, it, expect, afterEach } from 'vitest';\n+import { VM } from '../src/vm/index.js';\n+import type { Program } from '../src/model/bytecode.js';\n+import { DummyHost } from '../src/host/memory.js';\n+import { flush } from '../src/proof/index.js';\n+import { withEnv } from './helpers/env';\n+import { __resetEnvCacheForTests__ } from '../src/util/env';\n+\n+describe('proof dev mode', () => {\n+  afterEach(() => __resetEnvCacheForTests__());\n+  const prog: Program = {\n+    version: '0.1',\n+    regs: 2,\n+    instrs: [\n+      { op: 'CONST', dst: 0, value: {} },\n+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },\n+      { op: 'CONST', dst: 0, value: { x: 1 } },\n+      { op: 'HALT' },\n+    ],\n+  };\n+\n+  it('emits tags when DEV_PROOFS=1', async () => {\n+    await withEnv({ DEV_PROOFS: '1' }, async () => {\n+      const vm = new VM(DummyHost);\n+      await vm.run(prog);\n+      const tags = flush();\n+      expect(tags.some(t => t.kind === 'Transport')).toBe(true);\n+      expect(tags.some(t => t.kind === 'Witness')).toBe(true);\n+    });\n+  });\n+\n+  it('no tags when DEV_PROOFS is unset', async () => {\n+    await withEnv({ DEV_PROOFS: undefined }, async () => {\n+      const vm = new VM(DummyHost);\n+      await vm.run(prog);\n+      const tags = flush();\n+      expect(tags.length).toBe(0);\n+    });\n+  });\n+});"},{"sha":"84020f7a6fb48f42653c12ed963f928fe34b852f","filename":"packages/tf-lang-l0-ts/tests/proof-tags.test.ts","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproof-tags.test.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -1,5 +1,5 @@\n import { describe, it, expect } from 'vitest';\n-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';\n+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';\n \n describe('proof tags', () => {\n   it('compile tag shapes', () => {"},{"sha":"62d88abc4ef50fd6aac5bc6cfa6b467f8d9b9ba3","filename":"packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts","status":"added","additions":17,"deletions":0,"changes":17,"blob_url":"https://github.com/LexLattice/tf-lang/blob/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","raw_url":"https://github.com/LexLattice/tf-lang/raw/2c4bc59231ec0823937911a7c4ee1bcbb2ec0343/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts","contents_url":"https://api.github.com/repos/LexLattice/tf-lang/contents/packages%2Ftf-lang-l0-ts%2Ftests%2Fproofs%2Fdev_proofs_flag.test.ts?ref=2c4bc59231ec0823937911a7c4ee1bcbb2ec0343","patch":"@@ -0,0 +1,17 @@\n+import { describe, it, expect, afterEach } from 'vitest';\n+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';\n+import { withEnv } from '../helpers/env';\n+\n+describe('DEV_PROOFS caching (TS)', () => {\n+  afterEach(() => __resetEnvCacheForTests__());\n+\n+  it('reads once and caches', async () => {\n+    await withEnv({ DEV_PROOFS: '1' }, () => {\n+      expect(devProofsEnabled()).toBe(true);\n+    });\n+    // Flip env but cache should hold until reset\n+    await withEnv({ DEV_PROOFS: '0' }, () => {\n+      expect(devProofsEnabled()).toBe(true);\n+    });\n+  });\n+});"}]```

## Diff
```diff
diff --git a/.codex/JOURNAL.md b/.codex/JOURNAL.md
index 1d51d29..7f0f351 100644
--- a/.codex/JOURNAL.md
+++ b/.codex/JOURNAL.md
@@ -500,3 +500,27 @@ Next suggested step:
   - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
 - Results:
   - tests and vectors passed
+## [B2] Proof tag emission
+- Start: 2025-09-11 23:00 UTC
+- End:   2025-09-11 23:30 UTC
+- Changes:
+  - added DEV_PROOFS-gated proof log in TS and Rust
+  - VMs emit Witness, Normalization, Transport, Refutation, and Conservativity tags
+  - tests cover tag emission toggled by DEV_PROOFS
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests passed
+## [B2-polish] Cache DEV_PROOFS
+- Start: 2025-09-11 23:40 UTC
+- End:   2025-09-11 23:55 UTC
+- Changes:
+  - centralized cached DEV_PROOFS flag in TS and Rust runtimes
+  - scoped env helpers for tests and JSON shape lock
+- Verification:
+  - pnpm -C packages/tf-lang-l0-ts test
+  - pnpm -C packages/tf-lang-l0-ts vectors
+  - cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml
+- Results:
+  - tests and vectors passed
diff --git a/.codex/LESSONS.md b/.codex/LESSONS.md
index 4cd4e50..c179ab8 100644
--- a/.codex/LESSONS.md
+++ b/.codex/LESSONS.md
@@ -18,3 +18,5 @@
 - [A4/A5][2025-09-11] Rule: "LENS ops restricted to dst:0; explicit opcode whitelist." Guardrail: lens:dst_only+opcode_whitelist
 - [A7][2025-09-11] Rule: "Guardrail ops must propagate errors; hosts must not swallow them." Guardrail: host:propagate_guardrail_errors
 - [B1][2025-09-11] Rule: "Proof tags are inert and excluded from hashes." Guardrail: proof:tag_inert
+- [B2][2025-09-11] Rule: "Proof tags emitted only when DEV_PROOFS=1." Guardrail: proof:dev_flag
+- [B2-polish][2025-09-11] Rule: "Cache feature flags; tests use scoped env guards." Guardrail: proof:env_cache
diff --git a/.codex/polish/B2.md b/.codex/polish/B2.md
new file mode 100644
index 0000000..d15db56
--- /dev/null
+++ b/.codex/polish/B2.md
@@ -0,0 +1,2 @@
+- TS interpreter: emit normalization tags via loop over ['delta','effect'] to reduce repetition.
+- Rust interpreter: likewise loop emitting Normalization tags for 'delta' and 'effect'.
diff --git a/.codex/self-plans/B2.md b/.codex/self-plans/B2.md
new file mode 100644
index 0000000..c434bdd
--- /dev/null
+++ b/.codex/self-plans/B2.md
@@ -0,0 +1,25 @@
+# Plan for B2
+
+## Steps
+1. Create a proof logging module in TS that collects proof tags when `DEV_PROOFS=1` and expose emit/flush helpers.
+2. Update TS VM interpreter to emit Transport tags for lens ops, Refutation tags on ASSERT failures, Witness and Normalization tags after run, and Conservativity tags on CALL errors.
+3. Export the new proof module and adjust tests to verify tags appear only when `DEV_PROOFS=1`.
+4. Implement analogous proof logging in Rust: global log with `emit` and `flush`, gated by `DEV_PROOFS` env var.
+5. Update Rust VM interpreter to emit tags for lens ops, asserts, calls, and final witness/normalization, mirroring TS behavior.
+6. Add Rust tests ensuring tags are emitted only in dev mode.
+7. Run `pnpm -C packages/tf-lang-l0-ts test` and `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml` to verify.
+8. Update `.codex/JOURNAL.md` with a new B2 entry; add a lesson if a new general rule emerges.
+
+## Tests
+- `pnpm -C packages/tf-lang-l0-ts test`
+- `cargo test --manifest-path packages/tf-lang-l0-rs/Cargo.toml`
+
+## Risks
+- Environment variable may leak between tests; ensure logs are flushed and variables reset.
+- Synchronizing tag structures across runtimes might be inconsistent.
+- Adding dependency `once_cell` for Rust logging could impact build.
+
+## Definition of Done
+- Proof tags emitted in both TS and Rust VMs only when `DEV_PROOFS=1`.
+- Tests cover presence and absence of tags.
+- Journal updated and repository tests pass.
diff --git a/packages/tf-lang-l0-rs/Cargo.lock b/packages/tf-lang-l0-rs/Cargo.lock
index 485414a..307911d 100644
--- a/packages/tf-lang-l0-rs/Cargo.lock
+++ b/packages/tf-lang-l0-rs/Cargo.lock
@@ -79,6 +79,12 @@ version = "2.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
 
+[[package]]
+name = "once_cell"
+version = "1.21.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
+
 [[package]]
 name = "pretty_assertions"
 version = "1.4.1"
@@ -168,6 +174,7 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "blake3",
+ "once_cell",
  "pretty_assertions",
  "serde",
  "serde_json",
diff --git a/packages/tf-lang-l0-rs/Cargo.toml b/packages/tf-lang-l0-rs/Cargo.toml
index 253a2b2..b007053 100644
--- a/packages/tf-lang-l0-rs/Cargo.toml
+++ b/packages/tf-lang-l0-rs/Cargo.toml
@@ -17,6 +17,7 @@ thiserror = "1"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1"
 blake3 = "1.5"
+once_cell = "1"
 
 [dev-dependencies]
 pretty_assertions = "1"
diff --git a/packages/tf-lang-l0-rs/src/env.rs b/packages/tf-lang-l0-rs/src/env.rs
new file mode 100644
index 0000000..a124ac3
--- /dev/null
+++ b/packages/tf-lang-l0-rs/src/env.rs
@@ -0,0 +1,25 @@
+use std::sync::{Mutex, OnceLock};
+/// Centralized, cached environment feature flags for the Rust runtime.
+static DEV_PROOFS: OnceLock<Mutex<Option<bool>>> = OnceLock::new();
+
+pub fn dev_proofs_enabled() -> bool {
+    let lock = DEV_PROOFS.get_or_init(|| Mutex::new(None));
+    let mut cache = lock.lock().unwrap();
+    if let Some(v) = *cache {
+        v
+    } else {
+        let v = std::env::var("DEV_PROOFS")
+            .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
+            .unwrap_or(false);
+        *cache = Some(v);
+        v
+    }
+}
+
+/// TESTS ONLY: clear cached flags
+#[doc(hidden)]
+pub fn __reset_env_cache_for_tests__() {
+    if let Some(lock) = DEV_PROOFS.get() {
+        *lock.lock().unwrap() = None;
+    }
+}
diff --git a/packages/tf-lang-l0-rs/src/lib.rs b/packages/tf-lang-l0-rs/src/lib.rs
index a0a116d..ab13c3a 100644
--- a/packages/tf-lang-l0-rs/src/lib.rs
+++ b/packages/tf-lang-l0-rs/src/lib.rs
@@ -5,5 +5,6 @@ pub mod util;
 pub mod vm;
 pub mod ops;
 pub mod proof;
+pub mod env;
 
 // Avoid glob re-exports at crate root to prevent ambiguous names (e.g., `types`).
diff --git a/packages/tf-lang-l0-rs/src/proof.rs b/packages/tf-lang-l0-rs/src/proof.rs
index 4a4ea5e..cd0f0da 100644
--- a/packages/tf-lang-l0-rs/src/proof.rs
+++ b/packages/tf-lang-l0-rs/src/proof.rs
@@ -42,3 +42,19 @@ pub enum ProofTag {
     Refutation { code: String, msg: Option<String> },
     Conservativity { callee: String, expected: String, found: String },
 }
+
+use once_cell::sync::Lazy;
+use std::sync::Mutex;
+use crate::env::dev_proofs_enabled;
+
+pub static PROOF_LOG: Lazy<Mutex<Vec<ProofTag>>> = Lazy::new(|| Mutex::new(Vec::new()));
+
+pub fn emit(tag: ProofTag) {
+    if dev_proofs_enabled() {
+        PROOF_LOG.lock().unwrap().push(tag);
+    }
+}
+
+pub fn flush() -> Vec<ProofTag> {
+    PROOF_LOG.lock().unwrap().drain(..).collect()
+}
diff --git a/packages/tf-lang-l0-rs/src/vm/interpreter.rs b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
index dab79dc..383cd83 100644
--- a/packages/tf-lang-l0-rs/src/vm/interpreter.rs
+++ b/packages/tf-lang-l0-rs/src/vm/interpreter.rs
@@ -2,6 +2,7 @@ use crate::canon::{blake3_hex, canonical_json_bytes};
 use crate::model::bytecode::Instr;
 use crate::model::{JournalEntry, Program, World};
 use crate::vm::opcode::Host;
+use crate::proof::{ProofTag, Effect, NormalizationTarget, TransportOp, Replace, emit};
 use serde_json::Value;
 
 /// Simple VM running SSA bytecode with JSON values as registers.
@@ -37,6 +38,7 @@ impl<'h> VM<'h> {
                 Instr::Assert { pred, msg } => {
                     let v = get(*pred, &regs)?;
                     if !v.as_bool().unwrap_or(false) {
+                        emit(ProofTag::Refutation { code: "ASSERT".into(), msg: Some(msg.clone()) });
                         return Err(VmError::Invalid(format!("ASSERT failed: {}", msg)).into());
                     }
                 }
@@ -97,6 +99,7 @@ impl<'h> VM<'h> {
                 }
                 Instr::LensProj { dst, state, region } => {
                     let sub = self.host.lens_project(get(*state, &regs)?, region)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensProj, region: region.clone() });
                     regs[*dst as usize] = sub;
                 }
                 Instr::LensMerge {
@@ -105,9 +108,10 @@ impl<'h> VM<'h> {
                     region,
                     sub,
                 } => {
-                    let merged =
-                        self.host
-                            .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    let merged = self
+                        .host
+                        .lens_merge(get(*state, &regs)?, region, get(*sub, &regs)?)?;
+                    emit(ProofTag::Transport { op: TransportOp::LensMerge, region: region.clone() });
                     regs[*dst as usize] = merged;
                 }
                 Instr::PlanSim {
@@ -173,7 +177,10 @@ impl<'h> VM<'h> {
                     for r in args {
                         a.push(get(*r, &regs)?.clone());
                     }
-                    let out = self.host.call_tf(tf_id, &a)?;
+                    let out = self.host.call_tf(tf_id, &a).map_err(|e| {
+                        emit(ProofTag::Conservativity { callee: tf_id.clone(), expected: "ok".into(), found: format!("{}", e) });
+                        e
+                    })?;
                     regs[*dst as usize] = out;
                 }
             }
@@ -184,10 +191,18 @@ impl<'h> VM<'h> {
         }
 
         let final_state = regs.get(0).cloned().unwrap_or(serde_json::Value::Null);
-        let out = if final_state == initial_state {
-            serde_json::Value::Null
+        let delta = if final_state == initial_state {
+            None
         } else {
-            serde_json::json!({ "replace": final_state })
+            Some(Replace { replace: final_state.clone() })
+        };
+        emit(ProofTag::Witness { delta: delta.clone(), effect: Effect::default() });
+        for target in [NormalizationTarget::Delta, NormalizationTarget::Effect] {
+            emit(ProofTag::Normalization { target });
+        }
+        let out = match delta {
+            None => serde_json::Value::Null,
+            Some(d) => serde_json::json!({ "replace": d.replace }),
         };
 
         Ok(out)
diff --git a/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
new file mode 100644
index 0000000..3ddfa82
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/dev_proofs_flag.rs
@@ -0,0 +1,14 @@
+use tflang_l0::env::{dev_proofs_enabled, __reset_env_cache_for_tests__};
+mod util;
+use util::env::EnvVarGuard;
+
+#[test]
+fn dev_proofs_is_cached() {
+    let _g = EnvVarGuard::set("DEV_PROOFS", "1");
+    assert!(dev_proofs_enabled());
+    drop(_g); // restore
+    // Flip env, but cache should hold until reset
+    let _g2 = EnvVarGuard::unset("DEV_PROOFS");
+    assert!(dev_proofs_enabled());
+    __reset_env_cache_for_tests__();
+}
diff --git a/packages/tf-lang-l0-rs/tests/proof_dev.rs b/packages/tf-lang-l0-rs/tests/proof_dev.rs
new file mode 100644
index 0000000..4511d35
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/proof_dev.rs
@@ -0,0 +1,65 @@
+use serde_json::json;
+use tflang_l0::model::{Instr, Program};
+use tflang_l0::vm::interpreter::VM;
+use tflang_l0::vm::opcode::Host;
+use tflang_l0::proof::{flush, ProofTag, TransportOp};
+use tflang_l0::env::__reset_env_cache_for_tests__;
+mod util;
+use util::env::EnvVarGuard;
+
+struct DummyHost;
+
+impl Host for DummyHost {
+    fn lens_project(&self, state: &serde_json::Value, region: &str) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"region": region, "state": state}))
+    }
+    fn lens_merge(&self, state: &serde_json::Value, _region: &str, substate: &serde_json::Value) -> anyhow::Result<serde_json::Value> {
+        Ok(json!({"orig": state, "sub": substate}))
+    }
+    fn snapshot_make(&self, state: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn snapshot_id(&self, _snapshot: &serde_json::Value) -> anyhow::Result<String> { Ok("id".into()) }
+    fn diff_apply(&self, state: &serde_json::Value, _delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(state.clone()) }
+    fn diff_invert(&self, delta: &serde_json::Value) -> anyhow::Result<serde_json::Value> { Ok(delta.clone()) }
+    fn journal_record(&self, _plan: &serde_json::Value, _delta: &serde_json::Value, _s0: &str, _s1: &str, _meta: &serde_json::Value) -> anyhow::Result<tflang_l0::model::JournalEntry> {
+        Ok(tflang_l0::model::JournalEntry(serde_json::Value::Null))
+    }
+    fn journal_rewind(&self, world: &tflang_l0::model::World, _entry: &tflang_l0::model::JournalEntry) -> anyhow::Result<tflang_l0::model::World> {
+        Ok(tflang_l0::model::World(world.0.clone()))
+    }
+    fn call_tf(&self, _tf_id: &str, _args: &[serde_json::Value]) -> anyhow::Result<serde_json::Value> { Ok(serde_json::Value::Null) }
+}
+
+fn sample_prog() -> Program {
+    Program {
+        version: "0.1".into(),
+        regs: 2,
+        instrs: vec![
+            Instr::Const { dst: 0, value: json!({}) },
+            Instr::LensProj { dst: 1, state: 0, region: "r".into() },
+            Instr::Const { dst: 0, value: json!({"x":1}) },
+            Instr::Halt,
+        ],
+    }
+}
+
+#[test]
+fn dev_proofs_toggles_tags() {
+    {
+        let _g = EnvVarGuard::set("DEV_PROOFS", "1");
+        __reset_env_cache_for_tests__();
+        let vm = VM { host: &DummyHost };
+        let _ = vm.run(&sample_prog()).unwrap();
+        let tags = flush();
+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Transport { op: TransportOp::LensProj, .. })));
+        assert!(tags.iter().any(|t| matches!(t, ProofTag::Witness { .. })));
+    }
+
+    {
+        let _g = EnvVarGuard::unset("DEV_PROOFS");
+        __reset_env_cache_for_tests__();
+        let vm = VM { host: &DummyHost };
+        let _ = vm.run(&sample_prog()).unwrap();
+        let tags = flush();
+        assert!(tags.is_empty());
+    }
+}
diff --git a/packages/tf-lang-l0-rs/tests/serde_shapes.rs b/packages/tf-lang-l0-rs/tests/serde_shapes.rs
new file mode 100644
index 0000000..e7135c4
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/serde_shapes.rs
@@ -0,0 +1,9 @@
+use serde_json::json;
+use tflang_l0::proof::{ProofTag, NormalizationTarget};
+
+#[test]
+fn proof_tag_normalization_shape() {
+    let n = ProofTag::Normalization { target: NormalizationTarget::Delta };
+    let v = serde_json::to_value(&n).unwrap();
+    assert_eq!(v, json!({"kind":"Normalization","target":"delta"}));
+}
diff --git a/packages/tf-lang-l0-rs/tests/util/env.rs b/packages/tf-lang-l0-rs/tests/util/env.rs
new file mode 100644
index 0000000..9cba035
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/util/env.rs
@@ -0,0 +1,26 @@
+use std::env;
+/// RAII guard for scoped env overrides to prevent test flakiness.
+pub struct EnvVarGuard {
+    key: String,
+    prev: Option<String>,
+}
+impl EnvVarGuard {
+    pub fn set(key: &str, val: &str) -> Self {
+        let prev = env::var(key).ok();
+        env::set_var(key, val);
+        Self { key: key.to_string(), prev }
+    }
+    pub fn unset(key: &str) -> Self {
+        let prev = env::var(key).ok();
+        env::remove_var(key);
+        Self { key: key.to_string(), prev }
+    }
+}
+impl Drop for EnvVarGuard {
+    fn drop(&mut self) {
+        match &self.prev {
+            Some(v) => env::set_var(&self.key, v),
+            None => env::remove_var(&self.key),
+        }
+    }
+}
diff --git a/packages/tf-lang-l0-rs/tests/util/mod.rs b/packages/tf-lang-l0-rs/tests/util/mod.rs
new file mode 100644
index 0000000..3d7924f
--- /dev/null
+++ b/packages/tf-lang-l0-rs/tests/util/mod.rs
@@ -0,0 +1 @@
+pub mod env;
diff --git a/packages/tf-lang-l0-ts/src/index.ts b/packages/tf-lang-l0-ts/src/index.ts
index 14746e5..3588d09 100644
--- a/packages/tf-lang-l0-ts/src/index.ts
+++ b/packages/tf-lang-l0-ts/src/index.ts
@@ -5,4 +5,4 @@ export * as check from './check/index.js';
 export { canonicalJsonBytes } from './canon/json.js';
 export { blake3hex } from './canon/hash.js';
 export * as ops from './ops/index.js';
-export * as proof from './proof/tags.js';
+export * as proof from './proof/index.js';
diff --git a/packages/tf-lang-l0-ts/src/proof/index.ts b/packages/tf-lang-l0-ts/src/proof/index.ts
new file mode 100644
index 0000000..c1a33e4
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/proof/index.ts
@@ -0,0 +1,17 @@
+export * from './tags.js';
+import type { ProofTag } from './tags.js';
+import { devProofsEnabled } from '../util/env';
+
+const log: ProofTag[] = [];
+
+export function emit(tag: ProofTag): void {
+  if (devProofsEnabled()) {
+    log.push(tag);
+  }
+}
+
+export function flush(): ProofTag[] {
+  const out = log.slice();
+  log.length = 0;
+  return out;
+}
diff --git a/packages/tf-lang-l0-ts/src/util/env.ts b/packages/tf-lang-l0-ts/src/util/env.ts
new file mode 100644
index 0000000..75bef9a
--- /dev/null
+++ b/packages/tf-lang-l0-ts/src/util/env.ts
@@ -0,0 +1,14 @@
+// Centralized, cached environment feature flags for the TS runtime.
+let _devProofs: boolean | undefined;
+export function devProofsEnabled(): boolean {
+  if (_devProofs === undefined) {
+    const v = (process.env.DEV_PROOFS || '').toLowerCase();
+    _devProofs = v === '1' || v === 'true';
+  }
+  return _devProofs;
+}
+
+// For tests only: reset the cached flag (not exported in build).
+export function __resetEnvCacheForTests__() {
+  _devProofs = undefined;
+}
diff --git a/packages/tf-lang-l0-ts/src/vm/interpreter.ts b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
index dc82803..c4b5fbe 100644
--- a/packages/tf-lang-l0-ts/src/vm/interpreter.ts
+++ b/packages/tf-lang-l0-ts/src/vm/interpreter.ts
@@ -2,6 +2,7 @@ import type { Program } from '../model/bytecode.js';
 import type { Host } from './opcode.js';
 import type { Value, World, JournalEntry } from '../model/types.js';
 import { canonicalJsonBytes, blake3hex } from '../canon/index.js';
+import { emit } from '../proof/index.js';
 
 export class VM {
   constructor(public host: Host) {}
@@ -41,8 +42,16 @@ export class VM {
         }
         case 'SNAP_MAKE': regs[ins.dst] = await this.host.snapshot_make(this.get(regs, ins.state)); break;
         case 'SNAP_ID': regs[ins.dst] = await this.host.snapshot_id(this.get(regs, ins.snapshot)); break;
-        case 'LENS_PROJ': regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region); break;
-        case 'LENS_MERGE': regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub)); break;
+        case 'LENS_PROJ': {
+          regs[ins.dst] = await this.host.lens_project(this.get(regs, ins.state), ins.region);
+          emit({ kind: 'Transport', op: 'LENS_PROJ', region: ins.region });
+          break;
+        }
+        case 'LENS_MERGE': {
+          regs[ins.dst] = await this.host.lens_merge(this.get(regs, ins.state), ins.region, this.get(regs, ins.sub));
+          emit({ kind: 'Transport', op: 'LENS_MERGE', region: ins.region });
+          break;
+        }
         case 'PLAN_SIM': {
           const res: any = await this.host.call_tf("tf://plan/simulate@0.1", [this.get(regs, ins.world), this.get(regs, ins.plan)]);
           regs[ins.dst_delta] = res?.delta ?? null;
@@ -67,12 +76,20 @@ export class VM {
         }
         case 'CALL': {
           const args = ins.args.map(a => this.get(regs, a));
-          regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          try {
+            regs[ins.dst] = await this.host.call_tf(ins.tf_id, args);
+          } catch (e: any) {
+            emit({ kind: 'Conservativity', callee: ins.tf_id, expected: 'ok', found: String(e) });
+            throw e;
+          }
           break;
         }
         case 'ASSERT': {
           const v = this.get(regs, ins.pred);
-          if (v !== true) throw new Error(`ASSERT failed: ${ins.msg}`);
+          if (v !== true) {
+            emit({ kind: 'Refutation', code: 'ASSERT', msg: ins.msg });
+            throw new Error(`ASSERT failed: ${ins.msg}`);
+          }
           break;
         }
         default: {
@@ -91,10 +108,10 @@ export class VM {
     // identity => null; otherwise full replace
     const a = canonicalJsonBytes(initialState);
     const b = canonicalJsonBytes(finalState);
-    if (Buffer.from(a).equals(Buffer.from(b))) {
-      return null;
-    }
-    return { replace: finalState };
+    const delta = Buffer.from(a).equals(Buffer.from(b)) ? null : { replace: finalState };
+    emit({ kind: 'Witness', delta, effect: { read: [], write: [], external: [] } });
+    ['delta', 'effect'].forEach(target => emit({ kind: 'Normalization', target: target as any }));
+    return delta;
   }
 }
 
diff --git a/packages/tf-lang-l0-ts/tests/helpers/env.ts b/packages/tf-lang-l0-ts/tests/helpers/env.ts
new file mode 100644
index 0000000..3068297
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/helpers/env.ts
@@ -0,0 +1,22 @@
+// Scoped env override for tests to avoid leaking state across parallel cases.
+export async function withEnv<T>(
+  vars: Record<string, string | undefined>,
+  fn: () => Promise<T> | T
+): Promise<T> {
+  const prev: Record<string, string | undefined> = {};
+  for (const k of Object.keys(vars)) {
+    prev[k] = process.env[k];
+    const v = vars[k];
+    if (v === undefined) delete process.env[k];
+    else process.env[k] = v;
+  }
+  try {
+    return await fn();
+  } finally {
+    for (const k of Object.keys(vars)) {
+      const v = prev[k];
+      if (v === undefined) delete process.env[k];
+      else process.env[k] = v;
+    }
+  }
+}
diff --git a/packages/tf-lang-l0-ts/tests/proof-dev.test.ts b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
new file mode 100644
index 0000000..23f3f48
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proof-dev.test.ts
@@ -0,0 +1,40 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { VM } from '../src/vm/index.js';
+import type { Program } from '../src/model/bytecode.js';
+import { DummyHost } from '../src/host/memory.js';
+import { flush } from '../src/proof/index.js';
+import { withEnv } from './helpers/env';
+import { __resetEnvCacheForTests__ } from '../src/util/env';
+
+describe('proof dev mode', () => {
+  afterEach(() => __resetEnvCacheForTests__());
+  const prog: Program = {
+    version: '0.1',
+    regs: 2,
+    instrs: [
+      { op: 'CONST', dst: 0, value: {} },
+      { op: 'LENS_PROJ', dst: 1, state: 0, region: 'r' },
+      { op: 'CONST', dst: 0, value: { x: 1 } },
+      { op: 'HALT' },
+    ],
+  };
+
+  it('emits tags when DEV_PROOFS=1', async () => {
+    await withEnv({ DEV_PROOFS: '1' }, async () => {
+      const vm = new VM(DummyHost);
+      await vm.run(prog);
+      const tags = flush();
+      expect(tags.some(t => t.kind === 'Transport')).toBe(true);
+      expect(tags.some(t => t.kind === 'Witness')).toBe(true);
+    });
+  });
+
+  it('no tags when DEV_PROOFS is unset', async () => {
+    await withEnv({ DEV_PROOFS: undefined }, async () => {
+      const vm = new VM(DummyHost);
+      await vm.run(prog);
+      const tags = flush();
+      expect(tags.length).toBe(0);
+    });
+  });
+});
diff --git a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
index 73f4ae2..84020f7 100644
--- a/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
+++ b/packages/tf-lang-l0-ts/tests/proof-tags.test.ts
@@ -1,5 +1,5 @@
 import { describe, it, expect } from 'vitest';
-import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/tags.js';
+import type { Witness, Normalization, Transport, Refutation, Conservativity, ProofTag } from '../src/proof/index.js';
 
 describe('proof tags', () => {
   it('compile tag shapes', () => {
diff --git a/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
new file mode 100644
index 0000000..62d88ab
--- /dev/null
+++ b/packages/tf-lang-l0-ts/tests/proofs/dev_proofs_flag.test.ts
@@ -0,0 +1,17 @@
+import { describe, it, expect, afterEach } from 'vitest';
+import { devProofsEnabled, __resetEnvCacheForTests__ } from '../../src/util/env';
+import { withEnv } from '../helpers/env';
+
+describe('DEV_PROOFS caching (TS)', () => {
+  afterEach(() => __resetEnvCacheForTests__());
+
+  it('reads once and caches', async () => {
+    await withEnv({ DEV_PROOFS: '1' }, () => {
+      expect(devProofsEnabled()).toBe(true);
+    });
+    // Flip env but cache should hold until reset
+    await withEnv({ DEV_PROOFS: '0' }, () => {
+      expect(devProofsEnabled()).toBe(true);
+    });
+  });
+});
```

## Meta (JSON)
```json
{"author":{"id":"MDQ6VXNlcjQ1Mjg3Mzk1","is_bot":false,"login":"andreidita22","name":""},"createdAt":"2025-09-12T08:13:22Z","isDraft":false,"mergeStateStatus":"CLEAN","number":27,"reviewDecision":"","reviews":[{"id":"PRR_kwDOPs5-l86_pfhA","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Summary of Changes\n\nHello @andreidita22, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!\n\nThis pull request enhances the debugging and introspection capabilities of the system by introducing \"proof tags\" that provide detailed insights into the execution flow of both TypeScript and Rust virtual machines. These tags, which capture events like state transformations, assertions, and function calls, are conditionally emitted only when a DEV_PROOFS environment variable is set, preventing performance overhead in production. The changes also include robust mechanisms for caching this environment variable and isolating its state during testing, ensuring reliable and predictable behavior across development and test environments.\n\n### Highlights\n\n* **Conditional Proof Tag Emission**: Implemented a mechanism to emit various proof tags (Witness, Normalization, Transport, Refutation, Conservativity) in both TypeScript and Rust runtimes, but only when the DEV_PROOFS environment variable is enabled.\n* **Performance Optimization & Test Isolation**: Introduced caching for the DEV_PROOFS flag in both runtimes to avoid repeated environment variable lookups, along with test-only reset hooks and scoped environment helpers to ensure test isolation and prevent leakage of environment state.\n* **Proof Tag Serialization Lock**: Added a test to lock the serialization shape of ProofTag::Normalization in Rust, ensuring consistency and preventing accidental breaking changes to the proof tag structure.\n* **Comprehensive Tagging**: Integrated proof tag emission into key VM operations, including lens projections/merges, assertion failures, and function call errors, as well as final witness and normalization states.\n\n\n\n\n\n<details>\n<summary><b>Using Gemini Code Assist</b></summary>\n<br>\n\nThe full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.\n\n<b>Invoking Gemini</b>\n\nYou can request assistance from Gemini at any point in your pull request via creating an issue comment (i.e. comment on the pull request page) using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands.\n\nFeature | Command | Description\n--- | --- | ---\nCode Review | `/gemini review` | Performs a code review for the current pull request in its current state.\nPull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.\nComment | @gemini-code-assist | Responds in comments when explicitly tagged, both in issue comments and review comments.\nHelp | `/gemini help` | Displays a list of available commands.\n\n<b>Customization</b>\n\nTo customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).\n\n<b>Limitations & Feedback</b>\n\nGemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).\n\n<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>\n</details>\n\n\n\n\n[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).\n","submittedAt":"2025-09-12T08:13:50Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2c4bc59231ec0823937911a7c4ee1bcbb2ec0343"}},{"id":"PRR_kwDOPs5-l86_phO4","author":{"login":"gemini-code-assist"},"authorAssociation":"NONE","body":"## Code Review\n\nThis pull request introduces proof tag emission in dev mode for both Rust and TypeScript runtimes, controlled by a `DEV_PROOFS` environment variable. The changes include caching for the flag check to optimize performance and new test helpers for managing environment variables to ensure test stability. The implementation is solid, and my feedback focuses on potential performance improvements, enhancing robustness against panics in the Rust code, addressing thread-safety concerns in tests, and improving test coverage and type safety.","submittedAt":"2025-09-12T08:16:12Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2c4bc59231ec0823937911a7c4ee1bcbb2ec0343"}},{"id":"PRR_kwDOPs5-l86_phiy","author":{"login":"chatgpt-codex-connector"},"authorAssociation":"NONE","body":"Codex Review: Here are some suggestions.\n\nReply with `@codex fix comments` to fix any unresolved comments.\n\n<details> <summary>About Codex in GitHub</summary>\n\n[Your team has set up Codex to review pull requests in this repo](http://chatgpt.com/codex/settings/general). Reviews are triggered when you open a pull request for review, mark a draft as ready, or comment \"@codex review\". If Codex has suggestions, it will comment; otherwise it will react with üëç.\n\nCodex can also answer questions or update the PR. Try commenting \"@codex fix this CI failure\" or \"@codex address that feedback\".\n</details>","submittedAt":"2025-09-12T08:16:28Z","includesCreatedEdit":false,"reactionGroups":[],"state":"COMMENTED","commit":{"oid":"2c4bc59231ec0823937911a7c4ee1bcbb2ec0343"}}],"statusCheckRollup":[{"__typename":"CheckRun","completedAt":"2025-09-12T08:14:04Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668720003/job/50215453407","name":"conformance","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"Conformance (TS ‚Üî Rust)"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:36Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453439","name":"TypeScript build & test","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:32Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215453460","name":"changed","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:14:09Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719996/job/50215453452","name":"Rust build & test","startedAt":"2025-09-12T08:13:28Z","status":"COMPLETED","workflowName":"ci"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:47Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462938","name":"ts","startedAt":"2025-09-12T08:13:36Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:14:09Z","conclusion":"SUCCESS","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462922","name":"rust","startedAt":"2025-09-12T08:13:38Z","status":"COMPLETED","workflowName":"ci-fast"},{"__typename":"CheckRun","completedAt":"2025-09-12T08:13:33Z","conclusion":"SKIPPED","detailsUrl":"https://github.com/LexLattice/tf-lang/actions/runs/17668719977/job/50215462872","name":"golden","startedAt":"2025-09-12T08:13:33Z","status":"COMPLETED","workflowName":"ci-fast"}],"title":"B2: emit proof tags in dev mode","updatedAt":"2025-09-12T08:16:28Z","url":"https://github.com/LexLattice/tf-lang/pull/27"}
```
