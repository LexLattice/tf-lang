# Track A Findings (Top 10)

1. **S2 · C2** — `wrapWithAuthorize` emits `Authorize{…}` with an uppercase `A`, but the parser only recognizes lowercase `authorize`, so the quick-fix produces syntactically invalid DSL. Evidence: `packages/tf-lsp-server/src/actions/wrap-authorize.mjs` lines 1-35 vs tokenizer in `packages/tf-compose/src/parser.mjs` lines 38-75. **Repro:** trigger the quick fix on any protected primitive; the new block fails to parse and `checkIR` reports `UndefinedPrimitive`. **Fix sketch:** change the template to `authorize{ scope: "" } {` (lowercase) and add a unit test covering the action. **Risk if deferred:** users apply auto-fixes that immediately break the document and flood diagnostics.

2. **S1 · C2** — The custom `tf/sourceMap` request reads `params.file` directly from disk with `readFile` without any path validation, enabling arbitrary file reads when the client is compromised. Evidence: `packages/tf-lsp-server/src/server.ts` lines 66-97. **Repro:** send a JSON-RPC request with `file: '/etc/passwd'`; the server returns its contents as a range. **Fix sketch:** restrict lookup to open documents (via `documents.get`) or enforce a workspace root allowlist before reading. **Risk if deferred:** LSP hosts expose local secrets to any client-side exploit.

3. **S3 · C2** — `offsetToPosition` walks the entire source for every lookup, turning hover and diagnostics into O(n²) work on large files. Evidence: `packages/tf-lsp-server/src/server.ts` lines 531-548. **Repro:** hover repeatedly in a 5k-line file and observe CPU spikes. **Fix sketch:** reuse `TextDocument.positionAt` by creating a lightweight `TextDocument` once per request or precomputing line offsets. **Risk if deferred:** latency grows quadratically, making the LSP unusable on real specs.

4. **S3 · C2** — `extractFQSymbol` splits the entire document on every hover request (`text.split(/\r?\n/)`), allocating O(n) per invocation. Evidence: `packages/tf-lsp-server/src/server.ts` lines 563-586. **Repro:** profile hover on a large document; GC churn dominates. **Fix sketch:** access the current line via `TextDocument.getText({ start, end })` or cache `doc.getText()` slices. **Risk if deferred:** hover throughput collapses on large specs.

5. **S3 · C2** — Diagnostics from `checkIR` are emitted at `docStartRange`, so every rule violation highlights line 0 instead of the offending primitive. Evidence: `packages/tf-lsp-server/src/server.ts` lines 437-456. **Repro:** introduce two undefined primitives; both diagnostics point at the file start. **Fix sketch:** plumb source spans from the IR (e.g., pass token positions through `parseDSL`) and map reasons to ranges. **Risk if deferred:** developers cannot locate violations quickly.

6. **S3 · C2** — String literals copy escape sequences verbatim (`\n` stays `'n'`), because `tokenize` simply appends the escaped character. Evidence: `packages/tf-compose/src/parser.mjs` lines 171-194. **Repro:** author `prim(foo: "line\nfeed")`; runtime receives `line nfeed`. **Fix sketch:** decode common escapes (`n`, `t`, `"`, `\`) when building `buf`. **Risk if deferred:** DSL cannot express structured payloads without downstream patching.

7. **S2 · C2** — The lexer only treats `authorize` as a region when the next character is `{` or `(` with no intervening whitespace, rejecting idiomatic `authorize { … }`. Evidence: `packages/tf-compose/src/parser.mjs` lines 33-52. **Repro:** format a block as `authorize { ... }`; parsing fails with `Unexpected character`. **Fix sketch:** skip whitespace between the keyword and delimiter. **Risk if deferred:** formatter output or manual spacing breaks parsing.

8. **S3 · C2** — `computeInlineLetActions` assumes single-line initializers; `findLetDeclaration` stops at the first newline, so inlining a multi-line `let` splices incomplete code. Evidence: `packages/tf-lsp-server/src/server.ts` lines 343-373. **Repro:** inline a `let` whose initializer spans a `seq{}` block; the action drops trailing clauses. **Fix sketch:** extend the parser to balance braces or reuse the DSL AST for ranges. **Risk if deferred:** refactorings silently corrupt code.

9. **S4 · C2** — `findOccurrences` uses a plain regex without the `u` flag, so identifiers containing Unicode letters aren’t matched. Evidence: `packages/tf-lsp-server/src/server.ts` lines 406-414. **Repro:** select an identifier containing `é`; introduce-let does nothing. **Fix sketch:** add the `u` flag and broaden `isIdentifierChar` to `\p{ID_Start}` classes. **Risk if deferred:** non-ASCII identifiers remain unsupported.

10. **S4 · C1** — Hover signature lookup falls back to `name(...)` for any primitive missing `input.object`, even if `input.array` exists, omitting argument information. Evidence: `packages/tf-lsp-server/src/server.ts` lines 593-606. **Repro:** hover a primitive defined with array inputs; hover shows `prim(...)`. **Fix sketch:** inspect additional schema shapes (`array`, `oneOf`) before falling back. **Risk if deferred:** hover documentation remains incomplete for many primitives.
