# Track B Findings (Top 10)

1. **S2 · C2** — `updateTraceIdsFromWasm` blindly calls `Array.from(raw, ...)`; if the WASM binding returns a string (the default export in `tf-eval-wasm`), it is split into single characters, producing hundreds of bogus trace IDs. Evidence: `packages/tf-run-wasm/src/index.ts` lines 94-103. **Repro:** force the wasm stub to return `'tf:foo@1'`; runtime emits one-character trace rows. **Fix sketch:** normalize to `Array.isArray(raw) ? [...raw] : [raw]` and filter out empty values. **Risk if deferred:** downstream tooling sees corrupted trace identifiers.

2. **S2 · C2** — `enumerateComponentPlans` assumes every spec `step.op` exists in `choiceLibrary`. A new op yields `library === undefined`, so `library.forEach` throws. Evidence: `packages/tf-plan-enum/src/index.ts` lines 248-255. **Repro:** add a `step` with `op: "migrate_db"`; the CLI crashes before validation. **Fix sketch:** guard with `if (!Array.isArray(library)) throw new Error("Unknown op ...")` and surface the failure early. **Risk if deferred:** runtime cannot evolve with new ops without code changes.

3. **S3 · C2** — When both `irSource` and `irPath` are absent, `run` still issues `readFile(String(opts.irPath), 'utf8')`, i.e. `readFile('undefined')`, on every call before falling back to `'{}'`. Evidence: `packages/tf-run-wasm/src/index.ts` lines 160-162. **Repro:** invoke the CLI with only `--trace-path`; strace shows an `open("undefined")` per run. **Fix sketch:** short-circuit when neither `irSource` nor `irPath` is provided. **Risk if deferred:** unnecessary syscalls slow tight loops and spam logs on some platforms.

4. **S3 · C1** — `ensureParentDirectory` calls `mkdir(dirname(path))`; when `path` already ends with `/`, `dirname` collapses to itself and `mkdir` recurses into the file name. Evidence: `packages/tf-run-wasm/src/index.ts` lines 155-181. **Repro:** set `tracePath` to `out/trace/`; the runtime creates a directory named `trace/` and then fails to write the file. **Fix sketch:** reject paths ending with `/` or normalize with `path.resolve` + `path.basename`. **Risk if deferred:** misconfigured paths silently do nothing.

5. **S3 · C2** — `updateTraceIdsFromWasm` trusts the wasm payload size; an attacker can return a million IDs and exhaust memory when serialising traces. Evidence: `packages/tf-run-wasm/src/index.ts` lines 94-104. **Repro:** patch the wasm shim to return an array of 1e6 entries; the stub copies them into JS and OOMs. **Fix sketch:** cap length (e.g. 1k) and log a warning when exceeded. **Risk if deferred:** malformed wasm modules can crash CLI invocations.

6. **S3 · C2** — `rescorePlan` silently drops dependency IDs that are missing from the node map, so the recomputed score ignores part of the graph. Evidence: `packages/tf-plan/src/index.ts` lines 70-88. **Repro:** delete a node from `plan.nodes` while leaving its ID in a branch’s `deps`; the rescore runs without warning and averages fewer dependencies. **Fix sketch:** throw when any dependency lookup fails. **Risk if deferred:** runtime recomputes bogus scores on corrupted plan graphs.

7. **S4 · C2** — `writeNdjson` writes the entire file in one `writeFile`; large plans trigger single huge allocations. Evidence: `packages/tf-plan/src/index.ts` lines 104-112. **Repro:** score a plan with 100k nodes; memory usage spikes. **Fix sketch:** stream via `createWriteStream` or chunk per 10k nodes. **Risk if deferred:** out-of-memory on big enumerations.

8. **S3 · C1** — `enumerateBranches` slices `sortedOptions` by `beamWidth` but never validates that `beamWidth > 0`; specifying zero yields “Enumeration finished without branch nodes,” masking the configuration error. Evidence: `packages/tf-plan-enum/src/index.ts` lines 312-356. **Repro:** pass `--beam-width 0`; runtime throws an unhelpful generic error. **Fix sketch:** assert `beamWidth >= 1` and return a descriptive message. **Risk if deferred:** users misdiagnose configuration mistakes as engine failures.

9. **S4 · C2** — `aggregateScore` averages branch scores even though totals are weighted sums already; mixing averages and totals double-normalises results. Evidence: `packages/tf-plan-enum/src/index.ts` lines 184-203. **Repro:** compare aggregate vs raw totals; aggregated totals drift lower. **Fix sketch:** compute weighted totals directly (`sum(score.total)` / components). **Risk if deferred:** branch comparisons skew toward low-cardinality combinations.

10. **S4 · C1** — `readSpec` loads the entire JSON before validation. Very large specs (~50 MB) block the event loop and risk crashes. Evidence: `packages/tf-plan-enum/src/index.ts` lines 334-339. **Repro:** feed a 50 MB spec; CPU pegged for seconds. **Fix sketch:** stream-parse or enforce a max size with `stat` before reading. **Risk if deferred:** large specs degrade CLI responsiveness.
