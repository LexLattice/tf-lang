# Track D Findings (Top 10)

1. **S2 · C2** — `applyInverseOnce` removes any `serialize` → `deserialize` pair without checking operands, so mismatched codecs are eliminated. Evidence: `packages/tf-opt/lib/plan-apply.mjs` lines 98-118. **Repro:** run on IR containing `serialize_json |> deserialize_binary`; the pass deletes both nodes. **Fix sketch:** compare arguments (e.g., schema IDs) before splicing. **Risk if deferred:** optimizer produces plans that drop necessary conversions.

2. **S2 · C2** — Commute obligations ignore the recorded direction; `applyCommuteOnce` swaps whenever the right primitive name matches, even if the obligation specified `direction: 'left'` or `'right'`. Evidence: obligation capture in `packages/tf-opt/lib/rewrite-detect.mjs` lines 40-74 vs application in `plan-apply.mjs` lines 66-95. **Repro:** feed an obligation with `direction: 'right'`; the optimizer still commutes leftwards. **Fix sketch:** honour direction when deciding to swap. **Risk if deferred:** unsafe commutations reorder side-effecting primitives.

3. **S3 · C2** — `cloneIr` falls back to `JSON.parse(JSON.stringify(ir))`, erasing `BigInt`, `Date`, and prototype data that upstream IR nodes may carry (e.g., source spans). Evidence: `packages/tf-opt/lib/plan-apply.mjs` lines 10-18. **Repro:** annotate IR nodes with `loc`; after optimization the property disappears. **Fix sketch:** require Node ≥17 and rely on `structuredClone`, or implement a custom clone preserving known metadata. **Risk if deferred:** later passes lose source mapping information.

4. **S3 · C1** — `applyCommuteOnce` mutates the shared array in place, so repeated passes over sibling arrays can miss opportunities after a swap. Evidence: `packages/tf-opt/lib/plan-apply.mjs` lines 66-95. **Repro:** three-node chain `emit-metric |> pure |> emit-metric`; only the first pair commutes, leaving the second stuck. **Fix sketch:** restart the loop after each swap or collect swap indices first. **Risk if deferred:** optimizer under-applies valid rewrites.

5. **S3 · C2** — `extractPrimitivesFromIr` skips primitive names embedded inside argument objects (e.g., nested workflows) because it only recurses into values that are objects and not strings. Evidence: `packages/tf-opt/lib/rewrite-detect.mjs` lines 7-24. **Repro:** IR with `{ node:'Prim', prim:'compose', args:{ inner:{ node:'Prim', prim:'serialize' }}}`; the inner primitive is ignored. **Fix sketch:** traverse nested objects recursively regardless of key. **Risk if deferred:** detector misses rewrite opportunities.

6. **S3 · C2** — `analyzePrimitiveSequence` builds obligations even when `effectMap` lacks an entry, so `currentEff` becomes `undefined` and commute checks fall back to empty arrays. Evidence: `packages/tf-opt/lib/rewrite-detect.mjs` lines 25-73. **Repro:** run against a primitive absent from the catalog; the analyzer still emits commute obligations. **Fix sketch:** skip entries missing effect metadata. **Risk if deferred:** optimizer assumes commutativity for unknown primitives.

7. **S3 · C1** — Idempotent detection uses `isDeepStrictEqual`, which fails when nodes differ only in non-semantic metadata (e.g., generated IDs). Evidence: `packages/tf-opt/lib/plan-apply.mjs` lines 123-143. **Repro:** duplicate `hash` nodes with different `loc`; the pass refuses to collapse them. **Fix sketch:** compare canonicalized nodes (drop metadata keys) before equality. **Risk if deferred:** optimizer misses safe deduplications.

8. **S4 · C2** — Rewrite loop runs until no changes but has no iteration cap. A buggy obligation that keeps toggling two nodes (e.g., alternating commute partners) can spin forever. Evidence: `packages/tf-opt/lib/plan-apply.mjs` lines 183-200. **Fix sketch:** track iteration count and abort after a sane limit. **Risk if deferred:** malformed obligations hang optimization.

9. **S4 · C2** — `loadPrimitiveEffectMap` caches the catalog globally but never invalidates on spec updates, so hot reloads see stale effect data. Evidence: `packages/tf-opt/lib/data.mjs` lines 24-45. **Repro:** modify `catalog.json`; optimizer still reads the old map until process restart. **Fix sketch:** expose a `resetEffectCache()` used by tooling in watch mode. **Risk if deferred:** local dev sees inconsistent rewrite suggestions.

10. **S4 · C1** — `canonicalLawName` doesn’t normalise case, whereas law IDs in obligations are lowercase. Evidence: `packages/tf-opt/lib/data.mjs` lines 53-60. **Repro:** pass `Idempotent:Hash`; lookup fails. **Fix sketch:** lower-case incoming names when canonicalising. **Risk if deferred:** tooling rejecting equivalent law names.
