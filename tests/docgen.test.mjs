import assert from 'node:assert/strict';
import { createHash } from 'node:crypto';
import { readFile, stat } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import test from 'node:test';

import { generateCatalogDoc } from '../scripts/docgen/catalog.mjs';
import { generateDSLDoc } from '../scripts/docgen/dsl.mjs';
import { generateEffectsDoc } from '../scripts/docgen/effects.mjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');

function ensureSingleTrailingNewline(content) {
  assert.ok(content.endsWith('\n'), 'output should end with a newline');
  assert.ok(!content.endsWith('\n\n'), 'output should end with a single newline');
}

function parseBanner(content, scriptPath) {
  const newlineIndex = content.indexOf('\n');
  assert.ok(newlineIndex > 0, 'document must include a banner line');
  const bannerLine = content.slice(0, newlineIndex);
  const pattern = new RegExp(`^<!-- generated by ${scriptPath.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&')}; do not edit by hand; sha256:([0-9a-f]{64}) -->$`);
  const match = bannerLine.match(pattern);
  assert.ok(match, `banner should mention ${scriptPath}`);
  const body = content.slice(newlineIndex + 1);
  const digest = match[1];
  const computed = createHash('sha256').update(body).digest('hex');
  assert.strictEqual(computed, digest, 'banner digest should match body content');
  return { bannerLine, body, digest };
}

function slugifyHeading(text) {
  return text
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-');
}

function collectHeadingSlugs(content) {
  const slugs = new Set();
  const lines = content.split(/\r?\n/);
  for (const line of lines) {
    const match = line.match(/^(#+)\s+(.*)$/);
    if (!match) continue;
    const slug = slugifyHeading(match[2]);
    if (slug) {
      slugs.add(slug);
    }
  }
  return slugs;
}

test('doc generators are deterministic and expose anchors', async () => {
  const catalogPath = await generateCatalogDoc({ root: repoRoot });
  await stat(catalogPath);
  const catalogContent = await readFile(catalogPath, 'utf8');
  ensureSingleTrailingNewline(catalogContent);
  parseBanner(catalogContent, 'scripts/docgen/catalog.mjs');
  const trimmed = catalogContent.trimEnd();
  const countLine = trimmed.split('\n').find(line => line.startsWith('Primitives: '));
  assert.ok(countLine, 'catalog doc should report primitive count');

  const catalogJson = JSON.parse(await readFile(path.join(repoRoot, 'packages', 'tf-l0-spec', 'spec', 'catalog.json'), 'utf8'));
  const expectedCount = Array.isArray(catalogJson?.primitives) ? catalogJson.primitives.length : 0;
  assert.strictEqual(countLine, `Primitives: ${expectedCount}`);

  await generateCatalogDoc({ root: repoRoot });
  const catalogContentAgain = await readFile(catalogPath, 'utf8');
  assert.strictEqual(catalogContentAgain, catalogContent);

  const dslPath = await generateDSLDoc({ root: repoRoot });
  await stat(dslPath);
  const dslContent = await readFile(dslPath, 'utf8');
  ensureSingleTrailingNewline(dslContent);
  parseBanner(dslContent, 'scripts/docgen/dsl.mjs');
  await generateDSLDoc({ root: repoRoot });
  const dslContentAgain = await readFile(dslPath, 'utf8');
  assert.strictEqual(dslContentAgain, dslContent);

  const effectsPath = await generateEffectsDoc({ root: repoRoot });
  await stat(effectsPath);
  const effectsContent = await readFile(effectsPath, 'utf8');
  ensureSingleTrailingNewline(effectsContent);
  parseBanner(effectsContent, 'scripts/docgen/effects.mjs');
  await generateEffectsDoc({ root: repoRoot });
  const effectsContentAgain = await readFile(effectsPath, 'utf8');
  assert.strictEqual(effectsContentAgain, effectsContent);

  const readme = await readFile(path.join(repoRoot, 'README.md'), 'utf8');
  const docContents = new Map([
    ['docs/l0-catalog.md', catalogContent],
    ['docs/l0-dsl.md', dslContent],
    ['docs/l0-effects.md', effectsContent]
  ]);
  const linkPattern = /\[[^\]]+\]\((docs\/l0-[^)]+\.md)(#[^)]+)?\)/g;
  let match;
  while ((match = linkPattern.exec(readme)) !== null) {
    const docPath = match[1];
    const anchor = match[2];
    if (!anchor) continue;
    const content = docContents.get(docPath);
    assert.ok(content, `README references ${docPath} which should exist`);
    const slugs = collectHeadingSlugs(content);
    const anchorSlug = anchor.slice(1).toLowerCase();
    assert.ok(slugs.has(anchorSlug), `anchor ${anchor} should match a heading in ${docPath}`);
  }
});
